{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MatrixOne Documentation Welcome to MatrixOne documentation! MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine, across multiple datacenters, clouds, edges and other heterogenous infrastructures. If you find documentation issues, feel free to create an Issue to let us know or directly create a Pull Request to help fix or update it. Recommended articles Overview Get Started Reference MatrixOne Introduction Install MatrixOne SQL Reference MatrixOne Architecture Connect to MatrixOne Server v0.4.0 Release Notes MatrixCube Introduction SSB Test with MatrixOne","title":"Home"},{"location":"#matrixone-documentation","text":"Welcome to MatrixOne documentation! MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine, across multiple datacenters, clouds, edges and other heterogenous infrastructures. If you find documentation issues, feel free to create an Issue to let us know or directly create a Pull Request to help fix or update it.","title":"MatrixOne Documentation"},{"location":"#recommended-articles","text":"Overview Get Started Reference MatrixOne Introduction Install MatrixOne SQL Reference MatrixOne Architecture Connect to MatrixOne Server v0.4.0 Release Notes MatrixCube Introduction SSB Test with MatrixOne","title":"Recommended articles"},{"location":"MatrixOne/glossary/","text":"Glossary Terms It's helpful to understand a few terms before reading our architecture documentation. Term Definition A AST (Abstract syntax tree) Abstract Syntax Trees or ASTs are tree representations of code. They are a fundamental part of the way a compiler works. C Cluster A distributed MatrixOne deployment, which acts as a single logical application. D Data Storage A DataStorage is an interface for implementing distributed storage service. It must be defined in prior to using MatrixCube. DataStorage needs to be implemented based on the characteristics of storage engine. E Event Notify The machanism of synchronizing heartbeat information to all nodes is called an event notify. F Factorization The factorization method uses basic factorization formula to reduce any algebraic or quadratic equation into its simpler form. MatrixOne uses compact factorized representations at the physical layer to reduce data redundancy and boost query performance. H Heartbeat Every node in a MatrixOne cluster will periodically sends its status information, this information is called a heartbeat. M MatrixCube MatrixCube is a framework for building distributed systems, which offers guarantees about reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers only need to focus on the business logic on a single node. P Prophet Prophet is a scheduling module in MatrixCube. It takes charge of Auto-Rebalance, which keeps the system storage level and read/write throughput level balanced across Stores. The initial 3 Stores of a MatrixCube cluster are all Prophet Nodes. Pure Storage In contrast to Prophet, pure storage is another type of node, which doesn't handle any scheduling job and works as simple storage. R Replica To provide reliable service, each shard is stored not only once, it will have several copy stored in different stores. Every copy of a shard is called a Replica. S Snapshot Isolation (SI) Snapshot Isolation is a multi-version concurrency control approach that is widely used in practice. MatrixOne supports distributed transaction of snapshot isolation level. Store A MatrixCube distributed system consists of several physical servers, our data are stored across these physical server. We call each server inside this cluster a Store. Shard In MatrixOne, the data are split into different partitions to store in order to get better scalability. Each partition is called a Shard. In our design, a new created table is initially a Shard. When the size of the table exceeds the Shard size limit, the Shard will split. Shard Splitting There is a certain limit to a Shard size. Whenever a Shard exceeds its storage limit, MatrixCube splits a Shard into two Shards and keep each Shard with the same storage level. Shard Proxy The Shard Proxy is a central module to accept all user read/write requests and route requests to corresponding nodes. Concepts MatrixOne relies heavily on the following concepts. Being familiar with them will help you understand what our architecture achieves. Term Definition A Auto-Rebalance A modern distributed database should do more than just split data amongst a number of servers. The automatic process of storage and workload distribution among servers is called an Auto-Rebalance. C Consistency MatrixOne supports a strong consistency. It is guaranted that after any successful data write, the reading afterwards will get the latest value, no matter from which store. E Execution Plan An execution plan in a database is a simple graphical representation of the operations that the query optimizer generates to calculate the most efficient way to return a set of results. F Fault-Tolerance Fault-Tolerance simply means a system's ability to continue operating uninterrupted despite the failure of one or more of its components. J JIT Compilation Turns SQL plan tree or Intermediate Representation code into a native program using LLVM at runtime. M Monolithic Engine A monolithic database engine is designed to support hybrid workloads: transactional, analytical, streaming, time-series, machine learning, etc. Materialized View A materialized view is a pre-computed data set derived from a query specification (the SELECT in the view definition) and stored for later use. Materialized view is usually used for increasing performance and efficiency. Metadata Metadata is the data that describes the structure and creation method of data in a database. P Paxos Paxos is an algorithm that is used to achieve consensus among a distributed set of computers that communicate via an asynchronous network. R Raft Raft is a consensus algorithm that is designed to be easy to understand. It's equivalent to Paxos in fault-tolerance and performance. The difference is that it's decomposed into relatively independent subproblems, and it cleanly addresses all major pieces needed for practical systems. Raft Group and Leader Raft defines a strong, single leader and number of followers in a group of peers. The group represents a replicated state machine. Only the leader may service client requests. The leader replicates actions to the followers. S SIMD instruction SIMD is short for Single Instruction/Multiple Data, while the term SIMD operations refers to a computing method that enables processing of multiple data with a single instruction. T Transaction A set of operations performed on your database that satisfy the requirements of ACID semantics. V Vectorized Execution Vectorized data processing helps with developing faster analytical query engines by making efficient utilization of CPU cache. Arrow's columnar format allows to use lightweight schemes like dictionary encoding, bit packing, and run length encoding, which favor query performance over compression ratio.","title":"Glossary"},{"location":"MatrixOne/glossary/#glossary","text":"","title":"Glossary"},{"location":"MatrixOne/glossary/#terms","text":"It's helpful to understand a few terms before reading our architecture documentation. Term Definition A AST (Abstract syntax tree) Abstract Syntax Trees or ASTs are tree representations of code. They are a fundamental part of the way a compiler works. C Cluster A distributed MatrixOne deployment, which acts as a single logical application. D Data Storage A DataStorage is an interface for implementing distributed storage service. It must be defined in prior to using MatrixCube. DataStorage needs to be implemented based on the characteristics of storage engine. E Event Notify The machanism of synchronizing heartbeat information to all nodes is called an event notify. F Factorization The factorization method uses basic factorization formula to reduce any algebraic or quadratic equation into its simpler form. MatrixOne uses compact factorized representations at the physical layer to reduce data redundancy and boost query performance. H Heartbeat Every node in a MatrixOne cluster will periodically sends its status information, this information is called a heartbeat. M MatrixCube MatrixCube is a framework for building distributed systems, which offers guarantees about reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers only need to focus on the business logic on a single node. P Prophet Prophet is a scheduling module in MatrixCube. It takes charge of Auto-Rebalance, which keeps the system storage level and read/write throughput level balanced across Stores. The initial 3 Stores of a MatrixCube cluster are all Prophet Nodes. Pure Storage In contrast to Prophet, pure storage is another type of node, which doesn't handle any scheduling job and works as simple storage. R Replica To provide reliable service, each shard is stored not only once, it will have several copy stored in different stores. Every copy of a shard is called a Replica. S Snapshot Isolation (SI) Snapshot Isolation is a multi-version concurrency control approach that is widely used in practice. MatrixOne supports distributed transaction of snapshot isolation level. Store A MatrixCube distributed system consists of several physical servers, our data are stored across these physical server. We call each server inside this cluster a Store. Shard In MatrixOne, the data are split into different partitions to store in order to get better scalability. Each partition is called a Shard. In our design, a new created table is initially a Shard. When the size of the table exceeds the Shard size limit, the Shard will split. Shard Splitting There is a certain limit to a Shard size. Whenever a Shard exceeds its storage limit, MatrixCube splits a Shard into two Shards and keep each Shard with the same storage level. Shard Proxy The Shard Proxy is a central module to accept all user read/write requests and route requests to corresponding nodes.","title":"Terms"},{"location":"MatrixOne/glossary/#concepts","text":"MatrixOne relies heavily on the following concepts. Being familiar with them will help you understand what our architecture achieves. Term Definition A Auto-Rebalance A modern distributed database should do more than just split data amongst a number of servers. The automatic process of storage and workload distribution among servers is called an Auto-Rebalance. C Consistency MatrixOne supports a strong consistency. It is guaranted that after any successful data write, the reading afterwards will get the latest value, no matter from which store. E Execution Plan An execution plan in a database is a simple graphical representation of the operations that the query optimizer generates to calculate the most efficient way to return a set of results. F Fault-Tolerance Fault-Tolerance simply means a system's ability to continue operating uninterrupted despite the failure of one or more of its components. J JIT Compilation Turns SQL plan tree or Intermediate Representation code into a native program using LLVM at runtime. M Monolithic Engine A monolithic database engine is designed to support hybrid workloads: transactional, analytical, streaming, time-series, machine learning, etc. Materialized View A materialized view is a pre-computed data set derived from a query specification (the SELECT in the view definition) and stored for later use. Materialized view is usually used for increasing performance and efficiency. Metadata Metadata is the data that describes the structure and creation method of data in a database. P Paxos Paxos is an algorithm that is used to achieve consensus among a distributed set of computers that communicate via an asynchronous network. R Raft Raft is a consensus algorithm that is designed to be easy to understand. It's equivalent to Paxos in fault-tolerance and performance. The difference is that it's decomposed into relatively independent subproblems, and it cleanly addresses all major pieces needed for practical systems. Raft Group and Leader Raft defines a strong, single leader and number of followers in a group of peers. The group represents a replicated state machine. Only the leader may service client requests. The leader replicates actions to the followers. S SIMD instruction SIMD is short for Single Instruction/Multiple Data, while the term SIMD operations refers to a computing method that enables processing of multiple data with a single instruction. T Transaction A set of operations performed on your database that satisfy the requirements of ACID semantics. V Vectorized Execution Vectorized data processing helps with developing faster analytical query engines by making efficient utilization of CPU cache. Arrow's columnar format allows to use lightweight schemes like dictionary encoding, bit packing, and run length encoding, which favor query performance over compression ratio.","title":"Concepts"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/","text":"Make Your First Contribution Thank you for your interest in contributing to MatrixOne. Contributions are welcome from everyone. This document will help you get started on your first contribution to MatrixOne. How to Contribute? Before setting about contribution, you need figure out what area you are trying to help us in. You can see Types of contributions for more details. As your first-ever contribution, it can be selected from the following categories which require little technical background of the contributor: To report a bug in the code To improve the MatrixOne documentation File an issue to describe the problem before working on it. In addition, you will also find issues labelled with good-first-issue , which represents issues suitable for new contributors. Such Issues contain clear steps and expected output. You may start your first contribution based on these issues. Assign Your Issue It's difficult to report an issue when you are just a newcomer on account of little knowledge of MatrixOne or relative contents, so we list good-first-issues suitable for new contributors to work with and be easy to fix. After deciding a suitable issue to work on, you can comment /assign on the issue you would like to work on, you will be automatically assigned to the issue. You can then find yourself listed under Assignees section. Prerequisite Before working on the issue you are assigned, please make sure you have set up development environment and installed MatrixOne. You can see Preparation for more details. Workflow Step 1: Fork the Repository Visit our Github Repository . On the top right of the page, click the Fork button (top right) to create a cloud-based fork of the repository. Step 2: Clone fork to local storage Open the repository you forked from MatrixOne. Click on the Code button and then the Copy to Clipboard icon. Next, move to the working directory you expect in local and launch your terminal. Run the following Git command: git clone <content you just copied> For example: git clone git@github.com:<yourname>/matrixone.git <yourname> is the ID you signed in at GitHub. This Git command downloads the content of MatrixOne repository you forked on GitHub to your local device. Step 3: Add MatrixOne repo as a remote repository You can add MatrixOrigin/MatrixOne repository as a remote repository in local with: git remote add upstream https://github.com/matrixorigin/matrixone.git upstream is the designation of this remote repository. If you want to replace it with other words you want, don't forget to replace it as well in the next steps, or some errors will happen. Step 4: Develop Make some changes Now you can edit the code, modify the documents, and make whatever changes you want about your issue in the branch you just created. Run MatrixOne in a standalone mode If you want to demonstrate whether the changes you made are valid or produce an issue, you need to run MatrixOne in a standalone mode. Before running, make sure you have installed MatrixOne according to our Install tutorial . And you can connect MatrixOne Serve according to the Connect tutorial . Step 5: Commit to your local repo Having completed your modification, you can add the files you just modified using the git add command: git add <filename> <filename> is the name of the file you just modified. And you can use following command to add all the files in the current folder: git add . Next, you can commit these changes using the git commit command: git commit -m \"<commit message>\" -s Summarize and describe your modification briefly in the place of <commit message> . -s adds your sign-off message to your commit message. Step 6: Push to your remote repo After committing your modification, you should push your local branch to GitHub using the git push command, and we recommend you to push to a new branch: git push origin main:NEW_BRANCH NEW_BRANCH is the name of new branch you created and push to. Also, you can replace it with another name you want. Step 7 Create a pull request Having pushed your changes, you can visit your folk at https://github.com/$user/matrixone , and click the Compare & Pull Request button to create a pull request in NEW_BRANCH for your modification to the MatrixOne repository. Note You should fill in the required information based on the PR template. Once your PR is opened, it will be assigned to reviewers. These reviewers will check your contribution and make a detail review according to correctness, bugs, style and so on. Step 8 After merging, Keep your repo in sync Congratulations on that your contributions are accepted and merged to the project! And there are some operations left to do, which helps keep project committing history clean and keep your local and remote repo synchronized with MatrixOne repo. Overrides local commiting history with following command: git pull --force upstream main:main Lastly, upgrade the main branch of your folk in Github: git push --force origin main:main","title":"Make Your First Contribution"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#make-your-first-contribution","text":"Thank you for your interest in contributing to MatrixOne. Contributions are welcome from everyone. This document will help you get started on your first contribution to MatrixOne.","title":"Make Your First Contribution"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#how-to-contribute","text":"Before setting about contribution, you need figure out what area you are trying to help us in. You can see Types of contributions for more details. As your first-ever contribution, it can be selected from the following categories which require little technical background of the contributor: To report a bug in the code To improve the MatrixOne documentation File an issue to describe the problem before working on it. In addition, you will also find issues labelled with good-first-issue , which represents issues suitable for new contributors. Such Issues contain clear steps and expected output. You may start your first contribution based on these issues.","title":"How to Contribute?"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#assign-your-issue","text":"It's difficult to report an issue when you are just a newcomer on account of little knowledge of MatrixOne or relative contents, so we list good-first-issues suitable for new contributors to work with and be easy to fix. After deciding a suitable issue to work on, you can comment /assign on the issue you would like to work on, you will be automatically assigned to the issue. You can then find yourself listed under Assignees section.","title":"Assign Your Issue"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#prerequisite","text":"Before working on the issue you are assigned, please make sure you have set up development environment and installed MatrixOne. You can see Preparation for more details.","title":"Prerequisite"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#workflow","text":"","title":"Workflow"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#step-1-fork-the-repository","text":"Visit our Github Repository . On the top right of the page, click the Fork button (top right) to create a cloud-based fork of the repository.","title":"Step 1: Fork the Repository"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#step-2-clone-fork-to-local-storage","text":"Open the repository you forked from MatrixOne. Click on the Code button and then the Copy to Clipboard icon. Next, move to the working directory you expect in local and launch your terminal. Run the following Git command: git clone <content you just copied> For example: git clone git@github.com:<yourname>/matrixone.git <yourname> is the ID you signed in at GitHub. This Git command downloads the content of MatrixOne repository you forked on GitHub to your local device.","title":"Step 2: Clone fork to local storage"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#step-3-add-matrixone-repo-as-a-remote-repository","text":"You can add MatrixOrigin/MatrixOne repository as a remote repository in local with: git remote add upstream https://github.com/matrixorigin/matrixone.git upstream is the designation of this remote repository. If you want to replace it with other words you want, don't forget to replace it as well in the next steps, or some errors will happen.","title":"Step 3: Add MatrixOne repo as a remote repository"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#step-4-develop","text":"","title":"Step 4: Develop"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#make-some-changes","text":"Now you can edit the code, modify the documents, and make whatever changes you want about your issue in the branch you just created.","title":"Make some changes"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#run-matrixone-in-a-standalone-mode","text":"If you want to demonstrate whether the changes you made are valid or produce an issue, you need to run MatrixOne in a standalone mode. Before running, make sure you have installed MatrixOne according to our Install tutorial . And you can connect MatrixOne Serve according to the Connect tutorial .","title":"Run MatrixOne in a standalone mode"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#step-5-commit-to-your-local-repo","text":"Having completed your modification, you can add the files you just modified using the git add command: git add <filename> <filename> is the name of the file you just modified. And you can use following command to add all the files in the current folder: git add . Next, you can commit these changes using the git commit command: git commit -m \"<commit message>\" -s Summarize and describe your modification briefly in the place of <commit message> . -s adds your sign-off message to your commit message.","title":"Step 5: Commit to your local repo"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#step-6-push-to-your-remote-repo","text":"After committing your modification, you should push your local branch to GitHub using the git push command, and we recommend you to push to a new branch: git push origin main:NEW_BRANCH NEW_BRANCH is the name of new branch you created and push to. Also, you can replace it with another name you want.","title":"Step 6: Push to your remote repo"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#step-7-create-a-pull-request","text":"Having pushed your changes, you can visit your folk at https://github.com/$user/matrixone , and click the Compare & Pull Request button to create a pull request in NEW_BRANCH for your modification to the MatrixOne repository. Note You should fill in the required information based on the PR template. Once your PR is opened, it will be assigned to reviewers. These reviewers will check your contribution and make a detail review according to correctness, bugs, style and so on.","title":"Step 7 Create a pull request"},{"location":"MatrixOne/Contribution-Guide/make-your-first-contribution/#step-8-after-merging-keep-your-repo-in-sync","text":"Congratulations on that your contributions are accepted and merged to the project! And there are some operations left to do, which helps keep project committing history clean and keep your local and remote repo synchronized with MatrixOne repo. Overrides local commiting history with following command: git pull --force upstream main:main Lastly, upgrade the main branch of your folk in Github: git push --force origin main:main","title":"Step 8 After merging, Keep your repo in sync"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-comment-style/","text":"Code Comment Style This document describes the code comment style applied to MatrixOne style. When you are ready to commit, please follow the style to write good code comments. Why does a good comment matter? To speed up the reviewing process To help maintain the code To improve the API document readability To improve the development efficiency of the whole team Where/When to comment? Write a comment where/when: For important code For obscure code For tricky or interesting code For a complex code block If a bug exists in the code but you cannot fix it or you just want to ignore it for the moment If the code is not optimal but you don't have a smarter way now To remind yourself or others of missing functionality or upcoming requirements not present in the code A comment is generally required for: Package (Go) File Type Constant Function Method Variable Typical algorithm Exported name Test case TODO FIXME How to comment? Format of a good comment Go Use // for a single-line comment and trailing comment Use /* ... */ for a block comment (used only when needed) Use gofmt to format your code Place the single-line and block comment above the code it's annotating Fold long lines of comments Each line of text in your code and comment should be at most 100 characters long For a comment containing a URL Use a relative URL if the text is linked to a file within the same GitHub repository Use an absolute URL in docs and docs-cn repositories if the code with this comment is copied from another repository Language for a good comment Word Use American English rather than British English color, canceling, synchronize (Recommended) colour, cancelling, synchronise (Not recommended) Use correct spelling Use standard or official capitalization MatrixOne, MatrixCube, Raft, SQL (Right) matrixone, matrixcube, RAFT, sql (Wrong) Use words and expressions consistently \"dead link\" vs. \"broken link\" (Only one of them can appear in a single document) Do not use lengthy compound words Do not abbreviate unless it is absolutely necessary We should be used only when it means the code writer and the reader Sentence Use standard grammar and correct punctuation Use relatively short sentences Capitalize the first letter of sentences and end them with periods If a lower-case identifier comes at the beginning of a sentence, don't capitalize it // enterGame causes Players to enter the // video game, which is about a romantic // story in ancient China. func enterGame() os.Error { ... } When used for description, comments should be descriptive rather than imperative Opens the file (Right) Open the file (Wrong) Use \"this\" instead of \"the\" to refer to the current thing Gets the toolkit for this component (Recommended) Gets the toolkit for the component (Not recommended) The Markdown format is allowed Opens the log file Tips for a good comment Comment code while writing it Do not assume the code is self-evident Avoid unnecessary comments for simple code Write comments as if they were for you Make sure the comment is up-to-date Let the code speak for itself Thanks for your contribution!","title":"Code Comment Style"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-comment-style/#code-comment-style","text":"This document describes the code comment style applied to MatrixOne style. When you are ready to commit, please follow the style to write good code comments.","title":"Code Comment Style"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-comment-style/#why-does-a-good-comment-matter","text":"To speed up the reviewing process To help maintain the code To improve the API document readability To improve the development efficiency of the whole team","title":"Why does a good comment matter?"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-comment-style/#wherewhen-to-comment","text":"Write a comment where/when: For important code For obscure code For tricky or interesting code For a complex code block If a bug exists in the code but you cannot fix it or you just want to ignore it for the moment If the code is not optimal but you don't have a smarter way now To remind yourself or others of missing functionality or upcoming requirements not present in the code A comment is generally required for: Package (Go) File Type Constant Function Method Variable Typical algorithm Exported name Test case TODO FIXME","title":"Where/When to comment?"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-comment-style/#how-to-comment","text":"","title":"How to comment?"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-comment-style/#format-of-a-good-comment","text":"Go Use // for a single-line comment and trailing comment Use /* ... */ for a block comment (used only when needed) Use gofmt to format your code Place the single-line and block comment above the code it's annotating Fold long lines of comments Each line of text in your code and comment should be at most 100 characters long For a comment containing a URL Use a relative URL if the text is linked to a file within the same GitHub repository Use an absolute URL in docs and docs-cn repositories if the code with this comment is copied from another repository","title":"Format of a good comment"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-comment-style/#language-for-a-good-comment","text":"Word Use American English rather than British English color, canceling, synchronize (Recommended) colour, cancelling, synchronise (Not recommended) Use correct spelling Use standard or official capitalization MatrixOne, MatrixCube, Raft, SQL (Right) matrixone, matrixcube, RAFT, sql (Wrong) Use words and expressions consistently \"dead link\" vs. \"broken link\" (Only one of them can appear in a single document) Do not use lengthy compound words Do not abbreviate unless it is absolutely necessary We should be used only when it means the code writer and the reader Sentence Use standard grammar and correct punctuation Use relatively short sentences Capitalize the first letter of sentences and end them with periods If a lower-case identifier comes at the beginning of a sentence, don't capitalize it // enterGame causes Players to enter the // video game, which is about a romantic // story in ancient China. func enterGame() os.Error { ... } When used for description, comments should be descriptive rather than imperative Opens the file (Right) Open the file (Wrong) Use \"this\" instead of \"the\" to refer to the current thing Gets the toolkit for this component (Recommended) Gets the toolkit for the component (Not recommended) The Markdown format is allowed Opens the log file","title":"Language for a good comment"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-comment-style/#tips-for-a-good-comment","text":"Comment code while writing it Do not assume the code is self-evident Avoid unnecessary comments for simple code Write comments as if they were for you Make sure the comment is up-to-date Let the code speak for itself Thanks for your contribution!","title":"Tips for a good comment"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-of-conduct/","text":"MatrixOne Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at hai.jin@matrixorigin.io. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-of-conduct/#matrixone-code-of-conduct","text":"","title":"MatrixOne Code of Conduct"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-of-conduct/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at hai.jin@matrixorigin.io. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"MatrixOne/Contribution-Guide/Code-Style/code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/","text":"Commit Message and Pull Request Style This document describes the commit message and Pull Request style applied to all MatrixOrigin repositories. When you are ready to commit, be sure to follow the style guide to write a good commit message, a good Pull Request title, and description. Why a good commit message matters To speed up the reviewing process Help the reviewers better understand the PR Allow ignoring unimportant commits To help us write good Release Notes To help the future maintainers establish the context Provide better information when browsing the history What is a good commit message Elements of a good commit message: What is your change? (mandatory) It can be fixing a specific bug, adding a feature, improving performance, reliability and stability, or just be a change for the sake of correctness. Why was this change made? (mandatory) For short and obvious patches, this part can be omitted, but it should be a clear description of what the approach was. What effect does the commit have? (optional) In addition to the obvious effects, this may include benchmarks, side effects, etc. For short and obvious patches, this part can be omitted. How to write a good commit message To write a good commit message, we suggest following good format, cultivating good habits, and using good language. Format of a good commit message Please follow the following style for all your commits : <subsystem>: <what changed> <BLANK LINE> <why this change was made> <BLANK LINE> <footer>(optional) For the first subject line: Use no more than 70 characters. If the changes affect two subsystems, use a comma (and a whitespace) to separate them like util/codec, util/types: . If the changes affect three or more subsystems, you can use * instead, like *: . Use a lowercase letter on the text that immediately follows the colon. For example: \"media: update the DM architecture image\" Do not add a period at the end of a commit message. For the second line, always leave it blank. For the why part, if there is no specific reason for the change, you can use one of the generic reasons like \"Improve performance\", \"Improve test coverage.\" For other lines, use no more than 80 characters. Habits for a good commit message Summarize your change Describe clearly one logical change and avoid lazy messages as misc fixes Describe any limitations of the current code Do not end the subject with a period \".\" Do not assume the code is self-evident Do not assume reviewers understand the original issue Language for a good commit message Use the imperative mood for the first subject line Use simple verb tenses (eg. use \"add\" not \"added\") Use correct and standard grammar Use words and expressions consistently Use relatively short sentences Do not use lengthy compound words Do not abbreviate unless it's absolutely necessary Pull Request description style For Pull Request description in the Conversation box, please refer to the following Pull Request description template and include necessary information: **What type of PR is this?** - [ ] API-change - [ ] BUG - [ ] Improvement - [ ] Documentation - [ ] Feature - [ ] Test and CI - [ ] Code Refactoring **Which issue(s) this PR fixes:** issue # **What this PR does / why we need it:** **Special notes for your reviewer:** **Additional documentation (e.g. design docs, usage docs, etc.):** You may also use the checklist style to list contents if needed. The Markdown syntax is as follows: - [x] A checked line, something already done or fulfilled - [ ] An unchecked line, something not finished yet For short and obvious Pull Requests, you can omit some of the above information. Thanks for your contribution\uff01","title":"Commit & Pull Request Style"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/#commit-message-and-pull-request-style","text":"This document describes the commit message and Pull Request style applied to all MatrixOrigin repositories. When you are ready to commit, be sure to follow the style guide to write a good commit message, a good Pull Request title, and description.","title":"Commit Message and Pull Request Style"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/#why-a-good-commit-message-matters","text":"To speed up the reviewing process Help the reviewers better understand the PR Allow ignoring unimportant commits To help us write good Release Notes To help the future maintainers establish the context Provide better information when browsing the history","title":"Why a good commit message matters"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/#what-is-a-good-commit-message","text":"Elements of a good commit message: What is your change? (mandatory) It can be fixing a specific bug, adding a feature, improving performance, reliability and stability, or just be a change for the sake of correctness. Why was this change made? (mandatory) For short and obvious patches, this part can be omitted, but it should be a clear description of what the approach was. What effect does the commit have? (optional) In addition to the obvious effects, this may include benchmarks, side effects, etc. For short and obvious patches, this part can be omitted.","title":"What is a good commit message"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/#how-to-write-a-good-commit-message","text":"To write a good commit message, we suggest following good format, cultivating good habits, and using good language.","title":"How to write a good commit message"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/#format-of-a-good-commit-message","text":"Please follow the following style for all your commits : <subsystem>: <what changed> <BLANK LINE> <why this change was made> <BLANK LINE> <footer>(optional) For the first subject line: Use no more than 70 characters. If the changes affect two subsystems, use a comma (and a whitespace) to separate them like util/codec, util/types: . If the changes affect three or more subsystems, you can use * instead, like *: . Use a lowercase letter on the text that immediately follows the colon. For example: \"media: update the DM architecture image\" Do not add a period at the end of a commit message. For the second line, always leave it blank. For the why part, if there is no specific reason for the change, you can use one of the generic reasons like \"Improve performance\", \"Improve test coverage.\" For other lines, use no more than 80 characters.","title":"Format of a good commit message"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/#habits-for-a-good-commit-message","text":"Summarize your change Describe clearly one logical change and avoid lazy messages as misc fixes Describe any limitations of the current code Do not end the subject with a period \".\" Do not assume the code is self-evident Do not assume reviewers understand the original issue","title":"Habits for a good commit message"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/#language-for-a-good-commit-message","text":"Use the imperative mood for the first subject line Use simple verb tenses (eg. use \"add\" not \"added\") Use correct and standard grammar Use words and expressions consistently Use relatively short sentences Do not use lengthy compound words Do not abbreviate unless it's absolutely necessary","title":"Language for a good commit message"},{"location":"MatrixOne/Contribution-Guide/Code-Style/commit-pr-style/#pull-request-description-style","text":"For Pull Request description in the Conversation box, please refer to the following Pull Request description template and include necessary information: **What type of PR is this?** - [ ] API-change - [ ] BUG - [ ] Improvement - [ ] Documentation - [ ] Feature - [ ] Test and CI - [ ] Code Refactoring **Which issue(s) this PR fixes:** issue # **What this PR does / why we need it:** **Special notes for your reviewer:** **Additional documentation (e.g. design docs, usage docs, etc.):** You may also use the checklist style to list contents if needed. The Markdown syntax is as follows: - [x] A checked line, something already done or fulfilled - [ ] An unchecked line, something not finished yet For short and obvious Pull Requests, you can omit some of the above information. Thanks for your contribution\uff01","title":"Pull Request description style"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-code/","text":"Contribute Code MatrixOne is an open-source project maintained, improved, and extended by code contributors. This document describes the conventions about development workflow, and some styles and templates you need while contributing code to MatrixOne. If you encounter any problem or find some mistakes in participating in contribution to MatrixOne, please file an issue in GitHub or contact us on other platforms we support. Before Contributions Before you start developing, make sure you have read Preparation where you can follow the instructions to learn more about MatrixOne, development knowledge and how to set up the development environment. Get familiar with style It's necessary to keep a consistent style for code, code comments, commit messages, and pull requests when contributing to MatrixOne. When you put together your pull request, we highly recommend you comply with the following style guides which make MatrixOne easy to review, maintain, and develop. Code Style The coding style suggested by the Golang community is used in MatrixOne. See the style doc for details. Code Comment Style See the code comment style for details. Commit Message & Pull Request Style See the Commit Message & Pull Request Style for details. Workflow You can follow the workflow to operate development, and you can see Make Your First Contribution if you are a newcomer and need more detailed instructions about workflow. 1. Fork the MatrixOne repository on GitHub. 2. Clone your fork to your local machine with: git clone git@github.com:<yourname>/matrixone.git And add MatrixOne repo as a remote repository with: git remote add upstream https://github.com/matrixorigin/matrixone.git 3. Create a new branch, the branch name is up to you. git checkout -b topic-branch 4. Commit changes to your own branch locally, add necessary unit tests. 5. Push to a new branch in your own fork. git push origin main:NEW_BRANCH 6. Go back to GitHub, and submit a pull request in NEW_BRANCH so that we can review your changes. Add some labels if needed, and don't forget to refer to the related issue . 7. Once your PR get approved, it would be merged sooner. After merging, synchronize your local repository. git pull --force upstream main:main 8. Synchronized the main branch of your remote repository in Github. git push --force origin main:main If you still have some trouble, please refer to GitHub Docs for help. Code review When you open a pull request, you can assign some reviewers, or just leave it blank. And you can add some related labels so that it would be easier to recognize the PR's type/priority/etc. During review, reviewers would comment on your code snippet, and you can modify the code on your topic branch locally, commit the changes, and push to GitHub where the new commits would be attached to the PR automatically. For detailed code review tips, See Review a pull request for details.","title":"Contribute Code"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-code/#contribute-code","text":"MatrixOne is an open-source project maintained, improved, and extended by code contributors. This document describes the conventions about development workflow, and some styles and templates you need while contributing code to MatrixOne. If you encounter any problem or find some mistakes in participating in contribution to MatrixOne, please file an issue in GitHub or contact us on other platforms we support.","title":"Contribute Code"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-code/#before-contributions","text":"Before you start developing, make sure you have read Preparation where you can follow the instructions to learn more about MatrixOne, development knowledge and how to set up the development environment.","title":"Before Contributions"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-code/#get-familiar-with-style","text":"It's necessary to keep a consistent style for code, code comments, commit messages, and pull requests when contributing to MatrixOne. When you put together your pull request, we highly recommend you comply with the following style guides which make MatrixOne easy to review, maintain, and develop. Code Style The coding style suggested by the Golang community is used in MatrixOne. See the style doc for details. Code Comment Style See the code comment style for details. Commit Message & Pull Request Style See the Commit Message & Pull Request Style for details.","title":"Get familiar with style "},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-code/#workflow","text":"You can follow the workflow to operate development, and you can see Make Your First Contribution if you are a newcomer and need more detailed instructions about workflow. 1. Fork the MatrixOne repository on GitHub. 2. Clone your fork to your local machine with: git clone git@github.com:<yourname>/matrixone.git And add MatrixOne repo as a remote repository with: git remote add upstream https://github.com/matrixorigin/matrixone.git 3. Create a new branch, the branch name is up to you. git checkout -b topic-branch 4. Commit changes to your own branch locally, add necessary unit tests. 5. Push to a new branch in your own fork. git push origin main:NEW_BRANCH 6. Go back to GitHub, and submit a pull request in NEW_BRANCH so that we can review your changes. Add some labels if needed, and don't forget to refer to the related issue . 7. Once your PR get approved, it would be merged sooner. After merging, synchronize your local repository. git pull --force upstream main:main 8. Synchronized the main branch of your remote repository in Github. git push --force origin main:main If you still have some trouble, please refer to GitHub Docs for help.","title":"Workflow"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-code/#code-review","text":"When you open a pull request, you can assign some reviewers, or just leave it blank. And you can add some related labels so that it would be easier to recognize the PR's type/priority/etc. During review, reviewers would comment on your code snippet, and you can modify the code on your topic branch locally, commit the changes, and push to GitHub where the new commits would be attached to the PR automatically. For detailed code review tips, See Review a pull request for details.","title":"Code review"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-documentation/","text":"Contributing to MatrixOne Documentation Contributions to the MatrixOne documentation are welcome from everyone. The MatrixOne community strives to make the contribution process simple and straightforward. To do that, we create this page to walk you through the whole process step by step. Before you start Before you contribute please take a minute to familiarize yourself with basic Markdown syntax and have a look at our Code of Conduct and the Google Developer Documentation Style Guide for some guidance on how to write accessible, consistent, and inclusive documentation. How is MatrixOne documentation project organized? The MatrixOne documentation is managed in 3 repositories: The main project framework and CI&CD settings are in the matrixorigin.io repo. The markdown contents are in the docs/en/MatrixOne folder of matrixone repo. The images and unstructured data are located in the artwork repo. The matrixorigin.io repo contains a submodule that links to matrixone repo contents. The images are referred to as web image links from artwork repo. The matrixorigin.io has implemented a CI&CD project, which will be triggered by a new code merge and manual launch. This CI&CD workflow publishes the documentation to https://docs.matrixorigin.io/ . The documentation project is based on the mkdocs-material . You can find the corresponding syntax and commands with this project. MatrixOne Documentation Structure The MatrixOne documentation content is planned with 6 main modules. Overview : MatrixOne's introduction, features, architecture, tech design. Get Started : How to quickly deploy and run a MatrixOne in a standalone or a distributed environment. Reference : SQL reference, Configuration parameters, Error Codes. FAQs : Product, Technical Design, SQL, Deployment FAQs. Develop : How to develop some applications based on MatrixOne using different programming languages. Troubleshoot : Introduce common errors and debugging tools. Release Notes : Release notes of all versions. Contribution Guide : How to contribute to MatrixOne project. Lift a finger If you are just correcting a typo or grammatical error, feel free to go ahead and create a pull request . Contribute Workflow 1 . File an issue and assign it to yourself by commenting /assign . 2 . Fork matrixorigin.io and matrixone repos. 3 . Clone the matrixorigin.io repo, using --recursive to retrieve the submodule of matrixone repo. $ git clone --recursive git@github.com:yourusername/matrixorigin.io.git Clone the matrixone repo to the other folder in local: $ git clone git@github.com:yourusername/matrixone.git 4 . Add matrixone repo as a remote repository in your local matrixone folder with: git remote add upstream https://github.com/matrixorigin/matrixone.git Add matrixorigin.io repo as a remote repository in your local matrixorigin.io folder with: git remote add upstream https://github.com/matrixorigin/matrixorigin.io.git 5 . As the local repo has the full documentation project code, you can run mkdocs serve under matrixorigin.io folder, and check http://localhost:8000 to check if this project runs well. $ mkdocs serve 6 . Make your modification. If the modification is about the project settings, updating the sitemap with new pages, or updating the CI&CD workflow code. You can always check http://localhost:8000 to see if your modification is effective. If your modification is about the markdown contents, after you update the docs submodule of matrixorigin.io , the same modifcation should be applied to the matrixone repo. 7 . Push your git commits to your remote Github matrixorigin.io and matrixone repos. We recommend you to push to a new branch using the following commands: git push origin main:NEW_BRANCH 8 . Go back to GitHub, and submit a pull request in NEW_BRANCH so that we can review your changes. 9 . Once your code for both repos is merged, you'll wait for a CI&CD workflow to restart running until the documentation website being updated. Note So once your pull requests are merged, the update to the website is not immediate. We'll need to run a manual launch to update it. 10 . At last, you should update your local and remote repo to help keep committing history clean. Override your local committing repo with: git pull --force upstream main:main Update the main branch of your remote repo in Github: git push --force origin main:main Note Most processes should be implemented in both matrixorigin.io and matrixone . Contribute a blog article If you would like to write an article for our blog, please file an issue or send it to dengnan@matrixorigin.io . Feel free to submit either a completed draft or any article ideas. All submissions will be reviewed as quickly as possible. If your article or idea seems like a good fit for the blog, we will reach out to you directly.","title":"Contribute Documentation"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-documentation/#contributing-to-matrixone-documentation","text":"Contributions to the MatrixOne documentation are welcome from everyone. The MatrixOne community strives to make the contribution process simple and straightforward. To do that, we create this page to walk you through the whole process step by step.","title":"Contributing to MatrixOne Documentation"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-documentation/#before-you-start","text":"Before you contribute please take a minute to familiarize yourself with basic Markdown syntax and have a look at our Code of Conduct and the Google Developer Documentation Style Guide for some guidance on how to write accessible, consistent, and inclusive documentation.","title":"Before you start"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-documentation/#how-is-matrixone-documentation-project-organized","text":"The MatrixOne documentation is managed in 3 repositories: The main project framework and CI&CD settings are in the matrixorigin.io repo. The markdown contents are in the docs/en/MatrixOne folder of matrixone repo. The images and unstructured data are located in the artwork repo. The matrixorigin.io repo contains a submodule that links to matrixone repo contents. The images are referred to as web image links from artwork repo. The matrixorigin.io has implemented a CI&CD project, which will be triggered by a new code merge and manual launch. This CI&CD workflow publishes the documentation to https://docs.matrixorigin.io/ . The documentation project is based on the mkdocs-material . You can find the corresponding syntax and commands with this project.","title":"How is MatrixOne documentation project organized?"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-documentation/#matrixone-documentation-structure","text":"The MatrixOne documentation content is planned with 6 main modules. Overview : MatrixOne's introduction, features, architecture, tech design. Get Started : How to quickly deploy and run a MatrixOne in a standalone or a distributed environment. Reference : SQL reference, Configuration parameters, Error Codes. FAQs : Product, Technical Design, SQL, Deployment FAQs. Develop : How to develop some applications based on MatrixOne using different programming languages. Troubleshoot : Introduce common errors and debugging tools. Release Notes : Release notes of all versions. Contribution Guide : How to contribute to MatrixOne project.","title":"MatrixOne Documentation Structure"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-documentation/#lift-a-finger","text":"If you are just correcting a typo or grammatical error, feel free to go ahead and create a pull request .","title":"Lift a finger"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-documentation/#contribute-workflow","text":"1 . File an issue and assign it to yourself by commenting /assign . 2 . Fork matrixorigin.io and matrixone repos. 3 . Clone the matrixorigin.io repo, using --recursive to retrieve the submodule of matrixone repo. $ git clone --recursive git@github.com:yourusername/matrixorigin.io.git Clone the matrixone repo to the other folder in local: $ git clone git@github.com:yourusername/matrixone.git 4 . Add matrixone repo as a remote repository in your local matrixone folder with: git remote add upstream https://github.com/matrixorigin/matrixone.git Add matrixorigin.io repo as a remote repository in your local matrixorigin.io folder with: git remote add upstream https://github.com/matrixorigin/matrixorigin.io.git 5 . As the local repo has the full documentation project code, you can run mkdocs serve under matrixorigin.io folder, and check http://localhost:8000 to check if this project runs well. $ mkdocs serve 6 . Make your modification. If the modification is about the project settings, updating the sitemap with new pages, or updating the CI&CD workflow code. You can always check http://localhost:8000 to see if your modification is effective. If your modification is about the markdown contents, after you update the docs submodule of matrixorigin.io , the same modifcation should be applied to the matrixone repo. 7 . Push your git commits to your remote Github matrixorigin.io and matrixone repos. We recommend you to push to a new branch using the following commands: git push origin main:NEW_BRANCH 8 . Go back to GitHub, and submit a pull request in NEW_BRANCH so that we can review your changes. 9 . Once your code for both repos is merged, you'll wait for a CI&CD workflow to restart running until the documentation website being updated. Note So once your pull requests are merged, the update to the website is not immediate. We'll need to run a manual launch to update it. 10 . At last, you should update your local and remote repo to help keep committing history clean. Override your local committing repo with: git pull --force upstream main:main Update the main branch of your remote repo in Github: git push --force origin main:main Note Most processes should be implemented in both matrixorigin.io and matrixone .","title":"Contribute Workflow"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/contribute-documentation/#contribute-a-blog-article","text":"If you would like to write an article for our blog, please file an issue or send it to dengnan@matrixorigin.io . Feel free to submit either a completed draft or any article ideas. All submissions will be reviewed as quickly as possible. If your article or idea seems like a good fit for the blog, we will reach out to you directly.","title":"Contribute a blog article"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/make-a-design/","text":"Make a Design Proposal Many changes including bug fixes and documentation improvements, can be implemented and reviewed via the normal GitHub pull request workflow, which we have already introduced in the previous chapter. However, when you come up with a new feature you need or expect MatrixOne to achieve, we encourage you to propose your idea and express it as a technique design document. Therefore, this page is intended to guide you to provide a consistent and controlled path for new features to enter the MatrixOne projects, so that all stakeholders can fully understand the direction the project is evolving towards. This page defines the best practices procedure for making a proposal in MatrixOne projects. Before writing a design document Making enough preparations ahead of the design document can not only promote your working efficiency but increase the likelihood of it being accepted. Oppositely, a rough and casual design document may be rejected quickly. We motivate you to ask for help from experienced developers in order to obtain valuable suggestions to frame your design architecture or fill in details, which undoubtedly will upgrade the document to be desirable. The most common channel for preparing for writing a design document is on the Github issue. You can file a Feature Request or Refactoring Request to discuss about your ideas. Process Generally, you can follow these steps to finish the whole process: Create an issue describing the problem, goal, and solution. Get responses from other contributors to see if your proposal is generally acceptable and whether or not you should make some modifications. Create a pull request with a design document based on the design template . Make conversation with reviewers, revise the text in response. The design document is accepted or rejected when at least two committers reach consensus and no objection from the committer. If accepted, create a tracking issue for the design document or convert one from a previous discussion issue. The tracking issue basically tracks subtasks and progress. And refer the tracking issue in the design document replacing placeholder in the template. Merge the pull request of design. Start the implementation. Please refer to the tracking issue from subtasks to track the progress.","title":"Make a Design"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/make-a-design/#make-a-design-proposal","text":"Many changes including bug fixes and documentation improvements, can be implemented and reviewed via the normal GitHub pull request workflow, which we have already introduced in the previous chapter. However, when you come up with a new feature you need or expect MatrixOne to achieve, we encourage you to propose your idea and express it as a technique design document. Therefore, this page is intended to guide you to provide a consistent and controlled path for new features to enter the MatrixOne projects, so that all stakeholders can fully understand the direction the project is evolving towards. This page defines the best practices procedure for making a proposal in MatrixOne projects.","title":"Make a Design Proposal"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/make-a-design/#before-writing-a-design-document","text":"Making enough preparations ahead of the design document can not only promote your working efficiency but increase the likelihood of it being accepted. Oppositely, a rough and casual design document may be rejected quickly. We motivate you to ask for help from experienced developers in order to obtain valuable suggestions to frame your design architecture or fill in details, which undoubtedly will upgrade the document to be desirable. The most common channel for preparing for writing a design document is on the Github issue. You can file a Feature Request or Refactoring Request to discuss about your ideas.","title":"Before writing a design document"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/make-a-design/#process","text":"Generally, you can follow these steps to finish the whole process: Create an issue describing the problem, goal, and solution. Get responses from other contributors to see if your proposal is generally acceptable and whether or not you should make some modifications. Create a pull request with a design document based on the design template . Make conversation with reviewers, revise the text in response. The design document is accepted or rejected when at least two committers reach consensus and no objection from the committer. If accepted, create a tracking issue for the design document or convert one from a previous discussion issue. The tracking issue basically tracks subtasks and progress. And refer the tracking issue in the design document replacing placeholder in the template. Merge the pull request of design. Start the implementation. Please refer to the tracking issue from subtasks to track the progress.","title":"Process"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/","text":"Preparation Before contributing, it's necessary to make some preparations to learn more about MatrixOne and other revalant information which can improve developing and reviewing efficiency. Thanks for understanding that English is used as a shared language in this repository. Maintainers do not use machine translation to avoid miscommunication due to errors in translation. If the description of an issue / PR are written in non-English languages, those may be closed. If English is not your native language and you aren't sure about any of these, don't hesitate to ask for help in your pull request! What is MatrixOne Basic Information You can see MatrixOne Introduction for key features of MatrixOne, MatrixOne Architecture for MatrixOne architecture and operational logic. For our distributed framework, see MatrixCube Tech Design . Besides, you can browse SQL Reference and Custom Functions to know more about our interactive details. These introductions will help you go through you the key concepts and user details to understand the project. Roadmap MatrixOne v0.3.0 has been released, you can see Release Notes to know more information. Currently, we are working at v0.4.0 and v0.5.0 releases, the job tasks of these releases are listed in the Github milestones 0.4.0 . For the long-term project roadmap, please refer to MatrixOne roadmap for a more general overview. What Contributions Can I Make Contributions to MatrixOne are not limited to writing code. What follows are different ways to participate in the MatrixOne project and engage with our vibrant open-source community. See Types of Contributions for more details. To report a bug or a problem with documentation, please file an issue providing the details of the problem. Don't forget to add a proper label for your issue, and follow the issue templates . To propose a new feature, please file a new feature request . Describe the intended feature and discuss the design and implementation with the team and community. Once the team agrees on the plan, you can follow the Contribution Workflow to implement it. To implement a feature or bug-fix for an existing outstanding issue, follow the Contribution workflow . If you need more context on a particular issue, comment on the issue to let people know. Working Directories and Files For contributing code, matrixone is the main repository you'll be working on. The main working directories are listed below: Directory Working Files /LICENSES The license of dependant libraries /cmd The binary entry of Go executables optools The test and deployment utilities pkg The main codebase of MatrixOne project For different technical modules, a code structure under /pkg is as following table. Please refer to MatrixOne tech design for a better overview. Directory Modules frontend/ SQL Frontend sql/parser SQL Parser sql/ MPP SQL Execution sql/vectorize Vectorization of SQL Execution catalog/ Catalog for storing metadata github.com/matrixorigin/matrixcube MatrixCube vm/engine Storage engine vm/engine/aoe Analytics Optimized Engine vm/engine/tpe Transaction Processing Engine buildin/ System builtin functions For contributing documentation, matrixone , matrixorigin.io and artwork are all the main repositories you'll be working on. For more details, please refer to Contribute Documentation . Directory Working Files matrixone/docs/en/MatrixOne The content files of MatrixOne documentation website matrixone/docs/rfcs The design docs of MatrixOne project matrixorigin.io/mkdocs.yml The configuration file of documentation website artwork/docs The images, screenshots and diagrams of documentation webstie Set up your Development Environment Go Environment MatrixOne is written in Go. Before you start contributing code to MatrixOne, you need to set up your GO development environment. Install Go version 1.18 . You can see How to Write Go Code for more information. Define GOPATH environment variable and modify PATH to access your Go binaries. A common setup is as follows. You could always specify it based on your own flavor. export GOPATH = $HOME /go export PATH = $PATH : $GOPATH /bin Note MatrixOne uses Go Modules to manage dependencies. Github & Git MatrixOne is an open-source project built on Github, providing project maintainers and contributors with a platform to work together. Thus, in order to start working with MatrixOne repository, you will need a GitHub account and learn basic git commands. If you don't have a Github account, please register at https://github.com . In case you do not have SSH keys, you should generate them and then upload them on GitHub. It is required for sending over your patches. It is also possible to use the same SSH keys that you use with any other SSH servers - probably you already have those. For detailed information about Github, you can see Github Docs . To work with git repositories, please install git . And you can learn how to use it throuth following introduction: A brief manual can be found here . A detailed manual can be found here . Install and Run MatrixOne See Install Standalone MatrixOne for more details.","title":"Preparation"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#preparation","text":"Before contributing, it's necessary to make some preparations to learn more about MatrixOne and other revalant information which can improve developing and reviewing efficiency. Thanks for understanding that English is used as a shared language in this repository. Maintainers do not use machine translation to avoid miscommunication due to errors in translation. If the description of an issue / PR are written in non-English languages, those may be closed. If English is not your native language and you aren't sure about any of these, don't hesitate to ask for help in your pull request!","title":"Preparation"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#what-is-matrixone","text":"","title":"What is MatrixOne"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#basic-information","text":"You can see MatrixOne Introduction for key features of MatrixOne, MatrixOne Architecture for MatrixOne architecture and operational logic. For our distributed framework, see MatrixCube Tech Design . Besides, you can browse SQL Reference and Custom Functions to know more about our interactive details. These introductions will help you go through you the key concepts and user details to understand the project.","title":"Basic Information"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#roadmap","text":"MatrixOne v0.3.0 has been released, you can see Release Notes to know more information. Currently, we are working at v0.4.0 and v0.5.0 releases, the job tasks of these releases are listed in the Github milestones 0.4.0 . For the long-term project roadmap, please refer to MatrixOne roadmap for a more general overview.","title":"Roadmap"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#what-contributions-can-i-make","text":"Contributions to MatrixOne are not limited to writing code. What follows are different ways to participate in the MatrixOne project and engage with our vibrant open-source community. See Types of Contributions for more details. To report a bug or a problem with documentation, please file an issue providing the details of the problem. Don't forget to add a proper label for your issue, and follow the issue templates . To propose a new feature, please file a new feature request . Describe the intended feature and discuss the design and implementation with the team and community. Once the team agrees on the plan, you can follow the Contribution Workflow to implement it. To implement a feature or bug-fix for an existing outstanding issue, follow the Contribution workflow . If you need more context on a particular issue, comment on the issue to let people know.","title":"What Contributions Can I Make"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#working-directories-and-files","text":"For contributing code, matrixone is the main repository you'll be working on. The main working directories are listed below: Directory Working Files /LICENSES The license of dependant libraries /cmd The binary entry of Go executables optools The test and deployment utilities pkg The main codebase of MatrixOne project For different technical modules, a code structure under /pkg is as following table. Please refer to MatrixOne tech design for a better overview. Directory Modules frontend/ SQL Frontend sql/parser SQL Parser sql/ MPP SQL Execution sql/vectorize Vectorization of SQL Execution catalog/ Catalog for storing metadata github.com/matrixorigin/matrixcube MatrixCube vm/engine Storage engine vm/engine/aoe Analytics Optimized Engine vm/engine/tpe Transaction Processing Engine buildin/ System builtin functions For contributing documentation, matrixone , matrixorigin.io and artwork are all the main repositories you'll be working on. For more details, please refer to Contribute Documentation . Directory Working Files matrixone/docs/en/MatrixOne The content files of MatrixOne documentation website matrixone/docs/rfcs The design docs of MatrixOne project matrixorigin.io/mkdocs.yml The configuration file of documentation website artwork/docs The images, screenshots and diagrams of documentation webstie","title":"Working Directories and Files"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#set-up-your-development-environment","text":"","title":"Set up your Development Environment"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#go-environment","text":"MatrixOne is written in Go. Before you start contributing code to MatrixOne, you need to set up your GO development environment. Install Go version 1.18 . You can see How to Write Go Code for more information. Define GOPATH environment variable and modify PATH to access your Go binaries. A common setup is as follows. You could always specify it based on your own flavor. export GOPATH = $HOME /go export PATH = $PATH : $GOPATH /bin Note MatrixOne uses Go Modules to manage dependencies.","title":"Go Environment"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#github-git","text":"MatrixOne is an open-source project built on Github, providing project maintainers and contributors with a platform to work together. Thus, in order to start working with MatrixOne repository, you will need a GitHub account and learn basic git commands. If you don't have a Github account, please register at https://github.com . In case you do not have SSH keys, you should generate them and then upload them on GitHub. It is required for sending over your patches. It is also possible to use the same SSH keys that you use with any other SSH servers - probably you already have those. For detailed information about Github, you can see Github Docs . To work with git repositories, please install git . And you can learn how to use it throuth following introduction: A brief manual can be found here . A detailed manual can be found here .","title":"Github &amp; Git"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/preparation/#install-and-run-matrixone","text":"See Install Standalone MatrixOne for more details.","title":"Install and Run MatrixOne"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/report-an-issue/","text":"Report Issues Any problem is encouraged to be published when you participate in MatrixOne, and you can report issues about this problem in GitHub with templates and labels we suggest. This page is intended to introduce templates, labels, and precautions you will follow when you report issues. Avoid Duplicated Issues Before reporting an issue, you should see whether the problem has already been reported. You can use the search bar to search existing issues. Issue Templates If the problem you're reporting is not already in the issue tracker, you can file an issue with your GitHub account. MatrixOne uses issue templates for different kinds of issues. Issue templates are a bundle of questions to collect necessary information about the problem to make it easy for other contributors to participate. MatrixOne suggests 6 types of issue templates: A Bug report issue template consists of information below: Detail Environment Describe the details about the operating environment including version, hardware parameters, OS type and so on. Steps to Reproduce List steps to reproduce what you encountered. Actual & Expected Behavior Describe what's the observed and your expected behavior respectively. A Feature Request consists of information below: Is your feature request related to a problem? A clear and concise description of what the problem is and state your reasons why you need this feature. Describe the feature you'd like: A clear and concise description of what you want to happen. Describe alternatives you've considered: A clear and concise description of any alternative solutions or features you've considered. Teachability, Documentation, Adoption, Migration Strategy: If you can, explain some scenarios how users might use this, situations it would be helpful in. Any API designs, mockups, or diagrams are also helpful. A Documentation Issue consists of information below: Describe the issue A clear and concise description of what's wrong in documentation. Additional context Add any other context about the problem here. A Performance Question consists of information below: Detail Environment Describe the details about the operation environment including version, hardware parameters, OS type and so on. Steps to Reproduce List steps detailedly to reproduce the operations to test performance. Expected & Actual Performance Describe what's the observed and your expected performance respectively. Additional context Add any other context about the problem here. For example: Have you compared MatrixOne with other databases? If yes, what's their difference? An Enhancement consists of information below: What would you like to be added A concise description of what you're expecting/suggesting. Why is this needed A concise description of the reason/motivation. Anything else Anything that will give us more dectail about your issue! A Refactoring Request consists of information below: Is your refactoring request related to a problem? A clear and concise description of what the problem is. Describe the solution you'd like A clear and concise description of the refactoring you want to. Describe alternatives you've considered A clear and concise description of any alternative solutions or refactoring method you've considered. Additional context Add any other context or screenshots about the refactoring request here. A General Question : If the previous templates don't fit with what you'd like to report or ask, please use this general question template to file issue. Before asking a question, make sure you have: Searched open and closed GitHub issues Read the documentation: MatrixOne Readme MatrixOne Doc Issue Labels Once your issue is submitted, it will automatically be labeled with needs-triage , a MatrixOne maintainer will look at the issue, tag it with more suitable labels, and assign it to a suitable developer. If you'd like to work on the issue by yourself, you can comment /assign on the issue you would like to work on, and you will be automatically assigned to the issue. You can then find yourself listed under Assignees section. Good First Issues When you make the first contribution to MatrixOne, you can select one of the issues labeled good-first-issues each of which is relatively approachable for first-time contributors. For detailed suggestions you need when you make the first contribution, you can see Make Your First Contribution .","title":"Report an Issue"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/report-an-issue/#report-issues","text":"Any problem is encouraged to be published when you participate in MatrixOne, and you can report issues about this problem in GitHub with templates and labels we suggest. This page is intended to introduce templates, labels, and precautions you will follow when you report issues.","title":"Report Issues"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/report-an-issue/#avoid-duplicated-issues","text":"Before reporting an issue, you should see whether the problem has already been reported. You can use the search bar to search existing issues.","title":"Avoid Duplicated Issues"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/report-an-issue/#issue-templates","text":"If the problem you're reporting is not already in the issue tracker, you can file an issue with your GitHub account. MatrixOne uses issue templates for different kinds of issues. Issue templates are a bundle of questions to collect necessary information about the problem to make it easy for other contributors to participate. MatrixOne suggests 6 types of issue templates: A Bug report issue template consists of information below: Detail Environment Describe the details about the operating environment including version, hardware parameters, OS type and so on. Steps to Reproduce List steps to reproduce what you encountered. Actual & Expected Behavior Describe what's the observed and your expected behavior respectively. A Feature Request consists of information below: Is your feature request related to a problem? A clear and concise description of what the problem is and state your reasons why you need this feature. Describe the feature you'd like: A clear and concise description of what you want to happen. Describe alternatives you've considered: A clear and concise description of any alternative solutions or features you've considered. Teachability, Documentation, Adoption, Migration Strategy: If you can, explain some scenarios how users might use this, situations it would be helpful in. Any API designs, mockups, or diagrams are also helpful. A Documentation Issue consists of information below: Describe the issue A clear and concise description of what's wrong in documentation. Additional context Add any other context about the problem here. A Performance Question consists of information below: Detail Environment Describe the details about the operation environment including version, hardware parameters, OS type and so on. Steps to Reproduce List steps detailedly to reproduce the operations to test performance. Expected & Actual Performance Describe what's the observed and your expected performance respectively. Additional context Add any other context about the problem here. For example: Have you compared MatrixOne with other databases? If yes, what's their difference? An Enhancement consists of information below: What would you like to be added A concise description of what you're expecting/suggesting. Why is this needed A concise description of the reason/motivation. Anything else Anything that will give us more dectail about your issue! A Refactoring Request consists of information below: Is your refactoring request related to a problem? A clear and concise description of what the problem is. Describe the solution you'd like A clear and concise description of the refactoring you want to. Describe alternatives you've considered A clear and concise description of any alternative solutions or refactoring method you've considered. Additional context Add any other context or screenshots about the refactoring request here. A General Question : If the previous templates don't fit with what you'd like to report or ask, please use this general question template to file issue. Before asking a question, make sure you have: Searched open and closed GitHub issues Read the documentation: MatrixOne Readme MatrixOne Doc","title":"Issue Templates"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/report-an-issue/#issue-labels","text":"Once your issue is submitted, it will automatically be labeled with needs-triage , a MatrixOne maintainer will look at the issue, tag it with more suitable labels, and assign it to a suitable developer. If you'd like to work on the issue by yourself, you can comment /assign on the issue you would like to work on, and you will be automatically assigned to the issue. You can then find yourself listed under Assignees section.","title":"Issue Labels"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/report-an-issue/#good-first-issues","text":"When you make the first contribution to MatrixOne, you can select one of the issues labeled good-first-issues each of which is relatively approachable for first-time contributors. For detailed suggestions you need when you make the first contribution, you can see Make Your First Contribution .","title":"Good First Issues"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/review-a-pull-request/","text":"Reviews For MatrixOne, any type of review for a pull request is crucial, where you can classify the pull request to help look for more suitable experts to solve related problems or propose your suggestions to code for not only contents but style. It's not necessary to doubt whether your review is constructive and useful enough because no matter how tiny, a suggestion may make a profound influence on MatrixOne. Certainly, before reviewing we ask that you browse this page to learn basic requirements and relative methods. Principles of the code review When you review a pull request, there are several rules and suggestions you should take to propose better comments. Regardless of the specifics, we suggest you stay friendly first: Be respectful Be respectful to every pull request author and other reviewers. Code review is a part of community activities so you should follow the community requirements. Be careful with tone Try to frame your comments as suggestions or questions instead of commands. If the tone is softer, your reviews will be easier to accept. Be generous with your compliments We recommended you offer encouragement and appreciation to the authors for their good practices in the code segments. In many cases, telling the authors what they did is right is even more valuable than telling them what they did is wrong. Additionally, here are some suggestions in terms of content: Provide more We encourage you to provide additional details and context of your review process as much as you can. Undoubtedly, the more detailed your review, the more useful it will be to others. If you test the pull request, please report the result and your test environment details. If you request some changes, try to suggest how. Keep objective Avoid individual biased opinions and subjective emotions. Of course, everyone will comment with more or less subjective opinions, however, as a good reviewer you should consider the technique and data facts rather than your own personal preferences. Case by case It's difficult to decide whether it's more reasonable to accept or reject when you are faced with a complex problem. Regrettably, we can't provide a certain answer because it always depends on the specific situation, which asks you to balance the pros and cons. Classifying pull requests Some pull request authors may not be familiar with MatrixOne, the MatriOne development workflow, or the MatrixOne community. They don't know what labels should be added to the pull requests or which expert could be asked for a review. If you are able to, it would be great for you to triage the pull requests, add suitable labels to the pull requests, and request corresponding experts to review the pull requests. These actions could help more contributors notice the pull requests and make quick responses. Checking pull requests There are some basic aspects to check when you review a pull request: Concentration One pull request should only do one thing. No matter how small it is, the change does exactly one thing and gets it right. Don't mix other changes into it. Tests A pull request should be test covered, whether the tests are unit tests, integration tests, or end-to-end tests. Tests should be sufficient, correct and don't slow down the CI pipeline largely. Functionality The pull request should implement what the author intends to do, fit well in the existing code base, and resolve a real problem for users. Thus you should check whether or not the pull request achieve the intention and you could follow the discussions in the corresponding GitHub issue . Style Code in the pull request should follow common programming style . However, sometimes the existing code is inconsistent with the style guide, you should maintain consistency with the existing code or file a new issue to fix the existing code style first. Documentation If a pull request changes how users build, test, interact with, or release code, you must check whether it also updates the related documentation such as README.md and any generated reference docs. Similarly, if a pull request deletes or deprecates code, you must check whether or not the corresponding documentation should also be deleted. Performance If you find the pull request may affect performance, you could ask the author to provide a benchmark result.","title":"Review a Pull Request"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/review-a-pull-request/#reviews","text":"For MatrixOne, any type of review for a pull request is crucial, where you can classify the pull request to help look for more suitable experts to solve related problems or propose your suggestions to code for not only contents but style. It's not necessary to doubt whether your review is constructive and useful enough because no matter how tiny, a suggestion may make a profound influence on MatrixOne. Certainly, before reviewing we ask that you browse this page to learn basic requirements and relative methods.","title":"Reviews"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/review-a-pull-request/#principles-of-the-code-review","text":"When you review a pull request, there are several rules and suggestions you should take to propose better comments. Regardless of the specifics, we suggest you stay friendly first: Be respectful Be respectful to every pull request author and other reviewers. Code review is a part of community activities so you should follow the community requirements. Be careful with tone Try to frame your comments as suggestions or questions instead of commands. If the tone is softer, your reviews will be easier to accept. Be generous with your compliments We recommended you offer encouragement and appreciation to the authors for their good practices in the code segments. In many cases, telling the authors what they did is right is even more valuable than telling them what they did is wrong. Additionally, here are some suggestions in terms of content: Provide more We encourage you to provide additional details and context of your review process as much as you can. Undoubtedly, the more detailed your review, the more useful it will be to others. If you test the pull request, please report the result and your test environment details. If you request some changes, try to suggest how. Keep objective Avoid individual biased opinions and subjective emotions. Of course, everyone will comment with more or less subjective opinions, however, as a good reviewer you should consider the technique and data facts rather than your own personal preferences. Case by case It's difficult to decide whether it's more reasonable to accept or reject when you are faced with a complex problem. Regrettably, we can't provide a certain answer because it always depends on the specific situation, which asks you to balance the pros and cons.","title":"Principles of the code review"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/review-a-pull-request/#classifying-pull-requests","text":"Some pull request authors may not be familiar with MatrixOne, the MatriOne development workflow, or the MatrixOne community. They don't know what labels should be added to the pull requests or which expert could be asked for a review. If you are able to, it would be great for you to triage the pull requests, add suitable labels to the pull requests, and request corresponding experts to review the pull requests. These actions could help more contributors notice the pull requests and make quick responses.","title":"Classifying pull requests"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/review-a-pull-request/#checking-pull-requests","text":"There are some basic aspects to check when you review a pull request: Concentration One pull request should only do one thing. No matter how small it is, the change does exactly one thing and gets it right. Don't mix other changes into it. Tests A pull request should be test covered, whether the tests are unit tests, integration tests, or end-to-end tests. Tests should be sufficient, correct and don't slow down the CI pipeline largely. Functionality The pull request should implement what the author intends to do, fit well in the existing code base, and resolve a real problem for users. Thus you should check whether or not the pull request achieve the intention and you could follow the discussions in the corresponding GitHub issue . Style Code in the pull request should follow common programming style . However, sometimes the existing code is inconsistent with the style guide, you should maintain consistency with the existing code or file a new issue to fix the existing code style first. Documentation If a pull request changes how users build, test, interact with, or release code, you must check whether it also updates the related documentation such as README.md and any generated reference docs. Similarly, if a pull request deletes or deprecates code, you must check whether or not the corresponding documentation should also be deleted. Performance If you find the pull request may affect performance, you could ask the author to provide a benchmark result.","title":"Checking pull requests"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/types-of-contributions/","text":"Types of Contributions Contributions to MatrixOne are not limited to writing code. What follows are different ways to participate in the MatrixOne project and engage with our vibrant open-source community: Contribute Code Contribution type Description Report a bug To report a problem with MatrixOne, file an issue on GitHub. Include detailed information about the problem you've encountered. Contribute code You can fix a bug for any outstanding issues on GitHub, improve the code, or propose a design or implementation for a new MatrixOne feature. See Contribute Code for the contribution conventions and best practices. Review or approve pull requests Review or approve pull requests for the MatrixOne project as a reviewer or maintainer. Contribute to MatrixOne Documentation Contribution type Description Report or fix a technical documentation issue You can either click edit the page directly on the target page of MatrixOne, or file an issue on MatrixOne repository with detailed information, and, if possible, propose changes by creating a pull request . Contribute a new piece of technical document Before contributing a full-length technical document, read Contribution Documentation . Other Contributions Contribution type Description Share your demos and solutions Show MatrixOne users how to leverage the platform in specific scenarios. Send your use case to dengnan@matrixorigin.io and we'll post it in the community. Author a blog article, user story, or whitepapers Write high-quality content that clearly and accurately explains technical details about MatrixOne. Give a tech talk or host a live broadcast Give talks or host live broadcasts that help raise awareness around MatrixOne. Support MatrixOne users Help users on GitHub solve the problems they meet while using MatrixOne. Issue triage Adding descriptive labels to our GitHub issues speeds up routing issues to the right person in charge. It is a great contribution to the operation of the MatrixOne project. Contribute otherwise Any contribution that plays a positive role in the development of MatrixOne and its open-source community will be considered for eligibility.","title":"Types of Contributions"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/types-of-contributions/#types-of-contributions","text":"Contributions to MatrixOne are not limited to writing code. What follows are different ways to participate in the MatrixOne project and engage with our vibrant open-source community:","title":"Types of Contributions"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/types-of-contributions/#contribute-code","text":"Contribution type Description Report a bug To report a problem with MatrixOne, file an issue on GitHub. Include detailed information about the problem you've encountered. Contribute code You can fix a bug for any outstanding issues on GitHub, improve the code, or propose a design or implementation for a new MatrixOne feature. See Contribute Code for the contribution conventions and best practices. Review or approve pull requests Review or approve pull requests for the MatrixOne project as a reviewer or maintainer.","title":"Contribute Code"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/types-of-contributions/#contribute-to-matrixone-documentation","text":"Contribution type Description Report or fix a technical documentation issue You can either click edit the page directly on the target page of MatrixOne, or file an issue on MatrixOne repository with detailed information, and, if possible, propose changes by creating a pull request . Contribute a new piece of technical document Before contributing a full-length technical document, read Contribution Documentation .","title":"Contribute to MatrixOne Documentation"},{"location":"MatrixOne/Contribution-Guide/How-to-Contribute/types-of-contributions/#other-contributions","text":"Contribution type Description Share your demos and solutions Show MatrixOne users how to leverage the platform in specific scenarios. Send your use case to dengnan@matrixorigin.io and we'll post it in the community. Author a blog article, user story, or whitepapers Write high-quality content that clearly and accurately explains technical details about MatrixOne. Give a tech talk or host a live broadcast Give talks or host live broadcasts that help raise awareness around MatrixOne. Support MatrixOne users Help users on GitHub solve the problems they meet while using MatrixOne. Issue triage Adding descriptive labels to our GitHub issues speeds up routing issues to the right person in charge. It is a great contribution to the operation of the MatrixOne project. Contribute otherwise Any contribution that plays a positive role in the development of MatrixOne and its open-source community will be considered for eligibility.","title":"Other Contributions"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/","text":"Develop an aggregate function Prerequisite To develop an aggregate function for MatrixOne, you need a basic knowledge of Golang programming. You can go through this excellent Golang tutorial to learn some basic Golang concepts. Preparation Before you start, please make sure that you have Go installed and have cloned the MatrixOne code base. Please refer to Preparation and Contribute Code for more details. What is an aggregation function? In database systems, an aggregate function or aggregation function is a function where the values of multiple rows are grouped together to form a single summary value. Common aggregate functions include: COUNT counts how many rows are in a particular column. SUM adds together all the values in a particular column. MIN and MAX return the lowest and highest values in a particular column, respectively. AVG calculates the average of a group of selected values. Aggregate function in MatrixOne The function join in MatrixOne's database is highly efficient and less redundant in comparison with other state-of-the-art databases via factorisation making it a key feature. Therefore, many operations in MatrixOne need to be adapted to the factorisation method, in order to improve efficiency when performing join . Aggregate functions are an example of an important feature among these operations. To implement aggragate functions in MatrixOne, we design a data structure named Ring . Every aggregate function needs to implement the Ring interface in order to be factorized when join occurs. For the common aggregate function AVG as an example, we need to calculate the number of groups and their total numeric sum, then get an average result. This is common practice for any database design. However, when a query with join occurs between two tables, the common method is to get a Cartesian product by joining tables first, then perform an AVG with that Cartesian product. This is an expensive computational cost as a Cartesian product can be very large. In MatrixOne's implementation, the factorisation method pushs down the calculation of group statistics and sum before the join operation is performed. This method helps to reduce a lot in computational and storage cost. Factorisation is realized by the Ring interface and its inner functions. To checkout more about the factorisation theory and factorised database, please refer to Principles of Factorised Databases . What is a Ring Ring is an important data structure for MatrixOne factorisation, as well as a mathematical algebraic concept with a clear definition . An algebraic Ring is a set equipped with two binary operations + (addition) and \u22c5 (multiplication) satisfying several axioms. A Ring in MatrixOne is an interface with several functions similar to the algebraic Ring structure. We use Ring interface to implement aggragate functions. The + (addition) is defined as merging two Ring s groups and the \u22c5 (multiplication) operation is defined as the computation of a grouped aggregate value combined with its grouping key frequency information. Method of Ring Interface Do What Count Return the number of groups Size Return the memory size of Ring Dup Duplicate a Ring of same type Type Return the type of a Ring String Return some basic information of Ring for execution plan log Free Free the Ring memory Grow Add a group for the Ring Grows Add multiple groups for the Ring SetLength Shrink the size of Ring, keep the first N groups Shrink Shrink the size of Ring, keep the designated groups Eval Return the eventual result of the aggregate function Fill Update the data of Ring by a row BulkFill Update the ring data by a whole vector BatchFill Update the ring data by a part of vector Add Merge a couple of groups for two Rings BatchAdd Merge several couples of groups for two Rings Mul Multiplication between groups for two Rings, called when join occurs The implementation of Ring data structure is under /pkg/container/ring/ . How does Ring work with query: To better understand the Ring interface, we can take aggregate function sum() as an example. We'll walk you through the whole process of Ring . There are two different scenarios for aggregation functions with Ring s. 1. Query with single table. In the single table scenario, when we run the below query, it generates one or several Ring s, depending on the storage blocks the T1 table is stored. The number of blocks depends on the storage strategy. Each Ring will store several groups of sums. The number of the group depends on how many duplicate rows are in this Ring . T1 ( id , class , age ) + ------+-------+------+ | id | class | age | + ------+-------+------+ | 1 | one | 23 | | 2 | one | 20 | | 3 | one | 22 | | 4 | two | 20 | | 5 | two | 19 | | 6 | three | 18 | | 7 | three | 20 | | 8 | three | 21 | | 9 | three | 24 | | 10 | three | 19 | + ------+-------+------+ select class , sum ( age ) from T1 group by class ; For example, if two Ring s were generated, the first Ring holds the group sums of the first 4 rows, which will be like: | one | 23 + 20 + 22 | | two | 20 | The second Ring holds the group sums of the last 6 rows, which will be like: | two | 19 | | three | 18 + 20 + 21 + 24 + 19 | Then the Add method of Ring will be called to merge two groups together, and at last the Eval method will return the overall result to user. | one | 23 + 20 + 22 | | two | 20 + 19 | | three | 18 + 20 + 21 + 24 + 19 | 2. Query with joining multiple tables. In the multiple tables join scenario, we have two tables Tc and Ts . The query looks like the following. Tc ( id , class ) + ------+-------+ | id | class | + ------+-------+ | 1 | one | | 2 | one | | 3 | one | | 4 | two | | 5 | two | | 6 | three | | 7 | three | | 8 | three | | 9 | three | | 10 | three | + ------+-------+ Ts ( id , age ) + ------+------+ | id | age | + ------+------+ | 1 | 23 | | 2 | 20 | | 3 | 22 | | 4 | 20 | | 5 | 19 | | 6 | 18 | | 7 | 20 | | 8 | 24 | | 9 | 24 | | 10 | 19 | + ------+------+ select class , sum ( age ) from Tc join Ts on Tc . id = Ts . id group by class ; When we run this query, it will firstly generate Ring s for the Ts table since we are performing an aggeration over the age column. It might also generate one or several Ring s same as the single table. For simplicity, we imagine only one Ring is created for each table. The Ring-Ts will start to count sums for the group of id as all id s are different, so it will maintain the same. Then a hashtable will be created for performing join operation. The Ring-Tc is created in the same time as join is performed. This Ring-Tc will count the appearing frequency f of id. Then the Mul method of Ring-Ts is called to calculate the sum calculated from the Ring-Ts and frequency from Ring-Tc . sum[i] = sum[i] * f[i] Now we get values of [class, sum(age)] , then perform a group by with class which will give us the final result. The secret of factorisation From the above example, you can see that the Ring performs some pre calculations and only the result(like sum ) is stored in its structure. When performing operations like join , only simple Add or Multiplication is needed to get the result, which is called a push down calculation in factorisation . With the help of this push down, we no longer need to deal with a costly Cartesian product. As the joined table number increases, the factorisation allows us to take linear cost of performing that instead of exponential increase. Take the implementation of Variance function as an example. The variance formula is as below: Variance = \u03a3 [(xi - x\u0305)^2]/n Example: xi = 10,8,6,12,14, x\u0305 = 10 Calculation: ((10-10)^2+(8-10)^2+(6-10)^2+(12-10)^2+(14-10)^2)/5 = 8 If we proceed with implementing this formula, we have to record all values of each group, and also maintain these values with Add and Mul operations of Ring . Eventually the result is calculated in an Eval() function. This implementation has a drawback of high memory cost since we have to store all the values during processing. In the Avg implementation, it doesn't store all values in the Ring . Instead it stores only the sum of each group and the null numbers. It returns the final result with a simple division. This method saves a lot of memory space. Now let's turn the Variance formula a bit into a different form: Variance = \u03a3 (xi^2)/n-x\u0305^2 Example: xi = 10,8,6,12,14, x\u0305 = 10 Calculation: (10^2+8^2+6^2+12^2+14^2)/5-10^2 = 8 This formula's result is exactly the same as the previous one, but we only have to record the values sum of xi^2 and the sum of xi . We can largely reduce the memory space with this kind of reformulation. To conclude, every aggregate function needs to find a way to record as little values as possible in order to reduce memory cost. Below are two different implementations for Variance (the second one has a better performance): //Implementation1 type VarRing struct { // Typ is vector's value type Typ types . Type // attributes for computing the variance Data [] byte // store all the Sums' bytes Sums [] float64 // sums of each group, its memory address is same to Data Values [][] float64 // values of each group NullCounts [] int64 // group to record number of the null value } //Implementation2 type VarRing struct { // Typ is vector's value type Typ types . Type // attributes for computing the variance Data [] byte SumX [] float64 // sum of x, its memory address is same to Data, because we will use it to store result finally. SumX2 [] float64 // sum of x^2 NullCounts [] int64 // group to record number of the null value } Develop an var() function In this tutorial, we will walk you through the complete implementation of the Variance (get the standard overall variance value) aggregate function as an example with two different methods. Step 1: register function MatrixOne doesn't distinguish between operators and functions. In our code repository, the file pkg/sql/viewexec/transformer/types.go registers aggregate functions as operators and we assign each operator a distinct integer number. To add a new function var() , first add a new const Variance in the const declaration and var in the name declaration. const ( Sum = iota Avg Max Min Count StarCount ApproxCountDistinct Variance ) var TransformerNames = [ ... ] string { Sum : \"sum\" , Avg : \"avg\" , Max : \"max\" , Min : \"min\" , Count : \"count\" , StarCount : \"starcount\" , ApproxCountDistinct : \"approx_count_distinct\" , Variance : \"var\" , } Step2: implement the Ring interface 1. Define Ring structure Create variance.go under pkg/container/ring , and define a structure of VarRing . As we calculate the overall variance, we need to calculate: The numeric Sums and the null value numbers of each group, to calculate the average. Values of each group, to calculate the variance. //Implementation1 type VarRing struct { // Typ is vector's value type Typ types . Type // attributes for computing the variance Data [] byte // store all the Sums' bytes Sums [] float64 // sums of each group, its memory address is same to Data Values [][] float64 // values of each group NullCounts [] int64 // group to record number of the null value } //Implementation2 type VarRing struct { // Typ is vector's value type Typ types . Type // attributes for computing the variance Data [] byte SumX [] float64 // sum of x, its memory address is same to Data, because we will use it to store result finally. SumX2 [] float64 // sum of x^2 NullCounts [] int64 // group to record number of the null value } 2. Implement the functions of Ring interface You can checkout the full implmetation at variance.go . Fill function //Implementation1 func ( v * VarRing ) Fill ( i , j int64 , z int64 , vec * vector . Vector ) { var value float64 = 0 switch vec . Typ . Oid { case types . T_int8 : value = float64 ( vec . Col .([] int8 )[ j ]) case ... } for k := z ; k > 0 ; k -- { v . Values [ i ] = append ( v . Values [ i ], value ) } v . Sums [ i ] += value * float64 ( z ) if nulls . Contains ( vec . Nsp , uint64 ( z )) { v . NullCounts [ i ] += z } } //Implementation2 func ( v * VarRing ) Fill ( i , j int64 , z int64 , vec * vector . Vector ) { var value float64 = 0 switch vec . Typ . Oid { case types . T_int8 : value = float64 ( vec . Col .([] int8 )[ j ]) case ... } v . SumX [ i ] += value * float64 ( z ) v . SumX2 [ i ] += math . Pow ( value , 2 ) * float64 ( z ) if nulls . Contains ( vec . Nsp , uint64 ( z )) { v . NullCounts [ i ] += z } } Add function //Implementation1 func ( v * VarRing ) Add ( a interface {}, x , y int64 ) { v2 := a .( * VarRing ) v . Sums [ x ] += v2 . Sums [ y ] v . NullCounts [ x ] += v2 . NullCounts [ y ] v . Values [ x ] = append ( v . Values [ x ], v2 . Values [ y ] ... ) } //Implementation2 func ( v * VarRing ) Add ( a interface {}, x , y int64 ) { v2 := a .( * VarRing ) v . SumX [ x ] += v2 . SumX [ y ] v . SumX2 [ x ] += v2 . SumX2 [ y ] v . NullCounts [ x ] += v2 . NullCounts [ y ] } Mul function //Implementation1 func ( v * VarRing ) Mul ( a interface {}, x , y , z int64 ) { v2 := a .( * VarRing ) { v . Sums [ x ] += v2 . Sums [ y ] * float64 ( z ) v . NullCounts [ x ] += v2 . NullCounts [ y ] * z for k := z ; k > 0 ; k -- { v . Values [ x ] = append ( v . Values [ x ], v2 . Values [ y ] ... ) } } } //Implementation2 func ( v * VarRing ) Mul ( a interface {}, x , y , z int64 ) { v2 := a .( * VarRing ) { v . SumX [ x ] += v2 . SumX [ y ] * float64 ( z ) v . SumX2 [ x ] += v2 . SumX2 [ y ] * float64 ( z ) v . NullCounts [ x ] += v2 . NullCounts [ y ] * z } } Eval function //Implementation1 func ( v * VarRing ) Eval ( zs [] int64 ) * vector . Vector { defer func () { ... }() nsp := new ( nulls . Nulls ) for i , z := range zs { if n := z - v . NullCounts [ i ]; n == 0 { nulls . Add ( nsp , uint64 ( i )) } else { v . Sums [ i ] /= float64 ( n ) var variance float64 = 0 avg := v . Sums [ i ] for _ , value := range v . Values [ i ] { variance += math . Pow ( value - avg , 2.0 ) / float64 ( n ) } v . Sums [ i ] = variance } } return ... } //Implementation2 func ( v * VarRing ) Eval ( zs [] int64 ) * vector . Vector { defer func () { ... }() nsp := new ( nulls . Nulls ) for i , z := range zs { if n := z - v . NullCounts [ i ]; n == 0 { nulls . Add ( nsp , uint64 ( i )) } else { v . SumX [ i ] /= float64 ( n ) // compute E(x) v . SumX2 [ i ] /= float64 ( n ) // compute E(x^2) variance := v . SumX2 [ i ] - math . Pow ( v . SumX [ i ], 2 ) v . SumX [ i ] = variance // using v.SumX to record the result and return. } } return ... } 3. Implement encoding and decoding for VarRing In the pkg/sql/protocol/protocol.go file, implement the code for serialization and deserialization of VarRing . Serialization function Deserialization function EncodeRing DecodeRing DecodeRingWithProcess Serialization: case * variance . VarRing : buf . WriteByte ( VarianceRing ) // NullCounts n := len ( v . NullCounts ) buf . Write ( encoding . EncodeUint32 ( uint32 ( n ))) if n > 0 { buf . Write ( encoding . EncodeInt64Slice ( v . NullCounts )) } // Sumx2 n = len ( v . SumX2 ) buf . Write ( encoding . EncodeUint32 ( uint32 ( n ))) if n > 0 { buf . Write ( encoding . EncodeFloat64Slice ( v . SumX2 )) } // Sumx da := encoding . EncodeFloat64Slice ( v . SumX ) n = len ( da ) buf . Write ( encoding . EncodeUint32 ( uint32 ( n ))) if n > 0 { buf . Write ( da ) } // Typ buf . Write ( encoding . EncodeType ( v . Typ )) return nil Deserialization: case VarianceRing : r := new ( variance . VarRing ) data = data [ 1 :] // decode NullCounts n := encoding . DecodeUint32 ( data [: 4 ]) data = data [ 4 :] if n > 0 { r . NullCounts = make ([] int64 , n ) copy ( r . NullCounts , encoding . DecodeInt64Slice ( data [: n * 8 ])) data = data [ n * 8 :] } // decode Sumx2 n = encoding . DecodeUint32 ( data [: 4 ]) data = data [ 4 :] if n > 0 { r . SumX2 = make ([] float64 , n ) copy ( r . SumX2 , encoding . DecodeFloat64Slice ( data [: n * 8 ])) data = data [ n * 8 :] } // decode Sumx n = encoding . DecodeUint32 ( data [: 4 ]) data = data [ 4 :] if n > 0 { r . Data = data [: n ] data = data [ n :] } r . SumX = encoding . DecodeFloat64Slice ( r . Data ) // decode typ typ := encoding . DecodeType ( data [: encoding . TypeSize ]) data = data [ encoding . TypeSize :] r . Typ = typ // return return r , data , nil Here we go. Now we can fire up MatrixOne and try with our var() function. Compile and run MatrixOne Once the aggregation function is ready, we can compile and run MatrixOne to see the function behavior. Step1: Run make config and make build to compile the MatrixOne project and build binary file. make config make build Info make config generates a new configuration file. In this tutorial you only need to run it once. If you modify some code and want to recompile, you only have to run make build . Step2: Run ./mo-server system_vars_config.toml to launch MatrixOne, the MatrixOne server will start to listen for client connecting. ./mo-server system_vars_config.toml Info The logger print level of system_vars_config.toml is set to default as DEBUG , which will print a lot of information for you. If you only care about what your function will print, you can modify the system_vars_config.toml and set cubeLogLevel and level to ERROR level. cubeLogLevel = \"error\" level = \"error\" Info Sometimes a port is in use error at port 50000 will occur. You could checkout what process in occupying port 50000 by lsof -i:50000 . This command helps you to get the PIDNAME of this process, then you can kill the process by kill -9 PIDNAME . Step3: Connect to MatrixOne server with a MySQL client. Use the built-in test account for example: user: dump password: 111 $ mysql -h 127.0.0.1 -P 6001 -udump -p Enter password: Step4: Test your function behavior with some data. Below is an example. You can check if you get the right mathematical variance result. You can also try an inner join and check the result, if the result is correct, the factorisation is valid. mysql > select * from variance ; + ------+------+ | a | b | + ------+------+ | 1 | 4 | | 10 | 3 | | 19 | 12 | | 239 | 114 | | 49 | 149 | | 10 | 159 | | 1 | 3 | | 34 | 35 | + ------+------+ 8 rows in set ( 0 . 04 sec ) mysql > select * from variance2 ; + ------+------+ | a | b | + ------+------+ | 14 | 3514 | | 10 | 3514 | | 1 | 61 | + ------+------+ 3 rows in set ( 0 . 02 sec ) mysql > select var ( variance . a ), var ( variance . b ) from variance ; + -----------------+-----------------+ | var ( variance . a ) | var ( variance . b ) | + -----------------+-----------------+ | 5596 . 2344 | 4150 . 1094 | + -----------------+-----------------+ 1 row in set ( 0 . 06 sec ) mysql > select variance . a , var ( variance . b ) from variance inner join variance2 on variance . a = variance2 . a group by variance . a ; + ------------+-----------------+ | variance . a | var ( variance . b ) | + ------------+-----------------+ | 10 | 6084 . 0000 | | 1 | 0 . 2500 | + ------------+-----------------+ 2 rows in set ( 0 . 04 sec ) Bingo! Info Except for var() , MatrixOne has already some neat examples for aggregate functions, such as sum() , count() , max() , min() and avg() . With some minor corresponding changes, the procedure is quite the same as other functions. \u200b Write unit Test for your function We recommend that you also write a unit test for the new function. Go has a built-in testing command called go test and a package testing which combine to give a minimal yet complete testing experience. It automates execution of any function of the form. func TestXxx(*testing.T) To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the go test command is run. Step1: Create a file named variance_test.go under pkg/container/ring/variance/ directory. Import the testing framework and the reflect framework we are going to use for testing. package variance import ( \"fmt\" \"github.com/matrixorigin/matrixone/pkg/container/types\" \"reflect\" \"testing\" ) // TestVariance just for verify varRing related process func TestVariance ( t * testing . T ) { } Step2: Implement the TestVariance function with some predefined values. func TestVariance ( t * testing . T ) { // verify that if we can calculate // the variance of {1, 2, null, 0, 3, 4} and {2, 3, null, null, 4, 5} correctly // 1. make the test case v1 := NewVarianceRing ( types . Type { Oid : types . T_float64 }) v2 := v1 . Dup ().( * VarRing ) { // first 3 rows. // column1: {1, 2, null}, column2: {2, 3, null} v1 . SumX = [] float64 { 1 + 2 , 2 + 3 } v1 . SumX2 = [] float64 { 1 * 1 + 2 * 2 , 2 * 2 + 3 * 3 } v1 . NullCounts = [] int64 { 1 , 1 } } { // last 3 rows. // column1: {0, 3, 4}, column2: {null, 4, 5} v2 . SumX = [] float64 { 0 + 3 + 4 , 4 + 5 } v2 . SumX2 = [] float64 { 3 * 3 + 4 * 4 , 4 * 4 + 5 * 5 } v2 . NullCounts = [] int64 { 0 , 1 } } v1 . Add ( v2 , 0 , 0 ) v1 . Add ( v2 , 1 , 1 ) result := v1 . Eval ([] int64 { 6 , 6 }) expected := [] float64 { 2.0 , 1.25 } if ! reflect . DeepEqual ( result . Col , expected ) { t . Errorf ( fmt . Sprintf ( \"TestVariance wrong, expected %v, but got %v\" , expected , result . Col )) } } Step3: Complete the unit test for Serialization and Deserialization in the function TestRing in the file pkg/sql/protocol/protocol_test.go . You can check the complete test code of VarRing there. & variance . VarRing { NullCounts : [] int64 { 1 , 2 , 3 }, SumX : [] float64 { 4 , 9 , 13 }, SumX2 : [] float64 { 16 , 81 , 169 }, Typ : types . Type { Oid : types . T ( types . T_float64 ), Size : 8 }, } case * variance . VarRing : oriRing := r .( * variance . VarRing ) // Sumx if string ( ExpectRing . Data ) != string ( encoding . EncodeFloat64Slice ( oriRing . SumX )) { t . Errorf ( \"Decode varRing Sums failed.\" ) return } // NullCounts for i , n := range oriRing . NullCounts { if ExpectRing . NullCounts [ i ] != n { t . Errorf ( \"Decode varRing NullCounts failed. \\nExpected/Got:\\n%v\\n%v\" , n , ExpectRing . NullCounts [ i ]) return } } // Sumx2 for i , v := range oriRing . SumX2 { if ! reflect . DeepEqual ( ExpectRing . SumX2 [ i ], v ) { t . Errorf ( \"Decode varRing Values failed. \\nExpected/Got:\\n%v\\n%v\" , v , ExpectRing . SumX2 [ i ]) return } } Step4: Launch Test. Within the same directory as the test: go test This picks up any files matching packagename_test.go. If you are getting a PASS , you are passing the unit test. In MatrixOne, we have a bvt test framework which will run all the unit tests defined in the whole package, and each time your make a pull request to the code base, the test will automatically run. You code will be merged only if the bvt test pass. Conduct a Performance Test Aggregate functions are an important feature of a database system, with queries on hundreds of millions of data rows, the time consumption of an aggregate function is quite significant. Thus, we recommend you to run a performance test. Step1: Download the standard test dataset. We have prepared a single table SSB query dataset with 10 million rows of data. The raw data file size is about 4GB, 500MB after being zipped. You can get the data files directly: https://community-shared-data-1308875761.cos.ap-beijing.myqcloud.com/lineorder_flat.tar.bz2 Step2: Unzip the file and Load the data into MatrixOne. With the following SQL you can create the database and table, and load the lineorder_flat.tbl into MatrixOne. create database if not exists ssb ; use ssb ; drop table if exists lineorder_flat ; CREATE TABLE lineorder_flat ( LO_ORDERKEY bigint primary key , LO_LINENUMBER int , LO_CUSTKEY int , LO_PARTKEY int , LO_SUPPKEY int , LO_ORDERDATE date , LO_ORDERPRIORITY char ( 15 ), LO_SHIPPRIORITY tinyint , LO_QUANTITY double , LO_EXTENDEDPRICE double , LO_ORDTOTALPRICE double , LO_DISCOUNT double , LO_REVENUE int unsigned , LO_SUPPLYCOST int unsigned , LO_TAX double , LO_COMMITDATE date , LO_SHIPMODE char ( 10 ), C_NAME varchar ( 25 ), C_ADDRESS varchar ( 25 ), C_CITY char ( 10 ), C_NATION char ( 15 ), C_REGION char ( 12 ), C_PHONE char ( 15 ), C_MKTSEGMENT char ( 10 ), S_NAME char ( 25 ), S_ADDRESS varchar ( 25 ), S_CITY char ( 10 ), S_NATION char ( 15 ), S_REGION char ( 12 ), S_PHONE char ( 15 ), P_NAME varchar ( 22 ), P_MFGR char ( 6 ), P_CATEGORY char ( 7 ), P_BRAND char ( 9 ), P_COLOR varchar ( 11 ), P_TYPE varchar ( 25 ), P_SIZE int , P_CONTAINER char ( 10 ) ); load data infile '/Users/YOURPATH/lineorder_flat.tbl' into table lineorder_flat FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n' ; If you load successfully this dataset, you are normally getting a result as: Query OK, 10272594 rows affected (1 min 7.09 sec) Step3: Run your aggregate function and sum() , avg() on the column LO_SUPPKEY respectively to check the performance. select avg ( LO_SUPPKEY ) from lineorder_flat ; select sum ( LO_SUPPKEY ) from lineorder_flat ; select yourfunction ( LO_SUPPKEY ) from lineorder_flat ; Step4: When you submit your PR, please submit these performance results in your PR comment as well.","title":"Develop an aggregate function"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#develop-an-aggregate-function","text":"","title":"Develop an aggregate function"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#prerequisite","text":"To develop an aggregate function for MatrixOne, you need a basic knowledge of Golang programming. You can go through this excellent Golang tutorial to learn some basic Golang concepts.","title":"Prerequisite"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#preparation","text":"Before you start, please make sure that you have Go installed and have cloned the MatrixOne code base. Please refer to Preparation and Contribute Code for more details.","title":"Preparation"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#what-is-an-aggregation-function","text":"In database systems, an aggregate function or aggregation function is a function where the values of multiple rows are grouped together to form a single summary value. Common aggregate functions include: COUNT counts how many rows are in a particular column. SUM adds together all the values in a particular column. MIN and MAX return the lowest and highest values in a particular column, respectively. AVG calculates the average of a group of selected values.","title":"What is an aggregation function?"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#aggregate-function-in-matrixone","text":"The function join in MatrixOne's database is highly efficient and less redundant in comparison with other state-of-the-art databases via factorisation making it a key feature. Therefore, many operations in MatrixOne need to be adapted to the factorisation method, in order to improve efficiency when performing join . Aggregate functions are an example of an important feature among these operations. To implement aggragate functions in MatrixOne, we design a data structure named Ring . Every aggregate function needs to implement the Ring interface in order to be factorized when join occurs. For the common aggregate function AVG as an example, we need to calculate the number of groups and their total numeric sum, then get an average result. This is common practice for any database design. However, when a query with join occurs between two tables, the common method is to get a Cartesian product by joining tables first, then perform an AVG with that Cartesian product. This is an expensive computational cost as a Cartesian product can be very large. In MatrixOne's implementation, the factorisation method pushs down the calculation of group statistics and sum before the join operation is performed. This method helps to reduce a lot in computational and storage cost. Factorisation is realized by the Ring interface and its inner functions. To checkout more about the factorisation theory and factorised database, please refer to Principles of Factorised Databases .","title":"Aggregate function in MatrixOne"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#what-is-a-ring","text":"Ring is an important data structure for MatrixOne factorisation, as well as a mathematical algebraic concept with a clear definition . An algebraic Ring is a set equipped with two binary operations + (addition) and \u22c5 (multiplication) satisfying several axioms. A Ring in MatrixOne is an interface with several functions similar to the algebraic Ring structure. We use Ring interface to implement aggragate functions. The + (addition) is defined as merging two Ring s groups and the \u22c5 (multiplication) operation is defined as the computation of a grouped aggregate value combined with its grouping key frequency information. Method of Ring Interface Do What Count Return the number of groups Size Return the memory size of Ring Dup Duplicate a Ring of same type Type Return the type of a Ring String Return some basic information of Ring for execution plan log Free Free the Ring memory Grow Add a group for the Ring Grows Add multiple groups for the Ring SetLength Shrink the size of Ring, keep the first N groups Shrink Shrink the size of Ring, keep the designated groups Eval Return the eventual result of the aggregate function Fill Update the data of Ring by a row BulkFill Update the ring data by a whole vector BatchFill Update the ring data by a part of vector Add Merge a couple of groups for two Rings BatchAdd Merge several couples of groups for two Rings Mul Multiplication between groups for two Rings, called when join occurs The implementation of Ring data structure is under /pkg/container/ring/ .","title":"What is a Ring"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#how-does-ring-work-with-query","text":"To better understand the Ring interface, we can take aggregate function sum() as an example. We'll walk you through the whole process of Ring . There are two different scenarios for aggregation functions with Ring s. 1. Query with single table. In the single table scenario, when we run the below query, it generates one or several Ring s, depending on the storage blocks the T1 table is stored. The number of blocks depends on the storage strategy. Each Ring will store several groups of sums. The number of the group depends on how many duplicate rows are in this Ring . T1 ( id , class , age ) + ------+-------+------+ | id | class | age | + ------+-------+------+ | 1 | one | 23 | | 2 | one | 20 | | 3 | one | 22 | | 4 | two | 20 | | 5 | two | 19 | | 6 | three | 18 | | 7 | three | 20 | | 8 | three | 21 | | 9 | three | 24 | | 10 | three | 19 | + ------+-------+------+ select class , sum ( age ) from T1 group by class ; For example, if two Ring s were generated, the first Ring holds the group sums of the first 4 rows, which will be like: | one | 23 + 20 + 22 | | two | 20 | The second Ring holds the group sums of the last 6 rows, which will be like: | two | 19 | | three | 18 + 20 + 21 + 24 + 19 | Then the Add method of Ring will be called to merge two groups together, and at last the Eval method will return the overall result to user. | one | 23 + 20 + 22 | | two | 20 + 19 | | three | 18 + 20 + 21 + 24 + 19 | 2. Query with joining multiple tables. In the multiple tables join scenario, we have two tables Tc and Ts . The query looks like the following. Tc ( id , class ) + ------+-------+ | id | class | + ------+-------+ | 1 | one | | 2 | one | | 3 | one | | 4 | two | | 5 | two | | 6 | three | | 7 | three | | 8 | three | | 9 | three | | 10 | three | + ------+-------+ Ts ( id , age ) + ------+------+ | id | age | + ------+------+ | 1 | 23 | | 2 | 20 | | 3 | 22 | | 4 | 20 | | 5 | 19 | | 6 | 18 | | 7 | 20 | | 8 | 24 | | 9 | 24 | | 10 | 19 | + ------+------+ select class , sum ( age ) from Tc join Ts on Tc . id = Ts . id group by class ; When we run this query, it will firstly generate Ring s for the Ts table since we are performing an aggeration over the age column. It might also generate one or several Ring s same as the single table. For simplicity, we imagine only one Ring is created for each table. The Ring-Ts will start to count sums for the group of id as all id s are different, so it will maintain the same. Then a hashtable will be created for performing join operation. The Ring-Tc is created in the same time as join is performed. This Ring-Tc will count the appearing frequency f of id. Then the Mul method of Ring-Ts is called to calculate the sum calculated from the Ring-Ts and frequency from Ring-Tc . sum[i] = sum[i] * f[i] Now we get values of [class, sum(age)] , then perform a group by with class which will give us the final result.","title":"How does Ring work with query:"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#the-secret-of-factorisation","text":"From the above example, you can see that the Ring performs some pre calculations and only the result(like sum ) is stored in its structure. When performing operations like join , only simple Add or Multiplication is needed to get the result, which is called a push down calculation in factorisation . With the help of this push down, we no longer need to deal with a costly Cartesian product. As the joined table number increases, the factorisation allows us to take linear cost of performing that instead of exponential increase. Take the implementation of Variance function as an example. The variance formula is as below: Variance = \u03a3 [(xi - x\u0305)^2]/n Example: xi = 10,8,6,12,14, x\u0305 = 10 Calculation: ((10-10)^2+(8-10)^2+(6-10)^2+(12-10)^2+(14-10)^2)/5 = 8 If we proceed with implementing this formula, we have to record all values of each group, and also maintain these values with Add and Mul operations of Ring . Eventually the result is calculated in an Eval() function. This implementation has a drawback of high memory cost since we have to store all the values during processing. In the Avg implementation, it doesn't store all values in the Ring . Instead it stores only the sum of each group and the null numbers. It returns the final result with a simple division. This method saves a lot of memory space. Now let's turn the Variance formula a bit into a different form: Variance = \u03a3 (xi^2)/n-x\u0305^2 Example: xi = 10,8,6,12,14, x\u0305 = 10 Calculation: (10^2+8^2+6^2+12^2+14^2)/5-10^2 = 8 This formula's result is exactly the same as the previous one, but we only have to record the values sum of xi^2 and the sum of xi . We can largely reduce the memory space with this kind of reformulation. To conclude, every aggregate function needs to find a way to record as little values as possible in order to reduce memory cost. Below are two different implementations for Variance (the second one has a better performance): //Implementation1 type VarRing struct { // Typ is vector's value type Typ types . Type // attributes for computing the variance Data [] byte // store all the Sums' bytes Sums [] float64 // sums of each group, its memory address is same to Data Values [][] float64 // values of each group NullCounts [] int64 // group to record number of the null value } //Implementation2 type VarRing struct { // Typ is vector's value type Typ types . Type // attributes for computing the variance Data [] byte SumX [] float64 // sum of x, its memory address is same to Data, because we will use it to store result finally. SumX2 [] float64 // sum of x^2 NullCounts [] int64 // group to record number of the null value }","title":"The secret of factorisation"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#develop-an-var-function","text":"In this tutorial, we will walk you through the complete implementation of the Variance (get the standard overall variance value) aggregate function as an example with two different methods. Step 1: register function MatrixOne doesn't distinguish between operators and functions. In our code repository, the file pkg/sql/viewexec/transformer/types.go registers aggregate functions as operators and we assign each operator a distinct integer number. To add a new function var() , first add a new const Variance in the const declaration and var in the name declaration. const ( Sum = iota Avg Max Min Count StarCount ApproxCountDistinct Variance ) var TransformerNames = [ ... ] string { Sum : \"sum\" , Avg : \"avg\" , Max : \"max\" , Min : \"min\" , Count : \"count\" , StarCount : \"starcount\" , ApproxCountDistinct : \"approx_count_distinct\" , Variance : \"var\" , } Step2: implement the Ring interface 1. Define Ring structure Create variance.go under pkg/container/ring , and define a structure of VarRing . As we calculate the overall variance, we need to calculate: The numeric Sums and the null value numbers of each group, to calculate the average. Values of each group, to calculate the variance. //Implementation1 type VarRing struct { // Typ is vector's value type Typ types . Type // attributes for computing the variance Data [] byte // store all the Sums' bytes Sums [] float64 // sums of each group, its memory address is same to Data Values [][] float64 // values of each group NullCounts [] int64 // group to record number of the null value } //Implementation2 type VarRing struct { // Typ is vector's value type Typ types . Type // attributes for computing the variance Data [] byte SumX [] float64 // sum of x, its memory address is same to Data, because we will use it to store result finally. SumX2 [] float64 // sum of x^2 NullCounts [] int64 // group to record number of the null value } 2. Implement the functions of Ring interface You can checkout the full implmetation at variance.go . Fill function //Implementation1 func ( v * VarRing ) Fill ( i , j int64 , z int64 , vec * vector . Vector ) { var value float64 = 0 switch vec . Typ . Oid { case types . T_int8 : value = float64 ( vec . Col .([] int8 )[ j ]) case ... } for k := z ; k > 0 ; k -- { v . Values [ i ] = append ( v . Values [ i ], value ) } v . Sums [ i ] += value * float64 ( z ) if nulls . Contains ( vec . Nsp , uint64 ( z )) { v . NullCounts [ i ] += z } } //Implementation2 func ( v * VarRing ) Fill ( i , j int64 , z int64 , vec * vector . Vector ) { var value float64 = 0 switch vec . Typ . Oid { case types . T_int8 : value = float64 ( vec . Col .([] int8 )[ j ]) case ... } v . SumX [ i ] += value * float64 ( z ) v . SumX2 [ i ] += math . Pow ( value , 2 ) * float64 ( z ) if nulls . Contains ( vec . Nsp , uint64 ( z )) { v . NullCounts [ i ] += z } } Add function //Implementation1 func ( v * VarRing ) Add ( a interface {}, x , y int64 ) { v2 := a .( * VarRing ) v . Sums [ x ] += v2 . Sums [ y ] v . NullCounts [ x ] += v2 . NullCounts [ y ] v . Values [ x ] = append ( v . Values [ x ], v2 . Values [ y ] ... ) } //Implementation2 func ( v * VarRing ) Add ( a interface {}, x , y int64 ) { v2 := a .( * VarRing ) v . SumX [ x ] += v2 . SumX [ y ] v . SumX2 [ x ] += v2 . SumX2 [ y ] v . NullCounts [ x ] += v2 . NullCounts [ y ] } Mul function //Implementation1 func ( v * VarRing ) Mul ( a interface {}, x , y , z int64 ) { v2 := a .( * VarRing ) { v . Sums [ x ] += v2 . Sums [ y ] * float64 ( z ) v . NullCounts [ x ] += v2 . NullCounts [ y ] * z for k := z ; k > 0 ; k -- { v . Values [ x ] = append ( v . Values [ x ], v2 . Values [ y ] ... ) } } } //Implementation2 func ( v * VarRing ) Mul ( a interface {}, x , y , z int64 ) { v2 := a .( * VarRing ) { v . SumX [ x ] += v2 . SumX [ y ] * float64 ( z ) v . SumX2 [ x ] += v2 . SumX2 [ y ] * float64 ( z ) v . NullCounts [ x ] += v2 . NullCounts [ y ] * z } } Eval function //Implementation1 func ( v * VarRing ) Eval ( zs [] int64 ) * vector . Vector { defer func () { ... }() nsp := new ( nulls . Nulls ) for i , z := range zs { if n := z - v . NullCounts [ i ]; n == 0 { nulls . Add ( nsp , uint64 ( i )) } else { v . Sums [ i ] /= float64 ( n ) var variance float64 = 0 avg := v . Sums [ i ] for _ , value := range v . Values [ i ] { variance += math . Pow ( value - avg , 2.0 ) / float64 ( n ) } v . Sums [ i ] = variance } } return ... } //Implementation2 func ( v * VarRing ) Eval ( zs [] int64 ) * vector . Vector { defer func () { ... }() nsp := new ( nulls . Nulls ) for i , z := range zs { if n := z - v . NullCounts [ i ]; n == 0 { nulls . Add ( nsp , uint64 ( i )) } else { v . SumX [ i ] /= float64 ( n ) // compute E(x) v . SumX2 [ i ] /= float64 ( n ) // compute E(x^2) variance := v . SumX2 [ i ] - math . Pow ( v . SumX [ i ], 2 ) v . SumX [ i ] = variance // using v.SumX to record the result and return. } } return ... } 3. Implement encoding and decoding for VarRing In the pkg/sql/protocol/protocol.go file, implement the code for serialization and deserialization of VarRing . Serialization function Deserialization function EncodeRing DecodeRing DecodeRingWithProcess Serialization: case * variance . VarRing : buf . WriteByte ( VarianceRing ) // NullCounts n := len ( v . NullCounts ) buf . Write ( encoding . EncodeUint32 ( uint32 ( n ))) if n > 0 { buf . Write ( encoding . EncodeInt64Slice ( v . NullCounts )) } // Sumx2 n = len ( v . SumX2 ) buf . Write ( encoding . EncodeUint32 ( uint32 ( n ))) if n > 0 { buf . Write ( encoding . EncodeFloat64Slice ( v . SumX2 )) } // Sumx da := encoding . EncodeFloat64Slice ( v . SumX ) n = len ( da ) buf . Write ( encoding . EncodeUint32 ( uint32 ( n ))) if n > 0 { buf . Write ( da ) } // Typ buf . Write ( encoding . EncodeType ( v . Typ )) return nil Deserialization: case VarianceRing : r := new ( variance . VarRing ) data = data [ 1 :] // decode NullCounts n := encoding . DecodeUint32 ( data [: 4 ]) data = data [ 4 :] if n > 0 { r . NullCounts = make ([] int64 , n ) copy ( r . NullCounts , encoding . DecodeInt64Slice ( data [: n * 8 ])) data = data [ n * 8 :] } // decode Sumx2 n = encoding . DecodeUint32 ( data [: 4 ]) data = data [ 4 :] if n > 0 { r . SumX2 = make ([] float64 , n ) copy ( r . SumX2 , encoding . DecodeFloat64Slice ( data [: n * 8 ])) data = data [ n * 8 :] } // decode Sumx n = encoding . DecodeUint32 ( data [: 4 ]) data = data [ 4 :] if n > 0 { r . Data = data [: n ] data = data [ n :] } r . SumX = encoding . DecodeFloat64Slice ( r . Data ) // decode typ typ := encoding . DecodeType ( data [: encoding . TypeSize ]) data = data [ encoding . TypeSize :] r . Typ = typ // return return r , data , nil Here we go. Now we can fire up MatrixOne and try with our var() function.","title":"Develop an var() function"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#compile-and-run-matrixone","text":"Once the aggregation function is ready, we can compile and run MatrixOne to see the function behavior. Step1: Run make config and make build to compile the MatrixOne project and build binary file. make config make build Info make config generates a new configuration file. In this tutorial you only need to run it once. If you modify some code and want to recompile, you only have to run make build . Step2: Run ./mo-server system_vars_config.toml to launch MatrixOne, the MatrixOne server will start to listen for client connecting. ./mo-server system_vars_config.toml Info The logger print level of system_vars_config.toml is set to default as DEBUG , which will print a lot of information for you. If you only care about what your function will print, you can modify the system_vars_config.toml and set cubeLogLevel and level to ERROR level. cubeLogLevel = \"error\" level = \"error\" Info Sometimes a port is in use error at port 50000 will occur. You could checkout what process in occupying port 50000 by lsof -i:50000 . This command helps you to get the PIDNAME of this process, then you can kill the process by kill -9 PIDNAME . Step3: Connect to MatrixOne server with a MySQL client. Use the built-in test account for example: user: dump password: 111 $ mysql -h 127.0.0.1 -P 6001 -udump -p Enter password: Step4: Test your function behavior with some data. Below is an example. You can check if you get the right mathematical variance result. You can also try an inner join and check the result, if the result is correct, the factorisation is valid. mysql > select * from variance ; + ------+------+ | a | b | + ------+------+ | 1 | 4 | | 10 | 3 | | 19 | 12 | | 239 | 114 | | 49 | 149 | | 10 | 159 | | 1 | 3 | | 34 | 35 | + ------+------+ 8 rows in set ( 0 . 04 sec ) mysql > select * from variance2 ; + ------+------+ | a | b | + ------+------+ | 14 | 3514 | | 10 | 3514 | | 1 | 61 | + ------+------+ 3 rows in set ( 0 . 02 sec ) mysql > select var ( variance . a ), var ( variance . b ) from variance ; + -----------------+-----------------+ | var ( variance . a ) | var ( variance . b ) | + -----------------+-----------------+ | 5596 . 2344 | 4150 . 1094 | + -----------------+-----------------+ 1 row in set ( 0 . 06 sec ) mysql > select variance . a , var ( variance . b ) from variance inner join variance2 on variance . a = variance2 . a group by variance . a ; + ------------+-----------------+ | variance . a | var ( variance . b ) | + ------------+-----------------+ | 10 | 6084 . 0000 | | 1 | 0 . 2500 | + ------------+-----------------+ 2 rows in set ( 0 . 04 sec ) Bingo! Info Except for var() , MatrixOne has already some neat examples for aggregate functions, such as sum() , count() , max() , min() and avg() . With some minor corresponding changes, the procedure is quite the same as other functions. \u200b","title":"Compile and run MatrixOne"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#write-unit-test-for-your-function","text":"We recommend that you also write a unit test for the new function. Go has a built-in testing command called go test and a package testing which combine to give a minimal yet complete testing experience. It automates execution of any function of the form. func TestXxx(*testing.T) To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the go test command is run. Step1: Create a file named variance_test.go under pkg/container/ring/variance/ directory. Import the testing framework and the reflect framework we are going to use for testing. package variance import ( \"fmt\" \"github.com/matrixorigin/matrixone/pkg/container/types\" \"reflect\" \"testing\" ) // TestVariance just for verify varRing related process func TestVariance ( t * testing . T ) { } Step2: Implement the TestVariance function with some predefined values. func TestVariance ( t * testing . T ) { // verify that if we can calculate // the variance of {1, 2, null, 0, 3, 4} and {2, 3, null, null, 4, 5} correctly // 1. make the test case v1 := NewVarianceRing ( types . Type { Oid : types . T_float64 }) v2 := v1 . Dup ().( * VarRing ) { // first 3 rows. // column1: {1, 2, null}, column2: {2, 3, null} v1 . SumX = [] float64 { 1 + 2 , 2 + 3 } v1 . SumX2 = [] float64 { 1 * 1 + 2 * 2 , 2 * 2 + 3 * 3 } v1 . NullCounts = [] int64 { 1 , 1 } } { // last 3 rows. // column1: {0, 3, 4}, column2: {null, 4, 5} v2 . SumX = [] float64 { 0 + 3 + 4 , 4 + 5 } v2 . SumX2 = [] float64 { 3 * 3 + 4 * 4 , 4 * 4 + 5 * 5 } v2 . NullCounts = [] int64 { 0 , 1 } } v1 . Add ( v2 , 0 , 0 ) v1 . Add ( v2 , 1 , 1 ) result := v1 . Eval ([] int64 { 6 , 6 }) expected := [] float64 { 2.0 , 1.25 } if ! reflect . DeepEqual ( result . Col , expected ) { t . Errorf ( fmt . Sprintf ( \"TestVariance wrong, expected %v, but got %v\" , expected , result . Col )) } } Step3: Complete the unit test for Serialization and Deserialization in the function TestRing in the file pkg/sql/protocol/protocol_test.go . You can check the complete test code of VarRing there. & variance . VarRing { NullCounts : [] int64 { 1 , 2 , 3 }, SumX : [] float64 { 4 , 9 , 13 }, SumX2 : [] float64 { 16 , 81 , 169 }, Typ : types . Type { Oid : types . T ( types . T_float64 ), Size : 8 }, } case * variance . VarRing : oriRing := r .( * variance . VarRing ) // Sumx if string ( ExpectRing . Data ) != string ( encoding . EncodeFloat64Slice ( oriRing . SumX )) { t . Errorf ( \"Decode varRing Sums failed.\" ) return } // NullCounts for i , n := range oriRing . NullCounts { if ExpectRing . NullCounts [ i ] != n { t . Errorf ( \"Decode varRing NullCounts failed. \\nExpected/Got:\\n%v\\n%v\" , n , ExpectRing . NullCounts [ i ]) return } } // Sumx2 for i , v := range oriRing . SumX2 { if ! reflect . DeepEqual ( ExpectRing . SumX2 [ i ], v ) { t . Errorf ( \"Decode varRing Values failed. \\nExpected/Got:\\n%v\\n%v\" , v , ExpectRing . SumX2 [ i ]) return } } Step4: Launch Test. Within the same directory as the test: go test This picks up any files matching packagename_test.go. If you are getting a PASS , you are passing the unit test. In MatrixOne, we have a bvt test framework which will run all the unit tests defined in the whole package, and each time your make a pull request to the code base, the test will automatically run. You code will be merged only if the bvt test pass.","title":"Write unit Test for your function"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_aggregate_functions/#conduct-a-performance-test","text":"Aggregate functions are an important feature of a database system, with queries on hundreds of millions of data rows, the time consumption of an aggregate function is quite significant. Thus, we recommend you to run a performance test. Step1: Download the standard test dataset. We have prepared a single table SSB query dataset with 10 million rows of data. The raw data file size is about 4GB, 500MB after being zipped. You can get the data files directly: https://community-shared-data-1308875761.cos.ap-beijing.myqcloud.com/lineorder_flat.tar.bz2 Step2: Unzip the file and Load the data into MatrixOne. With the following SQL you can create the database and table, and load the lineorder_flat.tbl into MatrixOne. create database if not exists ssb ; use ssb ; drop table if exists lineorder_flat ; CREATE TABLE lineorder_flat ( LO_ORDERKEY bigint primary key , LO_LINENUMBER int , LO_CUSTKEY int , LO_PARTKEY int , LO_SUPPKEY int , LO_ORDERDATE date , LO_ORDERPRIORITY char ( 15 ), LO_SHIPPRIORITY tinyint , LO_QUANTITY double , LO_EXTENDEDPRICE double , LO_ORDTOTALPRICE double , LO_DISCOUNT double , LO_REVENUE int unsigned , LO_SUPPLYCOST int unsigned , LO_TAX double , LO_COMMITDATE date , LO_SHIPMODE char ( 10 ), C_NAME varchar ( 25 ), C_ADDRESS varchar ( 25 ), C_CITY char ( 10 ), C_NATION char ( 15 ), C_REGION char ( 12 ), C_PHONE char ( 15 ), C_MKTSEGMENT char ( 10 ), S_NAME char ( 25 ), S_ADDRESS varchar ( 25 ), S_CITY char ( 10 ), S_NATION char ( 15 ), S_REGION char ( 12 ), S_PHONE char ( 15 ), P_NAME varchar ( 22 ), P_MFGR char ( 6 ), P_CATEGORY char ( 7 ), P_BRAND char ( 9 ), P_COLOR varchar ( 11 ), P_TYPE varchar ( 25 ), P_SIZE int , P_CONTAINER char ( 10 ) ); load data infile '/Users/YOURPATH/lineorder_flat.tbl' into table lineorder_flat FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n' ; If you load successfully this dataset, you are normally getting a result as: Query OK, 10272594 rows affected (1 min 7.09 sec) Step3: Run your aggregate function and sum() , avg() on the column LO_SUPPKEY respectively to check the performance. select avg ( LO_SUPPKEY ) from lineorder_flat ; select sum ( LO_SUPPKEY ) from lineorder_flat ; select yourfunction ( LO_SUPPKEY ) from lineorder_flat ; Step4: When you submit your PR, please submit these performance results in your PR comment as well.","title":"Conduct a Performance Test"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/","text":"Develop a built-in function Prerequisite To develop a built-in function for MatrixOne, you need a basic knowledge of Golang programming. You can go through this excellent Golang tutorial to learn some basic Golang concepts. Preparation Before you start, please make sure that you have Go installed, cloned the MatrixOne code base. Please refer to Preparation and Contribute Code for more details. What is a built-in function? There are two types of functions in a database, built-in functions and user-defined functions. Built-in functions are functions that are shipped with the database. In contrast, user-defined functions are customized by the users. Built-in functions can be categorized according to the data types that they operate on i.e. strings, date and numeric built-in functions. An example of a built-in function is abs() , which calculates the absolute (non-negative) value of a given number. Some functions, such as abs() are used to perform calculations. Others such as getdate() are used to obtain a system value, such as the current data, or others, like left() , are used to manipulate textual data. Usually the built-in functions are categorized into major categories: Conversion Functions Logical Functions Math Functions String Functions Date Functions Develop an abs() function: In this tutorial, we use the function ABS (get the absolute value) as an example. Step 1: register function MatrixOne doesn't distinguish between operators and functions. In our code repository, the file pkg/builtin/types.go register builtin functions as operators and we assign each operator a distinct integer number. To add a new function abs() , add a new const Abs in the const declaration. const ( Length = iota + overload . NE + 1 Year Round Floor Abs ) In the directory pkg/builtin/unary , create a new go file abs.go . Info The functions under unary directory take only one value as input. The functions under binary directory take only two values as input. Other forms of functions are put under multi directory. This abs.go file has the following functionalities: 1. function name registration 2. declare all the different parameter types this function accepts, and the different return type when given different parameter types. 3. the stringification method for this function. 4. preparation for function calling and function calling. package unary func init () { } In Golang, init function will be called when a package is initialized. We wrap all ABS() 's functionality inside this init function so we don't need to call it explicitly. 1. function name registration func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name } In MatrixOne, all letters in a function name will be lowercased during the parsing process, so the register function names using only lowercase letters otherwise the function won't be recognized. 2. declare function parameter types and return types. The function abs accepts all numeric types as its parameter (uint8, int8, float32...), we can return a 64bit value covering all different parameter types. To optimize the performance of our function, we can also return different types with respect to the parameter type. Outside the init function, declare these variables for each pair of parameter type and return type. var argAndRets = [] argsAndRet { {[] types . T { types . T_uint8 }, types . T_uint8 }, {[] types . T { types . T_uint16 }, types . T_uint16 }, {[] types . T { types . T_uint32 }, types . T_uint32 }, {[] types . T { types . T_uint64 }, types . T_uint64 }, {[] types . T { types . T_int8 }, types . T_int8 }, {[] types . T { types . T_int16 }, types . T_int16 }, {[] types . T { types . T_int32 }, types . T_int32 }, {[] types . T { types . T_int64 }, types . T_int64 }, {[] types . T { types . T_float32 }, types . T_float32 }, {[] types . T { types . T_float64 }, types . T_float64 }, } func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name } Register parameter types and return types for abs function: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } } Define a stringify function and register abs function type: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } extend . UnaryStrings [ builtin . Abs ] = func ( e extend . Extend ) string { // define a stringify function for abs return fmt . Sprintf ( \"abs(%s)\" , e ) } overload . OpTypes [ builtin . Abs ] = overload . Unary // register abs function type } For simplicity, we demonstrate only two cases where abs function has parameter type float32 and float64. Preparation for function calling: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } extend . UnaryStrings [ builtin . Abs ] = func ( e extend . Extend ) string { // define a stringify function for abs return fmt . Sprintf ( \"abs(%s)\" , e ) } overload . OpTypes [ builtin . Abs ] = overload . Unary // register abs function type overload . UnaryOps [ builtin . Abs ] = [] * overload . UnaryOp { { Typ : types . T_float32 , ReturnType : types . T_float32 , Fn : func ( origVec * vector . Vector , proc * process . Process , _ bool ) ( * vector . Vector , error ) { origVecCol := origVec . Col .([] float32 ) resultVector , err := process . Get ( proc , 4 * int64 ( len ( origVecCol )), types . Type { Oid : types . T_float32 , Size : 4 }) // get a new types.T_float32 vector to store the result vector if err != nil { return nil , err } results := encoding . DecodeFloat32Slice ( resultVector . Data ) results = results [: len ( origVecCol )] resultVector . Col = results nulls . Set ( resultVector . Nsp , origVec . Nsp ) // the new vector's nulls are the same as the original vector vector . SetCol ( resultVector , abs . AbsFloat32 ( origVecCol , results )) // set the vector col with the return value from abs.AbsFloat32 function return resultVector , nil }, }, } } some annotations for this code snippet above: 1.process.Get: MatrixOne assigns each query a \"virtual process\", during the execution of a query, we may need to generate new Vector, allocate memory for it, and we do it using this Get function // proc: the process for this query, size: the memory allocation size we are asking for, type: the new Vector's type. func Get ( proc * Process , size int64 , typ types . Type ) ( * vector . Vector , error ) since we need a float32 vector here, its size should be 4 * len(origVecCol), 4 bytes for each float32. 2.encoding.DecodeFloat32Slice: this is just type casting. 3.Vector.Nsp: MatrixOne uses bitmaps to store the NULL values in a column, Vector.Nsp is a wrap up struct for this bitmap. 4.the boolean parameter of the Fn: this boolean value is usually used to indicate whether the vector passed in is a constant(it has length 1). Sometimes we could make use of this situation for our function implementation, for example, pkg/sql/colexec/extend/overload/plus.go. Since the result vector has the same type as the original vector, we could use the original vector to store our result when we don't need our original vector anymore in our execution plan(i.e., the reference count of the original vector is 0 or 1). To reuse the original vector when possible: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } extend . UnaryStrings [ builtin . Abs ] = func ( e extend . Extend ) string { // define a stringify function for abs return fmt . Sprintf ( \"abs(%s)\" , e ) } overload . OpTypes [ builtin . Abs ] = overload . Unary // register abs function type overload . UnaryOps [ builtin . Abs ] = [] * overload . UnaryOp { { Typ : types . T_float32 , ReturnType : types . T_float32 , Fn : func ( origVec * vector . Vector , proc * process . Process , _ bool ) ( * vector . Vector , error ) { origVecCol := origVec . Col .([] float32 ) if origVec . Ref == 1 || origVec . Ref == 0 { // reuse the original vector when we don't need the original one anymore origVec . Ref = 0 abs . AbsFloat32 ( origVecCol , origVecCol ) return origVec , nil } resultVector , err := process . Get ( proc , 4 * int64 ( len ( origVecCol )), types . Type { Oid : types . T_float32 , Size : 4 }) // get a new types.T_float32 vector to store the result vector if err != nil { return nil , err } results := encoding . DecodeFloat32Slice ( resultVector . Data ) // decode the vector's data to float32 type results = results [: len ( origVecCol )] resultVector . Col = results nulls . Set ( resultVector . Nsp , origVec . Nsp ) // the new vector's nulls are the same as the original vector vector . SetCol ( resultVector , abs . AbsFloat32 ( origVecCol , results )) // set the vector col with the return value from abs.AbsFloat32 function return resultVector , nil }, }, } } For float64 type parameter: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } extend . UnaryStrings [ builtin . Abs ] = func ( e extend . Extend ) string { // define a stringify function for abs return fmt . Sprintf ( \"abs(%s)\" , e ) } overload . OpTypes [ builtin . Abs ] = overload . Unary // register abs function type overload . UnaryOps [ builtin . Abs ] = [] * overload . UnaryOp { { Typ : types . T_float32 , ReturnType : types . T_float32 , Fn : func ( origVec * vector . Vector , proc * process . Process , _ bool ) ( * vector . Vector , error ) { origVecCol := origVec . Col .([] float32 ) if origVec . Ref == 1 || origVec . Ref == 0 { // reuse the original vector when we don't need the original one anymore origVec . Ref = 0 abs . AbsFloat32 ( origVecCol , origVecCol ) return origVec , nil } resultVector , err := process . Get ( proc , 4 * int64 ( len ( origVecCol )), types . Type { Oid : types . T_float32 , Size : 4 }) // get a new types.T_float32 vector to store the result vector if err != nil { return nil , err } results := encoding . DecodeFloat32Slice ( resultVector . Data ) // decode the vector's data to float32 type results = results [: len ( origVecCol )] resultVector . Col = results nulls . Set ( resultVector . Nsp , origVec . Nsp ) // the new vector's nulls are the same as the original vector vector . SetCol ( resultVector , abs . AbsFloat32 ( origVecCol , results )) // set the vector col with the return value from abs.AbsFloat32 function return resultVector , nil }, }, { Typ : types . T_float64 , ReturnType : types . T_float64 , Fn : func ( origVec * vector . Vector , proc * process . Process , _ bool ) ( * vector . Vector , error ) { origVecCol := origVec . Col .([] float64 ) if origVec . Ref == 1 || origVec . Ref == 0 { origVec . Ref = 0 abs . AbsFloat64 ( origVecCol , origVecCol ) return origVec , nil } resultVector , err := process . Get ( proc , 8 * int64 ( len ( origVecCol )), types . Type { Oid : types . T_float64 , Size : 8 }) if err != nil { return nil , err } results := encoding . DecodeFloat64Slice ( resultVector . Data ) results = results [: len ( origVecCol )] resultVector . Col = results nulls . Set ( resultVector . Nsp , origVec . Nsp ) vector . SetCol ( resultVector , abs . AbsFloat64 ( origVecCol , results )) return resultVector , nil }, }, } } Step 2: Implement Abs function In MatrixOne, We put all of our builtin function definition code in the pkg/vectorize/ directory. To implement abs functions, first we need to create a subdirectory abs in this vectorized directory. In this fresh abs directory, create a file abs.go , the place where our abs function implementation code goes. For certain cpu architectures, we could utilize the cpu's intrinsic SIMD instruction to compute the absolute value and hence boost our function's performance, to differentiate function implementations for different cpu architectures, we declare our pure go version of abs function this way: package abs var ( AbsFloat32 func ([] float32 , [] float32 ) [] float32 AbsFloat64 func ([] float64 , [] float64 ) [] float64 ) func init () { AbsFloat32 = absFloat32 AbsFloat64 = absFloat64 } func absFloat32 ( xs , rs [] float32 ) [] float32 { // See below } func absFloat64 ( xs , rs [] float64 ) [] float64 { // See below } Inside the absFloat32 and absFloat64, we implement our golang version of abs function for float32 and float64 type. The other data types (int8, int16, int32, int64) are more or less the same. func absFloat32 ( xs , rs [] float32 ) [] float32 { for i := range xs { if xs [ i ] < 0 { rs [ i ] = - xs [ i ] } else { rs [ i ] = xs [ i ] } } return rs } func absFloat64 ( xs , rs [] float64 ) [] float64 { for i := range xs { if xs [ i ] < 0 { rs [ i ] = - xs [ i ] } else { rs [ i ] = xs [ i ] } } return rs } Here we go. Now we can fire up MatrixOne and take our abs function for a little spin. Compile and run MatrixOne Once the function is ready, we could compile and run MatrixOne to see the function behavior. Step1: Run make config and make build to compile the MatrixOne project and build binary file. make config make build Info make config generates a new configuration file, in this tutorial, you only need to run it once. If you modify some code and want to recompile, you only have to run make build . Step2: Run ./mo-server system_vars_config.toml to launch MatrixOne, the MatrixOne server will start to listen for client connecting. ./mo-server system_vars_config.toml Info The logger print level of system_vars_config.toml is set to default as DEBUG , which will print a lot of information for you. If you only care about what your built-in function will print, you can modify the system_vars_config.toml and set cubeLogLevel and level to ERROR level. cubeLogLevel = \"error\" level = \"error\" Info Sometimes a port is in use error at port 50000 will occur. You could checkout what process in occupying port 50000 by lsof -i:50000 . This command helps you to get the PIDNAME of this process, then you can kill the process by kill -9 PIDNAME . Step3: Connect to MatrixOne server with a MySQL client. Use the built-in test account for example: user: dump password: 111 $ mysql -h 127.0.0.1 -P 6001 -udump -p Enter password: Step4: Test your function behavior with some data. Below is an example. mysql > create table abs_test_table ( a float , b double ); Query OK , 0 rows affected ( 0 . 44 sec ) mysql > insert into abs_test_table values ( 12 . 34 , - 43 . 21 ); Query OK , 1 row affected ( 0 . 08 sec ) mysql > insert into abs_test_table values ( - 12 . 34 , 43 . 21 ); Query OK , 1 row affected ( 0 . 02 sec ) mysql > insert into abs_test_table values ( 2 . 718 , - 3 . 14 ); Query OK , 1 row affected ( 0 . 02 sec ) mysql > select a , b , abs ( a ), abs ( b ) from abs_test_table ; + ----------+----------+---------+---------+ | a | b | abs ( a ) | abs ( b ) | + ----------+----------+---------+---------+ | 12 . 3400 | - 43 . 2100 | 12 . 3400 | 43 . 2100 | | - 12 . 3400 | 43 . 2100 | 12 . 3400 | 43 . 2100 | | 2 . 7180 | - 3 . 1400 | 2 . 7180 | 3 . 1400 | + ----------+----------+---------+---------+ 3 rows in set ( 0 . 01 sec ) Bingo! Info Except for abs() , MatrixOne has already some neat examples for built-in functions, such as floor() , round() , year() . With some minor corresponding changes, the procedure is quite the same as other functions. \u200b Write a unit Test for your function We recommend that you also write a unit test for the new function. Go has a built-in testing command called go test and a package testing which combine to give a minimal but complete testing experience. It automates execution of any function of the form. func TestXxx(*testing.T) To write a new test suite, create a file whose name ends _test.go and contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the go test command is run. Step1: Create a file named abs_test.go under vectorize/abs/ directory. Import the testing framework and the testify framework we are going to use for testing mathematical equal . package abs import ( \"testing\" \"github.com/stretchr/testify/require\" ) function TestAbsFloat32(t *testing.T) { } function TestAbsFloat64(t *testing.T) { } Step2: Implement the TestXxx functions with some predefined values. func TestAbsFloat32(t *testing.T) { //Test values nums := []float32{1.5, -1.5, 2.5, -2.5, 1.2, 12.3, 123.4, 1234.5, 12345.6, 1234.567, -1.2, -12.3, -123.4, -1234.5, -12345.6} //Predefined Correct Values absNums := []float32{1.5, 1.5, 2.5, 2.5, 1.2, 12.3, 123.4, 1234.5, 12345.6, 1234.567, 1.2, 12.3, 123.4, 1234.5, 12345.6} //Init a new variable newNums := make([]float32, len(nums)) //Run abs function newNums = AbsFloat32(nums, newNums) for i := range newNums { require.Equal(t, absNums[i], newNums[i]) } } func TestAbsFloat64(t *testing.T) { //Test values nums := []float64{1.5, -1.5, 2.5, -2.5, 1.2, 12.3, 123.4, 1234.5, 12345.6, 1234.567, -1.2, -12.3, -123.4, -1234.5, -12345.6} //Predefined Correct Values absNums := []float64{1.5, 1.5, 2.5, 2.5, 1.2, 12.3, 123.4, 1234.5, 12345.6, 1234.567, 1.2, 12.3, 123.4, 1234.5, 12345.6} //Init a new variable newNums := make([]float64, len(nums)) //Run abs function newNums = AbsFloat64(nums, newNums) for i := range newNums { require.Equal(t, absNums[i], newNums[i]) } } Step3: Launch Test. Within the same directory as the test: go test This picks up any files matching packagename_test.go. If you are getting a PASS , you are passing the unit test. In MatrixOne, we have a bvt test framework which will run all the unit tests defined in the whole package, and each time your code is merged in the code base, the test will automatically run.","title":"Develop a built-in function"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/#develop-a-built-in-function","text":"","title":"Develop a built-in function"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/#prerequisite","text":"To develop a built-in function for MatrixOne, you need a basic knowledge of Golang programming. You can go through this excellent Golang tutorial to learn some basic Golang concepts.","title":"Prerequisite"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/#preparation","text":"Before you start, please make sure that you have Go installed, cloned the MatrixOne code base. Please refer to Preparation and Contribute Code for more details.","title":"Preparation"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/#what-is-a-built-in-function","text":"There are two types of functions in a database, built-in functions and user-defined functions. Built-in functions are functions that are shipped with the database. In contrast, user-defined functions are customized by the users. Built-in functions can be categorized according to the data types that they operate on i.e. strings, date and numeric built-in functions. An example of a built-in function is abs() , which calculates the absolute (non-negative) value of a given number. Some functions, such as abs() are used to perform calculations. Others such as getdate() are used to obtain a system value, such as the current data, or others, like left() , are used to manipulate textual data. Usually the built-in functions are categorized into major categories: Conversion Functions Logical Functions Math Functions String Functions Date Functions","title":"What is a built-in function?"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/#develop-an-abs-function","text":"In this tutorial, we use the function ABS (get the absolute value) as an example. Step 1: register function MatrixOne doesn't distinguish between operators and functions. In our code repository, the file pkg/builtin/types.go register builtin functions as operators and we assign each operator a distinct integer number. To add a new function abs() , add a new const Abs in the const declaration. const ( Length = iota + overload . NE + 1 Year Round Floor Abs ) In the directory pkg/builtin/unary , create a new go file abs.go . Info The functions under unary directory take only one value as input. The functions under binary directory take only two values as input. Other forms of functions are put under multi directory. This abs.go file has the following functionalities: 1. function name registration 2. declare all the different parameter types this function accepts, and the different return type when given different parameter types. 3. the stringification method for this function. 4. preparation for function calling and function calling. package unary func init () { } In Golang, init function will be called when a package is initialized. We wrap all ABS() 's functionality inside this init function so we don't need to call it explicitly. 1. function name registration func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name } In MatrixOne, all letters in a function name will be lowercased during the parsing process, so the register function names using only lowercase letters otherwise the function won't be recognized. 2. declare function parameter types and return types. The function abs accepts all numeric types as its parameter (uint8, int8, float32...), we can return a 64bit value covering all different parameter types. To optimize the performance of our function, we can also return different types with respect to the parameter type. Outside the init function, declare these variables for each pair of parameter type and return type. var argAndRets = [] argsAndRet { {[] types . T { types . T_uint8 }, types . T_uint8 }, {[] types . T { types . T_uint16 }, types . T_uint16 }, {[] types . T { types . T_uint32 }, types . T_uint32 }, {[] types . T { types . T_uint64 }, types . T_uint64 }, {[] types . T { types . T_int8 }, types . T_int8 }, {[] types . T { types . T_int16 }, types . T_int16 }, {[] types . T { types . T_int32 }, types . T_int32 }, {[] types . T { types . T_int64 }, types . T_int64 }, {[] types . T { types . T_float32 }, types . T_float32 }, {[] types . T { types . T_float64 }, types . T_float64 }, } func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name } Register parameter types and return types for abs function: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } } Define a stringify function and register abs function type: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } extend . UnaryStrings [ builtin . Abs ] = func ( e extend . Extend ) string { // define a stringify function for abs return fmt . Sprintf ( \"abs(%s)\" , e ) } overload . OpTypes [ builtin . Abs ] = overload . Unary // register abs function type } For simplicity, we demonstrate only two cases where abs function has parameter type float32 and float64. Preparation for function calling: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } extend . UnaryStrings [ builtin . Abs ] = func ( e extend . Extend ) string { // define a stringify function for abs return fmt . Sprintf ( \"abs(%s)\" , e ) } overload . OpTypes [ builtin . Abs ] = overload . Unary // register abs function type overload . UnaryOps [ builtin . Abs ] = [] * overload . UnaryOp { { Typ : types . T_float32 , ReturnType : types . T_float32 , Fn : func ( origVec * vector . Vector , proc * process . Process , _ bool ) ( * vector . Vector , error ) { origVecCol := origVec . Col .([] float32 ) resultVector , err := process . Get ( proc , 4 * int64 ( len ( origVecCol )), types . Type { Oid : types . T_float32 , Size : 4 }) // get a new types.T_float32 vector to store the result vector if err != nil { return nil , err } results := encoding . DecodeFloat32Slice ( resultVector . Data ) results = results [: len ( origVecCol )] resultVector . Col = results nulls . Set ( resultVector . Nsp , origVec . Nsp ) // the new vector's nulls are the same as the original vector vector . SetCol ( resultVector , abs . AbsFloat32 ( origVecCol , results )) // set the vector col with the return value from abs.AbsFloat32 function return resultVector , nil }, }, } } some annotations for this code snippet above: 1.process.Get: MatrixOne assigns each query a \"virtual process\", during the execution of a query, we may need to generate new Vector, allocate memory for it, and we do it using this Get function // proc: the process for this query, size: the memory allocation size we are asking for, type: the new Vector's type. func Get ( proc * Process , size int64 , typ types . Type ) ( * vector . Vector , error ) since we need a float32 vector here, its size should be 4 * len(origVecCol), 4 bytes for each float32. 2.encoding.DecodeFloat32Slice: this is just type casting. 3.Vector.Nsp: MatrixOne uses bitmaps to store the NULL values in a column, Vector.Nsp is a wrap up struct for this bitmap. 4.the boolean parameter of the Fn: this boolean value is usually used to indicate whether the vector passed in is a constant(it has length 1). Sometimes we could make use of this situation for our function implementation, for example, pkg/sql/colexec/extend/overload/plus.go. Since the result vector has the same type as the original vector, we could use the original vector to store our result when we don't need our original vector anymore in our execution plan(i.e., the reference count of the original vector is 0 or 1). To reuse the original vector when possible: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } extend . UnaryStrings [ builtin . Abs ] = func ( e extend . Extend ) string { // define a stringify function for abs return fmt . Sprintf ( \"abs(%s)\" , e ) } overload . OpTypes [ builtin . Abs ] = overload . Unary // register abs function type overload . UnaryOps [ builtin . Abs ] = [] * overload . UnaryOp { { Typ : types . T_float32 , ReturnType : types . T_float32 , Fn : func ( origVec * vector . Vector , proc * process . Process , _ bool ) ( * vector . Vector , error ) { origVecCol := origVec . Col .([] float32 ) if origVec . Ref == 1 || origVec . Ref == 0 { // reuse the original vector when we don't need the original one anymore origVec . Ref = 0 abs . AbsFloat32 ( origVecCol , origVecCol ) return origVec , nil } resultVector , err := process . Get ( proc , 4 * int64 ( len ( origVecCol )), types . Type { Oid : types . T_float32 , Size : 4 }) // get a new types.T_float32 vector to store the result vector if err != nil { return nil , err } results := encoding . DecodeFloat32Slice ( resultVector . Data ) // decode the vector's data to float32 type results = results [: len ( origVecCol )] resultVector . Col = results nulls . Set ( resultVector . Nsp , origVec . Nsp ) // the new vector's nulls are the same as the original vector vector . SetCol ( resultVector , abs . AbsFloat32 ( origVecCol , results )) // set the vector col with the return value from abs.AbsFloat32 function return resultVector , nil }, }, } } For float64 type parameter: func init () { extend . FunctionRegistry [ \"abs\" ] = builtin . Abs // register function name for _ , item := range argAndRets { overload . AppendFunctionRets ( builtin . Abs , item . args , item . ret ) // append function parameter types and return types } extend . UnaryReturnTypes [ builtin . Abs ] = func ( extend extend . Extend ) types . T { // define a get return type function for abs function return getUnaryReturnType ( builtin . Abs , extend ) } extend . UnaryStrings [ builtin . Abs ] = func ( e extend . Extend ) string { // define a stringify function for abs return fmt . Sprintf ( \"abs(%s)\" , e ) } overload . OpTypes [ builtin . Abs ] = overload . Unary // register abs function type overload . UnaryOps [ builtin . Abs ] = [] * overload . UnaryOp { { Typ : types . T_float32 , ReturnType : types . T_float32 , Fn : func ( origVec * vector . Vector , proc * process . Process , _ bool ) ( * vector . Vector , error ) { origVecCol := origVec . Col .([] float32 ) if origVec . Ref == 1 || origVec . Ref == 0 { // reuse the original vector when we don't need the original one anymore origVec . Ref = 0 abs . AbsFloat32 ( origVecCol , origVecCol ) return origVec , nil } resultVector , err := process . Get ( proc , 4 * int64 ( len ( origVecCol )), types . Type { Oid : types . T_float32 , Size : 4 }) // get a new types.T_float32 vector to store the result vector if err != nil { return nil , err } results := encoding . DecodeFloat32Slice ( resultVector . Data ) // decode the vector's data to float32 type results = results [: len ( origVecCol )] resultVector . Col = results nulls . Set ( resultVector . Nsp , origVec . Nsp ) // the new vector's nulls are the same as the original vector vector . SetCol ( resultVector , abs . AbsFloat32 ( origVecCol , results )) // set the vector col with the return value from abs.AbsFloat32 function return resultVector , nil }, }, { Typ : types . T_float64 , ReturnType : types . T_float64 , Fn : func ( origVec * vector . Vector , proc * process . Process , _ bool ) ( * vector . Vector , error ) { origVecCol := origVec . Col .([] float64 ) if origVec . Ref == 1 || origVec . Ref == 0 { origVec . Ref = 0 abs . AbsFloat64 ( origVecCol , origVecCol ) return origVec , nil } resultVector , err := process . Get ( proc , 8 * int64 ( len ( origVecCol )), types . Type { Oid : types . T_float64 , Size : 8 }) if err != nil { return nil , err } results := encoding . DecodeFloat64Slice ( resultVector . Data ) results = results [: len ( origVecCol )] resultVector . Col = results nulls . Set ( resultVector . Nsp , origVec . Nsp ) vector . SetCol ( resultVector , abs . AbsFloat64 ( origVecCol , results )) return resultVector , nil }, }, } } Step 2: Implement Abs function In MatrixOne, We put all of our builtin function definition code in the pkg/vectorize/ directory. To implement abs functions, first we need to create a subdirectory abs in this vectorized directory. In this fresh abs directory, create a file abs.go , the place where our abs function implementation code goes. For certain cpu architectures, we could utilize the cpu's intrinsic SIMD instruction to compute the absolute value and hence boost our function's performance, to differentiate function implementations for different cpu architectures, we declare our pure go version of abs function this way: package abs var ( AbsFloat32 func ([] float32 , [] float32 ) [] float32 AbsFloat64 func ([] float64 , [] float64 ) [] float64 ) func init () { AbsFloat32 = absFloat32 AbsFloat64 = absFloat64 } func absFloat32 ( xs , rs [] float32 ) [] float32 { // See below } func absFloat64 ( xs , rs [] float64 ) [] float64 { // See below } Inside the absFloat32 and absFloat64, we implement our golang version of abs function for float32 and float64 type. The other data types (int8, int16, int32, int64) are more or less the same. func absFloat32 ( xs , rs [] float32 ) [] float32 { for i := range xs { if xs [ i ] < 0 { rs [ i ] = - xs [ i ] } else { rs [ i ] = xs [ i ] } } return rs } func absFloat64 ( xs , rs [] float64 ) [] float64 { for i := range xs { if xs [ i ] < 0 { rs [ i ] = - xs [ i ] } else { rs [ i ] = xs [ i ] } } return rs } Here we go. Now we can fire up MatrixOne and take our abs function for a little spin.","title":"Develop an abs() function:"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/#compile-and-run-matrixone","text":"Once the function is ready, we could compile and run MatrixOne to see the function behavior. Step1: Run make config and make build to compile the MatrixOne project and build binary file. make config make build Info make config generates a new configuration file, in this tutorial, you only need to run it once. If you modify some code and want to recompile, you only have to run make build . Step2: Run ./mo-server system_vars_config.toml to launch MatrixOne, the MatrixOne server will start to listen for client connecting. ./mo-server system_vars_config.toml Info The logger print level of system_vars_config.toml is set to default as DEBUG , which will print a lot of information for you. If you only care about what your built-in function will print, you can modify the system_vars_config.toml and set cubeLogLevel and level to ERROR level. cubeLogLevel = \"error\" level = \"error\" Info Sometimes a port is in use error at port 50000 will occur. You could checkout what process in occupying port 50000 by lsof -i:50000 . This command helps you to get the PIDNAME of this process, then you can kill the process by kill -9 PIDNAME . Step3: Connect to MatrixOne server with a MySQL client. Use the built-in test account for example: user: dump password: 111 $ mysql -h 127.0.0.1 -P 6001 -udump -p Enter password: Step4: Test your function behavior with some data. Below is an example. mysql > create table abs_test_table ( a float , b double ); Query OK , 0 rows affected ( 0 . 44 sec ) mysql > insert into abs_test_table values ( 12 . 34 , - 43 . 21 ); Query OK , 1 row affected ( 0 . 08 sec ) mysql > insert into abs_test_table values ( - 12 . 34 , 43 . 21 ); Query OK , 1 row affected ( 0 . 02 sec ) mysql > insert into abs_test_table values ( 2 . 718 , - 3 . 14 ); Query OK , 1 row affected ( 0 . 02 sec ) mysql > select a , b , abs ( a ), abs ( b ) from abs_test_table ; + ----------+----------+---------+---------+ | a | b | abs ( a ) | abs ( b ) | + ----------+----------+---------+---------+ | 12 . 3400 | - 43 . 2100 | 12 . 3400 | 43 . 2100 | | - 12 . 3400 | 43 . 2100 | 12 . 3400 | 43 . 2100 | | 2 . 7180 | - 3 . 1400 | 2 . 7180 | 3 . 1400 | + ----------+----------+---------+---------+ 3 rows in set ( 0 . 01 sec ) Bingo! Info Except for abs() , MatrixOne has already some neat examples for built-in functions, such as floor() , round() , year() . With some minor corresponding changes, the procedure is quite the same as other functions. \u200b","title":"Compile and run MatrixOne"},{"location":"MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/#write-a-unit-test-for-your-function","text":"We recommend that you also write a unit test for the new function. Go has a built-in testing command called go test and a package testing which combine to give a minimal but complete testing experience. It automates execution of any function of the form. func TestXxx(*testing.T) To write a new test suite, create a file whose name ends _test.go and contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the go test command is run. Step1: Create a file named abs_test.go under vectorize/abs/ directory. Import the testing framework and the testify framework we are going to use for testing mathematical equal . package abs import ( \"testing\" \"github.com/stretchr/testify/require\" ) function TestAbsFloat32(t *testing.T) { } function TestAbsFloat64(t *testing.T) { } Step2: Implement the TestXxx functions with some predefined values. func TestAbsFloat32(t *testing.T) { //Test values nums := []float32{1.5, -1.5, 2.5, -2.5, 1.2, 12.3, 123.4, 1234.5, 12345.6, 1234.567, -1.2, -12.3, -123.4, -1234.5, -12345.6} //Predefined Correct Values absNums := []float32{1.5, 1.5, 2.5, 2.5, 1.2, 12.3, 123.4, 1234.5, 12345.6, 1234.567, 1.2, 12.3, 123.4, 1234.5, 12345.6} //Init a new variable newNums := make([]float32, len(nums)) //Run abs function newNums = AbsFloat32(nums, newNums) for i := range newNums { require.Equal(t, absNums[i], newNums[i]) } } func TestAbsFloat64(t *testing.T) { //Test values nums := []float64{1.5, -1.5, 2.5, -2.5, 1.2, 12.3, 123.4, 1234.5, 12345.6, 1234.567, -1.2, -12.3, -123.4, -1234.5, -12345.6} //Predefined Correct Values absNums := []float64{1.5, 1.5, 2.5, 2.5, 1.2, 12.3, 123.4, 1234.5, 12345.6, 1234.567, 1.2, 12.3, 123.4, 1234.5, 12345.6} //Init a new variable newNums := make([]float64, len(nums)) //Run abs function newNums = AbsFloat64(nums, newNums) for i := range newNums { require.Equal(t, absNums[i], newNums[i]) } } Step3: Launch Test. Within the same directory as the test: go test This picks up any files matching packagename_test.go. If you are getting a PASS , you are passing the unit test. In MatrixOne, we have a bvt test framework which will run all the unit tests defined in the whole package, and each time your code is merged in the code base, the test will automatically run.","title":"Write a unit Test for your function"},{"location":"MatrixOne/Develop/develop_python_application/","text":"Build a simple stock analysis Python App with MatrixOne This tutorial shows you how to build a simple Python application with MatrixOne. About the demo This demo will store the historical stock data of the China stock market and make a simple analysis to find the best stocks to buy. The basic idea is that we track the P/E (Price-to-Earnings) and P/B (Price-to-Book) level of each stock since these can represent a company's market capitalization. If you are not familiar with these two concepts, please refer to P/E and P/B . Every day after the market closes, we compare the P/E and P/B value with the historical lowest P/E and P/B. If the current P/E or P/B is even lower than the historical lowest, the stock is very likely under-estimated. We can further investigate its reason of falling and judge if it's a good time to buy it. Before you start Before you start, you need to have a Tushare account and get an API token. If you haven't signed up for Tushare, you can sign up for it at https://tushare.pro/ and you can find your API token at https://tushare.pro/user/token# . Info Tushare is an open source utility for crawling historical data of China stocks. It has a complete dataset, but pay attention to their rules of API access limit and frequency. Besides the data source account, you need to at least have these two basic software installed: Python 3.x MatrixOne You may refer to Python 3 installation tutorial and MatrixOne installation for more details. Moreover, we need to install dependant Tushare and pymysql python libraries to use Tushare and access MatrixOne. pip3 install -r requirements.txt Info Pymysql is the only ORM tool supported by MatrixOne. The other python MySQL ORM tools as SQLAlchemy , mysql-connector , MySQLdb are not supported yet. Step1: prepare and load historical dataset First, we need to load the historical stock data in MatrixOne. As Tushare interface only allows a fetch of 5000 rows of data at once, we only have to collect the latest 5000 trade days data for each stock. Each year there are roughly 250 trade dates. 5000 makes almost 20 years of data, which largely satisfies our demo. The below code will set up tushare interface and get the list of stocks. import tushare as ts import time # Set Tushare data source ts . set_token ( 'YOUR_TUSHARE_API_TOKEN' ) pro = ts . pro_api () # Get the list of stocks pool = pro . stock_basic ( exchange = '' , list_status = 'L' , adj = 'qfq' , fields = 'ts_code,symbol,name,area,industry,fullname,list_date, market,exchange,is_hs' ) As we only need the P/E and P/B information, we call the daily_basic method and get each stock with data frames with ts_code , trade_date , pe and pb fields. Without any specification of start date and end date, Tushare will automatically output 5000 lastest records. j = 1 for i in pool . ts_code : print ( 'Getting %d stock\uff0cStock Code %s .' % ( j , i )) #The interface is limited to be queried 200 times/minute, some little delays are necessary time . sleep ( 0.301 ) j += 1 #Get stock P/E and P/B data frames df = pro . daily_basic ( ** { \"ts_code\" : i , \"trade_date\" : \"\" , \"start_date\" : \"\" , \"end_date\" : \"\" , \"limit\" : \"\" , \"offset\" : \"\" }, fields = [ \"ts_code\" , \"trade_date\" , \"pe\" , \"pb\" ]) With the data ready, we need to load them into MatrixOne. We use pymysql as the python-MatrixOne connector to run SQLs in MatrixOne. Prior to the below code, the MatrixOne server must be launched and a database called stock needs to be created first. MatrixOne: mysql > CREATE DATABASE stock . Python: import pymysql # Open a MatrixOne connection db = pymysql.connect(host='127.0.0.1', port=6001, user='dump', password='111', database='stock') # Create a cursor object cursor = db.cursor() # Create PE table cursor.execute('CREATE TABLE IF NOT EXISTS pe(ts_code VARCHAR(255), trade_date VARCHAR(255), pe FLOAT, pb FLOAT)') Load each 5000 records of data into MatrixOne: if df . empty == False : # Fill P/E and P/B values which are NaN df = df . fillna ( 0.0 ) val_to_insert = df . values . tolist () cursor . executemany ( \" insert into pe (ts_code, trade_date,pe,pb) values ( %s , %s , %s , %s )\" , val_to_insert ) Step2: find the historical lowest P/E or P/B stock After we load the historical stock data into MatrixOne, we have about 11 millions records. mysql > select count ( * ) from pe ; + ----------+ | count ( * ) | + ----------+ | 11233508 | + ----------+ 1 row in set ( 0 . 16 sec ) Now we run a sql to calculate the lowest P/E and P/B of each stock. # Find stocks that the current P/E is even lower than the historical lowest cursor . execute ( 'select ts_code,min(pe) from pe where pe>0 group by ts_code order by ts_code' ) # Fetch the result as python object value = cursor . fetchall () # Find stocks that the current P/B is even lower than the historical lowest cursor . execute ( 'select ts_code,min(pb) from pe where pb>0 group by ts_code order by ts_code' ) # Fetch the result as python object value = cursor . fetchall () Then we call Tushare daily_basic interface again to get the current P/E and P/B level and make a search to locate the stock whose current P/E or P/B is even lower than the historical lowest. You could of course switch any trade date you want for comparison. We take P/E as an example. df = pro . daily_basic ( ** { \"ts_code\" : \"\" , \"trade_date\" : sys . argv [ 1 ], \"start_date\" : \"\" , \"end_date\" : \"\" , \"limit\" : \"\" , \"offset\" : \"\" }, fields = [ \"ts_code\" , \"pe\" ]) df = df . fillna ( 0.0 ) for i in range ( 0 , len ( value )): ts_code , min_pe = value [ i ] for j in range ( 0 , len ( df . ts_code )): if ts_code == df . ts_code [ j ] and min_pe > df . pe [ j ] > 0 : logging . getLogger () . info ( \"ts_code: %s \" , ts_code ) logging . getLogger () . info ( \"history lowest PE : %f \" , min_pe ) logging . getLogger () . info ( \"current PE found: %f \" , df . pe [ j ]) This will print every stock with the lowest ever P/E or P/B. They are usually good choices to buy if they are not experiencing big trouble. Step3: Update our dataset We already have a lot of historical data stored in MatrixOne, each time we run a n analysis, we usually have been through a new trading day. The dataset need to be updated with the latest data, otherwise next time you will still compare yourself with the old data. We don't need to insert all data again, we just insert the data with the lastest trading dates. # get updating trading dates by user argument inputs df = pro . daily_basic ( ** { \"ts_code\" : i , \"trade_date\" : \"\" , \"start_date\" : self . startDate ,, \"end_date\" : self . endDate , \"limit\" : \"\" , \"offset\" : \"\" }, fields = [ \"ts_code\" , \"trade_date\" , \"pe\" , \"pb\" ]) # append update to MatrixOne if df . empty == False : df = df . fillna ( 0.0 ) val_to_insert = df . values . tolist () print ( val_to_insert ) cursor . executemany ( \" insert into pe (ts_code, trade_date,pe,pb) values ( %s , %s , %s , %s )\" , val_to_insert ) Source Code You can find the source code of this demo at matrix_one_app .","title":"Develop Python Applications"},{"location":"MatrixOne/Develop/develop_python_application/#build-a-simple-stock-analysis-python-app-with-matrixone","text":"This tutorial shows you how to build a simple Python application with MatrixOne.","title":"Build a simple stock analysis Python App with MatrixOne"},{"location":"MatrixOne/Develop/develop_python_application/#about-the-demo","text":"This demo will store the historical stock data of the China stock market and make a simple analysis to find the best stocks to buy. The basic idea is that we track the P/E (Price-to-Earnings) and P/B (Price-to-Book) level of each stock since these can represent a company's market capitalization. If you are not familiar with these two concepts, please refer to P/E and P/B . Every day after the market closes, we compare the P/E and P/B value with the historical lowest P/E and P/B. If the current P/E or P/B is even lower than the historical lowest, the stock is very likely under-estimated. We can further investigate its reason of falling and judge if it's a good time to buy it.","title":"About the demo"},{"location":"MatrixOne/Develop/develop_python_application/#before-you-start","text":"Before you start, you need to have a Tushare account and get an API token. If you haven't signed up for Tushare, you can sign up for it at https://tushare.pro/ and you can find your API token at https://tushare.pro/user/token# . Info Tushare is an open source utility for crawling historical data of China stocks. It has a complete dataset, but pay attention to their rules of API access limit and frequency. Besides the data source account, you need to at least have these two basic software installed: Python 3.x MatrixOne You may refer to Python 3 installation tutorial and MatrixOne installation for more details. Moreover, we need to install dependant Tushare and pymysql python libraries to use Tushare and access MatrixOne. pip3 install -r requirements.txt Info Pymysql is the only ORM tool supported by MatrixOne. The other python MySQL ORM tools as SQLAlchemy , mysql-connector , MySQLdb are not supported yet.","title":"Before you start"},{"location":"MatrixOne/Develop/develop_python_application/#step1-prepare-and-load-historical-dataset","text":"First, we need to load the historical stock data in MatrixOne. As Tushare interface only allows a fetch of 5000 rows of data at once, we only have to collect the latest 5000 trade days data for each stock. Each year there are roughly 250 trade dates. 5000 makes almost 20 years of data, which largely satisfies our demo. The below code will set up tushare interface and get the list of stocks. import tushare as ts import time # Set Tushare data source ts . set_token ( 'YOUR_TUSHARE_API_TOKEN' ) pro = ts . pro_api () # Get the list of stocks pool = pro . stock_basic ( exchange = '' , list_status = 'L' , adj = 'qfq' , fields = 'ts_code,symbol,name,area,industry,fullname,list_date, market,exchange,is_hs' ) As we only need the P/E and P/B information, we call the daily_basic method and get each stock with data frames with ts_code , trade_date , pe and pb fields. Without any specification of start date and end date, Tushare will automatically output 5000 lastest records. j = 1 for i in pool . ts_code : print ( 'Getting %d stock\uff0cStock Code %s .' % ( j , i )) #The interface is limited to be queried 200 times/minute, some little delays are necessary time . sleep ( 0.301 ) j += 1 #Get stock P/E and P/B data frames df = pro . daily_basic ( ** { \"ts_code\" : i , \"trade_date\" : \"\" , \"start_date\" : \"\" , \"end_date\" : \"\" , \"limit\" : \"\" , \"offset\" : \"\" }, fields = [ \"ts_code\" , \"trade_date\" , \"pe\" , \"pb\" ]) With the data ready, we need to load them into MatrixOne. We use pymysql as the python-MatrixOne connector to run SQLs in MatrixOne. Prior to the below code, the MatrixOne server must be launched and a database called stock needs to be created first. MatrixOne: mysql > CREATE DATABASE stock . Python: import pymysql # Open a MatrixOne connection db = pymysql.connect(host='127.0.0.1', port=6001, user='dump', password='111', database='stock') # Create a cursor object cursor = db.cursor() # Create PE table cursor.execute('CREATE TABLE IF NOT EXISTS pe(ts_code VARCHAR(255), trade_date VARCHAR(255), pe FLOAT, pb FLOAT)') Load each 5000 records of data into MatrixOne: if df . empty == False : # Fill P/E and P/B values which are NaN df = df . fillna ( 0.0 ) val_to_insert = df . values . tolist () cursor . executemany ( \" insert into pe (ts_code, trade_date,pe,pb) values ( %s , %s , %s , %s )\" , val_to_insert )","title":"Step1: prepare and load historical dataset"},{"location":"MatrixOne/Develop/develop_python_application/#step2-find-the-historical-lowest-pe-or-pb-stock","text":"After we load the historical stock data into MatrixOne, we have about 11 millions records. mysql > select count ( * ) from pe ; + ----------+ | count ( * ) | + ----------+ | 11233508 | + ----------+ 1 row in set ( 0 . 16 sec ) Now we run a sql to calculate the lowest P/E and P/B of each stock. # Find stocks that the current P/E is even lower than the historical lowest cursor . execute ( 'select ts_code,min(pe) from pe where pe>0 group by ts_code order by ts_code' ) # Fetch the result as python object value = cursor . fetchall () # Find stocks that the current P/B is even lower than the historical lowest cursor . execute ( 'select ts_code,min(pb) from pe where pb>0 group by ts_code order by ts_code' ) # Fetch the result as python object value = cursor . fetchall () Then we call Tushare daily_basic interface again to get the current P/E and P/B level and make a search to locate the stock whose current P/E or P/B is even lower than the historical lowest. You could of course switch any trade date you want for comparison. We take P/E as an example. df = pro . daily_basic ( ** { \"ts_code\" : \"\" , \"trade_date\" : sys . argv [ 1 ], \"start_date\" : \"\" , \"end_date\" : \"\" , \"limit\" : \"\" , \"offset\" : \"\" }, fields = [ \"ts_code\" , \"pe\" ]) df = df . fillna ( 0.0 ) for i in range ( 0 , len ( value )): ts_code , min_pe = value [ i ] for j in range ( 0 , len ( df . ts_code )): if ts_code == df . ts_code [ j ] and min_pe > df . pe [ j ] > 0 : logging . getLogger () . info ( \"ts_code: %s \" , ts_code ) logging . getLogger () . info ( \"history lowest PE : %f \" , min_pe ) logging . getLogger () . info ( \"current PE found: %f \" , df . pe [ j ]) This will print every stock with the lowest ever P/E or P/B. They are usually good choices to buy if they are not experiencing big trouble.","title":"Step2: find the historical lowest P/E or P/B stock"},{"location":"MatrixOne/Develop/develop_python_application/#step3-update-our-dataset","text":"We already have a lot of historical data stored in MatrixOne, each time we run a n analysis, we usually have been through a new trading day. The dataset need to be updated with the latest data, otherwise next time you will still compare yourself with the old data. We don't need to insert all data again, we just insert the data with the lastest trading dates. # get updating trading dates by user argument inputs df = pro . daily_basic ( ** { \"ts_code\" : i , \"trade_date\" : \"\" , \"start_date\" : self . startDate ,, \"end_date\" : self . endDate , \"limit\" : \"\" , \"offset\" : \"\" }, fields = [ \"ts_code\" , \"trade_date\" , \"pe\" , \"pb\" ]) # append update to MatrixOne if df . empty == False : df = df . fillna ( 0.0 ) val_to_insert = df . values . tolist () print ( val_to_insert ) cursor . executemany ( \" insert into pe (ts_code, trade_date,pe,pb) values ( %s , %s , %s , %s )\" , val_to_insert )","title":"Step3: Update our dataset"},{"location":"MatrixOne/Develop/develop_python_application/#source-code","text":"You can find the source code of this demo at matrix_one_app .","title":"Source Code"},{"location":"MatrixOne/FAQs/general-faqs/","text":"General FAQs Product FAQs What is MatrixOne? MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine, across multiple datacenters, clouds, edges and other heterogenous infrastructures. The all-in-one architecture of MatrixOne will significantly simplify database management and maintenance, creating a single database that can serve multiple data applications. For information about MatrixOne, you can see MatrixOne Introduction . Where can I apply MatrxOne? MatrixOne provides users with HTAP services to support hybrid workloads. It can be used to build data warehouse or data platforms. Is MatrixOne based on MySQL or some other database? MatrixOne is a completely redesigned database. It's compatible with part of MySQL syntax and semantics. We are currently working to support more database semantics such as PostgreSQL, Hive, Clickhouse, since we intend to develop MatrixOne as a hyperconverged database. To learn more about the compatibility with MySQL, you can visit MySQL-Compatibility . What's the relationship between MatrixOne and MatrixCube? MatrixOne is the main database project, including a query parser layer, compute layer, and storage layer. It can also work as a standalone database system. MatrixCube is a independant library who doesn't work alone, it's a distributed system framework. It gives MatrixOne the ability to extend as a distributed database. It also supports to be mounted with other storage engines. For information about MatrixCube, you can see MatrixCube Introduction . Why MatrixOne is so fast? MatrixOne achieves accelerated queries using patented vectorized execution as well as optimal computation push down strategies through factorization techniques. Which programming language is MatrixOne developed with ? Currently, the primary programming language used for our programming is Golang . What operating system does MatrixOne support? MatrixOne supports Linux and MacOS. Which MatrixOne data types are supported? You can see data tpyes in MatrixOne to learn more about the data types we support. Can I contribute to MatrixOne? Yes, MatrixOne is an open-source project developed on GitHub. Contribution instructions are published in Contribution Guide . We welcome developers to contribute to the MatrixOne community. Deployment FAQs Are there any hardware requirements for deploying MatrixOne? Standalone setting specification: x86 CPU with 4 cores and 32GB memory, with CentOS 7+ Operating System. Distributed setting specification: 3 servers, each one with x86 CPU with 16 cores and 64GB memory, with CentOS 7+ Operating System. SQL FAQs Whether functions and other keywords are case sensitive\uff1f No, they are not case sensitive. How do I export data from MatrixOne to a file? You can use SELECT INTO OUTFILE command to export data from MatrixOne to a csv file (only to the server host, not to the remote client). For this command, you can see SELECT Reference .","title":"General FAQs"},{"location":"MatrixOne/FAQs/general-faqs/#general-faqs","text":"","title":"General FAQs"},{"location":"MatrixOne/FAQs/general-faqs/#product-faqs","text":"What is MatrixOne? MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine, across multiple datacenters, clouds, edges and other heterogenous infrastructures. The all-in-one architecture of MatrixOne will significantly simplify database management and maintenance, creating a single database that can serve multiple data applications. For information about MatrixOne, you can see MatrixOne Introduction . Where can I apply MatrxOne? MatrixOne provides users with HTAP services to support hybrid workloads. It can be used to build data warehouse or data platforms. Is MatrixOne based on MySQL or some other database? MatrixOne is a completely redesigned database. It's compatible with part of MySQL syntax and semantics. We are currently working to support more database semantics such as PostgreSQL, Hive, Clickhouse, since we intend to develop MatrixOne as a hyperconverged database. To learn more about the compatibility with MySQL, you can visit MySQL-Compatibility . What's the relationship between MatrixOne and MatrixCube? MatrixOne is the main database project, including a query parser layer, compute layer, and storage layer. It can also work as a standalone database system. MatrixCube is a independant library who doesn't work alone, it's a distributed system framework. It gives MatrixOne the ability to extend as a distributed database. It also supports to be mounted with other storage engines. For information about MatrixCube, you can see MatrixCube Introduction . Why MatrixOne is so fast? MatrixOne achieves accelerated queries using patented vectorized execution as well as optimal computation push down strategies through factorization techniques. Which programming language is MatrixOne developed with ? Currently, the primary programming language used for our programming is Golang . What operating system does MatrixOne support? MatrixOne supports Linux and MacOS. Which MatrixOne data types are supported? You can see data tpyes in MatrixOne to learn more about the data types we support. Can I contribute to MatrixOne? Yes, MatrixOne is an open-source project developed on GitHub. Contribution instructions are published in Contribution Guide . We welcome developers to contribute to the MatrixOne community.","title":"Product FAQs"},{"location":"MatrixOne/FAQs/general-faqs/#deployment-faqs","text":"Are there any hardware requirements for deploying MatrixOne? Standalone setting specification: x86 CPU with 4 cores and 32GB memory, with CentOS 7+ Operating System. Distributed setting specification: 3 servers, each one with x86 CPU with 16 cores and 64GB memory, with CentOS 7+ Operating System.","title":"Deployment FAQs"},{"location":"MatrixOne/FAQs/general-faqs/#sql-faqs","text":"Whether functions and other keywords are case sensitive\uff1f No, they are not case sensitive. How do I export data from MatrixOne to a file? You can use SELECT INTO OUTFILE command to export data from MatrixOne to a csv file (only to the server host, not to the remote client). For this command, you can see SELECT Reference .","title":"SQL FAQs"},{"location":"MatrixOne/Get-Started/Playground/","text":"Playground MatrixOne Playground allows you to try SQL statements and explore features of MatrixOne instantly from your web browser with interactive tutorials. For docs about our SQL commands, you can see SQL Reference . For tutorials about SSB test, you can see Tutorial . Limitations You can only operate in read-only mode in MatixOrigin Playground\uff0cso DDL commands and part of DML commands which may change the data are not available. The detail limitations are shown below: DDL commands are not available: create/drop table , truncate , update , set , use Part of DML commands are not available\uff1a insert , replace , delete , select into commit is not available call is not available max_result_rows =2000 Examples In Playground, You can follow different interactive tutorials and pick one in the list box, and now the supported tutorials are shown below: SSB Test with MatrixOne We will use SSB Test as an example to show you the overall operation process of Playground. Test Preperations This tutorial walks you through the most popular Star Schema Benchmark\uff08SSB\uff09 Test SQL statements with MatrixOne. To better experience MatrixOne's features and performance, test queries in this tutorial will run without filters. Before you start, the test datasets have been pre-loaded in database ssb . To list available tables in the database you can query : SHOW TABLES\uff1b Tips You can click on the command to copy and Run it in the terminal on the right. The query results are displayed in the lower right. Then you can run the queries on SSB datasets, click Continue . Run Query Command Now, You can query the table with SQL commands we provide. For example: Run Q1.1 query select sum(lo_revenue) as revenue from lineorder join dates on lo_orderdate = d_datekey\uff1b And you can use join in queries: Run Q1.2 query select sum(lo_revenue) as revenue from lineorder join dates on lo_orderdate = d_datekey\uff1b Additionally, group by and order by can be used: Run Q2.1 query select sum(lo_revenue) as lo_revenue, d_year, p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey group by d_year, p_brand order by d_year, p_brand; More query commands are provided in Playground , you can test on your own. Learn More This page describes the features, limitations, and examples of Playground. For information on other options that are available when trying out MatrixOne, see the following: Install MatrixOne What\u2018s New","title":"Playground"},{"location":"MatrixOne/Get-Started/Playground/#playground","text":"MatrixOne Playground allows you to try SQL statements and explore features of MatrixOne instantly from your web browser with interactive tutorials. For docs about our SQL commands, you can see SQL Reference . For tutorials about SSB test, you can see Tutorial .","title":"Playground"},{"location":"MatrixOne/Get-Started/Playground/#limitations","text":"You can only operate in read-only mode in MatixOrigin Playground\uff0cso DDL commands and part of DML commands which may change the data are not available. The detail limitations are shown below: DDL commands are not available: create/drop table , truncate , update , set , use Part of DML commands are not available\uff1a insert , replace , delete , select into commit is not available call is not available max_result_rows =2000","title":"Limitations"},{"location":"MatrixOne/Get-Started/Playground/#examples","text":"In Playground, You can follow different interactive tutorials and pick one in the list box, and now the supported tutorials are shown below: SSB Test with MatrixOne We will use SSB Test as an example to show you the overall operation process of Playground.","title":"Examples"},{"location":"MatrixOne/Get-Started/Playground/#test-preperations","text":"This tutorial walks you through the most popular Star Schema Benchmark\uff08SSB\uff09 Test SQL statements with MatrixOne. To better experience MatrixOne's features and performance, test queries in this tutorial will run without filters. Before you start, the test datasets have been pre-loaded in database ssb . To list available tables in the database you can query : SHOW TABLES\uff1b Tips You can click on the command to copy and Run it in the terminal on the right. The query results are displayed in the lower right. Then you can run the queries on SSB datasets, click Continue .","title":"Test Preperations"},{"location":"MatrixOne/Get-Started/Playground/#run-query-command","text":"Now, You can query the table with SQL commands we provide. For example: Run Q1.1 query select sum(lo_revenue) as revenue from lineorder join dates on lo_orderdate = d_datekey\uff1b And you can use join in queries: Run Q1.2 query select sum(lo_revenue) as revenue from lineorder join dates on lo_orderdate = d_datekey\uff1b Additionally, group by and order by can be used: Run Q2.1 query select sum(lo_revenue) as lo_revenue, d_year, p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey group by d_year, p_brand order by d_year, p_brand; More query commands are provided in Playground , you can test on your own.","title":"Run Query Command"},{"location":"MatrixOne/Get-Started/Playground/#learn-more","text":"This page describes the features, limitations, and examples of Playground. For information on other options that are available when trying out MatrixOne, see the following: Install MatrixOne What\u2018s New","title":"Learn More"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/","text":"Connect to MatrixOne Server Before you begin Make sure you have already installed MatrixOne . 1. Install MySQL client MatrixOne supports the MySQL wire protocol, so you can use MySQL client drivers to connect from various languages. Currently, MatrixOne is only compatible with Oracle MySQL client. This means that some features might not work with MariaDB client or Percona client. 2. Connect to MatrixOne server You can use the MySQL command-line client to connect to MatrixOne server: $ mysql -h IP -P PORT -uUsername -p The connection string is the same format as MySQL accepts. You need to provide a user name and a password. Use the built-in test account for example: user: dump password: 111 $ mysql -h 127.0.0.1 -P 6001 -udump -p Enter password: Currently, MatrixOne only supports the TCP listener.","title":"Connect to MatrixOne Server"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/#connect-to-matrixone-server","text":"","title":"Connect to MatrixOne Server"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/#before-you-begin","text":"Make sure you have already installed MatrixOne .","title":"Before you begin"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/#1-install-mysql-client","text":"MatrixOne supports the MySQL wire protocol, so you can use MySQL client drivers to connect from various languages. Currently, MatrixOne is only compatible with Oracle MySQL client. This means that some features might not work with MariaDB client or Percona client.","title":"1. Install MySQL client"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/#2-connect-to-matrixone-server","text":"You can use the MySQL command-line client to connect to MatrixOne server: $ mysql -h IP -P PORT -uUsername -p The connection string is the same format as MySQL accepts. You need to provide a user name and a password. Use the built-in test account for example: user: dump password: 111 $ mysql -h 127.0.0.1 -P 6001 -udump -p Enter password: Currently, MatrixOne only supports the TCP listener.","title":"2. Connect to MatrixOne server"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/","text":"Install distributed MatrixOne MatrixOne supports distributed deloyment. At least 3 stores (same as Nodes) are required for the distributed setting. Two Types of Stores There are two types of stores in a MatrixOne cluster: prophet stores and pure storage stores. The first three stores are prophet stores. The others are pure storage stores. For example, if there're three stores in the cluster, all the stores are prophet stores. If there are five nodes in the cluster, three are prophet stores, and two are pure storage stores. Installation This tutorial is an example of 5 stores installation. Step1 Prepare 3 servers as prophet stores (recommended specification: x86 CPU with 16 cores and 64GB memory, with CentOS 7+ OS). Each store must install a MatrixOne as standalone version. Installation steps are the same as the standalone . Step2 Set up store1, which is also called the Prophet Genesis Store . Set id of the Prophet Genesis Store: nodeID = 1 Set addr-raft and addr-client to receive Raft protocol and Shard Proxy messages from other MatrixCube stores: addr-raft = \"your_ip_address:10000\" addr-client = \"your_ip_address:20000\" Set the size limit of a Shard : shard-capacity-bytes = \"4096MB\" Set rpc-addr to receive heartbeats from the whole cluster: rpc-addr = \"your_ip_address:30000\" Set join , client-urls and peer-urls to group into a Etcd-server cluster. As the Prophet Genesis Store is the first store, the join parameter can remain empty: join = \"\" client-urls = \"your_ip_address:40000\" peer-urls = \"your_ip_address:50000\" Set prophet-node to TRUE, as the prophet store will hold the cluster metadata: prophet-node = true Set max-replicas number to the replica numbers that you want, it can only be 2*N+1 numbers: max-replicas = 3 Step3 Set up store2 and store3 as prophet stores. Repeat the same procedure of step1 and step2 for each store. The only two differences are setting a unique nodeID and a join ip address. nodeID = 2 or 3; join = \"ip_address_of_store1\" Step4 Set up the other two stores as pure storage store. Repeat the same procedure of step1 and step2 for each store. There are three more parameters to be set: Set a unique number for nodeID. Set prophet-node to TRUE. Fill the three empty string with the three client-urls of the three prophet node for the external-etcd parameter. nodeID = 4/5; prophet-node = false; prophet-node = [\"ip_address_of_prophet_store1\",\"ip_address_of_prophet_store2\",\"ip_address_of_prophet_store3\"] To learn more about our distribute system parameters, please refer to distributed settings .","title":"Install Distributed MatrixOne"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#install-distributed-matrixone","text":"MatrixOne supports distributed deloyment. At least 3 stores (same as Nodes) are required for the distributed setting.","title":"Install distributed MatrixOne"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#two-types-of-stores","text":"There are two types of stores in a MatrixOne cluster: prophet stores and pure storage stores. The first three stores are prophet stores. The others are pure storage stores. For example, if there're three stores in the cluster, all the stores are prophet stores. If there are five nodes in the cluster, three are prophet stores, and two are pure storage stores.","title":"Two Types of Stores"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#installation","text":"This tutorial is an example of 5 stores installation.","title":"Installation"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#step1","text":"Prepare 3 servers as prophet stores (recommended specification: x86 CPU with 16 cores and 64GB memory, with CentOS 7+ OS). Each store must install a MatrixOne as standalone version. Installation steps are the same as the standalone .","title":"Step1"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#step2","text":"Set up store1, which is also called the Prophet Genesis Store . Set id of the Prophet Genesis Store: nodeID = 1 Set addr-raft and addr-client to receive Raft protocol and Shard Proxy messages from other MatrixCube stores: addr-raft = \"your_ip_address:10000\" addr-client = \"your_ip_address:20000\" Set the size limit of a Shard : shard-capacity-bytes = \"4096MB\" Set rpc-addr to receive heartbeats from the whole cluster: rpc-addr = \"your_ip_address:30000\" Set join , client-urls and peer-urls to group into a Etcd-server cluster. As the Prophet Genesis Store is the first store, the join parameter can remain empty: join = \"\" client-urls = \"your_ip_address:40000\" peer-urls = \"your_ip_address:50000\" Set prophet-node to TRUE, as the prophet store will hold the cluster metadata: prophet-node = true Set max-replicas number to the replica numbers that you want, it can only be 2*N+1 numbers: max-replicas = 3","title":"Step2"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#step3","text":"Set up store2 and store3 as prophet stores. Repeat the same procedure of step1 and step2 for each store. The only two differences are setting a unique nodeID and a join ip address. nodeID = 2 or 3; join = \"ip_address_of_store1\"","title":"Step3"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#step4","text":"Set up the other two stores as pure storage store. Repeat the same procedure of step1 and step2 for each store. There are three more parameters to be set: Set a unique number for nodeID. Set prophet-node to TRUE. Fill the three empty string with the three client-urls of the three prophet node for the external-etcd parameter. nodeID = 4/5; prophet-node = false; prophet-node = [\"ip_address_of_prophet_store1\",\"ip_address_of_prophet_store2\",\"ip_address_of_prophet_store3\"] To learn more about our distribute system parameters, please refer to distributed settings .","title":"Step4"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/","text":"Install standalone MatrixOne MatrixOne supports Linux and MacOS. You can install a standalone MatrixOne version either by building from source or using docker . Recommended hardware specification: x86 CPU with 4 cores and 32GB memory, with CentOS 7+ OS. Method 1: Install From AUR ArchLinux User can install MatrixOne from AUR . $ git clone https://aur.archlinux.org/matrixone.git $ cd matrixone $ makepkg -rsi Method 2: Building from source 1. Install Go as necessary Go version 1.18 is required. 2. Get the MatrixOne code $ git clone https://github.com/matrixorigin/matrixone.git $ cd matrixone 3. Run make You can run make debug , make clean , or anything else our Makefile offers. $ make config $ make build 4. Boot MatrixOne server $ ./mo-server system_vars_config.toml Method 3: Downloading binary packages Starting with 0.3.0, you can download binary packages directly to run MatrixOne in the X86_64 Linux or Mac X86_64 environment. 1. Download binary packages and decompress Linux Environment $ wget https://github.com/matrixorigin/matrixone/releases/download/v0.4.0/mo-server-v0.4.0-linux-amd64.zip $ unzip mo-server-v0.4.0-linux-amd64.zip MacOS Environment $ https://github.com/matrixorigin/matrixone/releases/download/v0.4.0/mo-server-v0.4.0-darwin-x86_64.zip $ unzip mo-server-v0.4.0-darwin-x86_64.zip 2.Launch MatrixOne server $./mo-server system_vars_config.toml Method 4: Using docker 1. Install Docker Please verify that Docker daemon is running in the background: $ docker --version 2. Create and run the container for the latest release of MatrixOne It will pull the image from Docker Hub if not exists. $ docker run -d -p 6001:6001 --name matrixone matrixorigin/matrixone:latest note For the information on the user name and password, see step 2. Next step: Connect to MatrixOne Server When you finish installing MatrixOne, you can refer to the section below to connect to the MatrixOne server. See Connect to MatrixOne server .","title":"Install Standalone MatrixOne"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#install-standalone-matrixone","text":"MatrixOne supports Linux and MacOS. You can install a standalone MatrixOne version either by building from source or using docker . Recommended hardware specification: x86 CPU with 4 cores and 32GB memory, with CentOS 7+ OS.","title":"Install standalone MatrixOne"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#method-1-install-from-aur","text":"ArchLinux User can install MatrixOne from AUR . $ git clone https://aur.archlinux.org/matrixone.git $ cd matrixone $ makepkg -rsi","title":"Method 1: Install From AUR"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#method-2-building-from-source","text":"","title":"Method 2: Building from source"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#1-install-go-as-necessary","text":"Go version 1.18 is required.","title":"1. Install Go as necessary"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#2-get-the-matrixone-code","text":"$ git clone https://github.com/matrixorigin/matrixone.git $ cd matrixone","title":"2. Get the MatrixOne code"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#3-run-make","text":"You can run make debug , make clean , or anything else our Makefile offers. $ make config $ make build","title":"3. Run make"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#4-boot-matrixone-server","text":"$ ./mo-server system_vars_config.toml","title":"4. Boot MatrixOne server"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#method-3-downloading-binary-packages","text":"Starting with 0.3.0, you can download binary packages directly to run MatrixOne in the X86_64 Linux or Mac X86_64 environment.","title":"Method 3: Downloading binary packages"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#1-download-binary-packages-and-decompress","text":"Linux Environment $ wget https://github.com/matrixorigin/matrixone/releases/download/v0.4.0/mo-server-v0.4.0-linux-amd64.zip $ unzip mo-server-v0.4.0-linux-amd64.zip MacOS Environment $ https://github.com/matrixorigin/matrixone/releases/download/v0.4.0/mo-server-v0.4.0-darwin-x86_64.zip $ unzip mo-server-v0.4.0-darwin-x86_64.zip","title":"1. Download binary packages and decompress"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#2launch-matrixone-server","text":"$./mo-server system_vars_config.toml","title":"2.Launch MatrixOne server"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#method-4-using-docker","text":"","title":"Method 4: Using docker"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#1-install-docker","text":"Please verify that Docker daemon is running in the background: $ docker --version","title":"1. Install Docker"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#2-create-and-run-the-container-for-the-latest-release-of-matrixone","text":"It will pull the image from Docker Hub if not exists. $ docker run -d -p 6001:6001 --name matrixone matrixorigin/matrixone:latest note For the information on the user name and password, see step 2.","title":"2. Create and run the container for the latest release of MatrixOne"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#next-step-connect-to-matrixone-server","text":"When you finish installing MatrixOne, you can refer to the section below to connect to the MatrixOne server. See Connect to MatrixOne server .","title":"Next step: Connect to MatrixOne Server"},{"location":"MatrixOne/Get-Started/Tutorial/NYC-test-with-matrixone/","text":"Complete a NYC Test with MatrixOne New York City (NYC) Taxi data set captures detailed information on billions of individual taxi trips in New York City. The data includes pick-up and drop-off dates/times, pick-up and drop-off locations, trip distances, itemized fares, rate types, payment types, and driver-reported passenger counts(Most of the raw data comes from the NYC Taxi & Limousine Commission). By going through this tutorial, you\u2019ll learn how to complete some queries on NYC Taxi data with MatrixOne. For detailed descriptions and instructions for downloading NYC Taxi Data , you can visit: https://github.com/toddwschneider/nyc-taxi-data http://tech.marksblogg.com/billion-nyc-taxi-rides-redshift.html . Before you begin Make sure you have already installed MatrixOne and connected to MatrixOne Server . 1. Download and Import data This section of the tutorial references here , and you can get original information about how to download and import raw data there. The data set has 1.7 billion rows of data and takes up 450 GB of space, so make sure have enough space to hold the data. Install PostgreSQL and PostGIS Both are available via Homebrew on Mac. Download raw data ./download_raw_data.sh && ./remove_bad_rows.sh The remove_bad_rows.sh script fixes two particular files that have a few rows with too many columns. For more detailed information about this, you can see the original references. Initialize database and set up schema ./initialize_database.sh Import taxi and FHV data ./import_trip_data.sh ./import_fhv_trip_data.sh Optional: download and import 2014 Uber data The FiveThirtyEight Uber dataset contains Uber trip records from Apr\u2013Sep 2014. Uber and other FHV (Lyft, Juno, Via, etc.) data is available since Jan 2015 in the TLC's data. ./download_raw_2014_uber_data.sh ./import_2014_uber_trip_data.sh 2. Exporting the data from PostgreSQL COPY ( SELECT trips.id, trips.vendor_id, trips.pickup_datetime, trips.dropoff_datetime, trips.store_and_fwd_flag, trips.rate_code_id, trips.pickup_longitude, trips.pickup_latitude, trips.dropoff_longitude, trips.dropoff_latitude, trips.passenger_count, trips.trip_distance, trips.fare_amount, trips.extra, trips.mta_tax, trips.tip_amount, trips.tolls_amount, trips.ehail_fee, trips.improvement_surcharge, trips.total_amount, trips.payment_type, trips.trip_type, trips.pickup_location_id, trips.dropoff_location_id, cab_types.type cab_type, weather.precipitation rain, weather.snow_depth, weather.snowfall, weather.max_temperature max_temp, weather.min_temperature min_temp, weather.average_wind_speed wind, pick_up.gid pickup_nyct2010_gid, pick_up.ctlabel pickup_ctlabel, pick_up.borocode pickup_borocode, pick_up.boroname pickup_boroname, pick_up.ct2010 pickup_ct2010, pick_up.boroct2010 pickup_boroct2010, pick_up.cdeligibil pickup_cdeligibil, pick_up.ntacode pickup_ntacode, pick_up.ntaname pickup_ntaname, pick_up.puma pickup_puma, drop_off.gid dropoff_nyct2010_gid, drop_off.ctlabel dropoff_ctlabel, drop_off.borocode dropoff_borocode, drop_off.boroname dropoff_boroname, drop_off.ct2010 dropoff_ct2010, drop_off.boroct2010 dropoff_boroct2010, drop_off.cdeligibil dropoff_cdeligibil, drop_off.ntacode dropoff_ntacode, drop_off.ntaname dropoff_ntaname, drop_off.puma dropoff_puma FROM trips LEFT JOIN cab_types ON trips.cab_type_id = cab_types.id LEFT JOIN central_park_weather_observations weather ON weather.date = trips.pickup_datetime::date LEFT JOIN nyct2010 pick_up ON pick_up.gid = trips.pickup_nyct2010_gid LEFT JOIN nyct2010 drop_off ON drop_off.gid = trips.dropoff_nyct2010_gid ) TO '/matrixone/export_data/trips.tsv'; 3. Create tables in MatrixOne CREATE TABLE trips ( trip_id int unsigned, vendor_id varchar(64), pickup_datetime bigint unsigned, dropoff_datetime bigint unsigned, store_and_fwd_flag char(1), rate_code_id smallint unsigned, pickup_longitude double, pickup_latitude double, dropoff_longitude double, dropoff_latitude double, passenger_count smallint unsigned, trip_distance double, distance bigint, fare_amount float, extra float, mta_tax float, tip_amount float, tolls_amount float, ehail_fee float, improvement_surcharge float, total_amount float, payment_type varchar(64), trip_type smallint unsigned, pickup varchar(64), dropoff varchar(64), cab_type varchar(64), precipitation float, snow_depth float, snowfall float, max_temperature smallint, min_temperature smallint, average_wind_speed float, pickup_nyct2010_gid smallint unsigned, pickup_ctlabel varchar(64), pickup_borocode smallint unsigned, pickup_boroname varchar(64), pickup_ct2010 varchar(64), pickup_boroct2010 varchar(64), pickup_cdeligibil char(1), pickup_ntacode varchar(64), pickup_ntaname varchar(64), pickup_puma varchar(64), dropoff_nyct2010_gid smallint unsigned, dropoff_ctlabel varchar(64), dropoff_borocode smallint unsigned, dropoff_boroname varchar(64), dropoff_ct2010 varchar(64), dropoff_boroct2010 varchar(64), dropoff_cdeligibil varchar(64), dropoff_ntacode varchar(64), dropoff_ntaname varchar(64), dropoff_puma varchar(64) ) ; 4. Insert data into the created tables load data infile '/matrixone/export_data/trips.tsv ' into table trips FIELDS TERMINATED BY ',' LINES TERMINATED BY '\\n'; Then you can query data in MatrixOne with the created table. 5. Run Queries # Q1 SELECT cab_type, count(*) FROM trips GROUP BY cab_type; # Q2 SELECT passenger_count, avg(total_amount) FROM trips GROUP BY passenger_count; # Q3 SELECT passenger_count, year(pickup_datetime) as year, count(*) FROM trips GROUP BY passenger_count, year; # Q4 SELECT passenger_count, year(pickup_datetime) as year, round(trip_distance) AS distance, count(*) as count FROM trips GROUP BY passenger_count, year, distance ORDER BY year,count DESC;","title":"NYC Test with MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/NYC-test-with-matrixone/#complete-a-nyc-test-with-matrixone","text":"New York City (NYC) Taxi data set captures detailed information on billions of individual taxi trips in New York City. The data includes pick-up and drop-off dates/times, pick-up and drop-off locations, trip distances, itemized fares, rate types, payment types, and driver-reported passenger counts(Most of the raw data comes from the NYC Taxi & Limousine Commission). By going through this tutorial, you\u2019ll learn how to complete some queries on NYC Taxi data with MatrixOne. For detailed descriptions and instructions for downloading NYC Taxi Data , you can visit: https://github.com/toddwschneider/nyc-taxi-data http://tech.marksblogg.com/billion-nyc-taxi-rides-redshift.html .","title":"Complete a NYC Test with MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/NYC-test-with-matrixone/#before-you-begin","text":"Make sure you have already installed MatrixOne and connected to MatrixOne Server .","title":"Before you begin"},{"location":"MatrixOne/Get-Started/Tutorial/NYC-test-with-matrixone/#1-download-and-import-data","text":"This section of the tutorial references here , and you can get original information about how to download and import raw data there. The data set has 1.7 billion rows of data and takes up 450 GB of space, so make sure have enough space to hold the data. Install PostgreSQL and PostGIS Both are available via Homebrew on Mac. Download raw data ./download_raw_data.sh && ./remove_bad_rows.sh The remove_bad_rows.sh script fixes two particular files that have a few rows with too many columns. For more detailed information about this, you can see the original references. Initialize database and set up schema ./initialize_database.sh Import taxi and FHV data ./import_trip_data.sh ./import_fhv_trip_data.sh Optional: download and import 2014 Uber data The FiveThirtyEight Uber dataset contains Uber trip records from Apr\u2013Sep 2014. Uber and other FHV (Lyft, Juno, Via, etc.) data is available since Jan 2015 in the TLC's data. ./download_raw_2014_uber_data.sh ./import_2014_uber_trip_data.sh","title":"1. Download and Import data"},{"location":"MatrixOne/Get-Started/Tutorial/NYC-test-with-matrixone/#2-exporting-the-data-from-postgresql","text":"COPY ( SELECT trips.id, trips.vendor_id, trips.pickup_datetime, trips.dropoff_datetime, trips.store_and_fwd_flag, trips.rate_code_id, trips.pickup_longitude, trips.pickup_latitude, trips.dropoff_longitude, trips.dropoff_latitude, trips.passenger_count, trips.trip_distance, trips.fare_amount, trips.extra, trips.mta_tax, trips.tip_amount, trips.tolls_amount, trips.ehail_fee, trips.improvement_surcharge, trips.total_amount, trips.payment_type, trips.trip_type, trips.pickup_location_id, trips.dropoff_location_id, cab_types.type cab_type, weather.precipitation rain, weather.snow_depth, weather.snowfall, weather.max_temperature max_temp, weather.min_temperature min_temp, weather.average_wind_speed wind, pick_up.gid pickup_nyct2010_gid, pick_up.ctlabel pickup_ctlabel, pick_up.borocode pickup_borocode, pick_up.boroname pickup_boroname, pick_up.ct2010 pickup_ct2010, pick_up.boroct2010 pickup_boroct2010, pick_up.cdeligibil pickup_cdeligibil, pick_up.ntacode pickup_ntacode, pick_up.ntaname pickup_ntaname, pick_up.puma pickup_puma, drop_off.gid dropoff_nyct2010_gid, drop_off.ctlabel dropoff_ctlabel, drop_off.borocode dropoff_borocode, drop_off.boroname dropoff_boroname, drop_off.ct2010 dropoff_ct2010, drop_off.boroct2010 dropoff_boroct2010, drop_off.cdeligibil dropoff_cdeligibil, drop_off.ntacode dropoff_ntacode, drop_off.ntaname dropoff_ntaname, drop_off.puma dropoff_puma FROM trips LEFT JOIN cab_types ON trips.cab_type_id = cab_types.id LEFT JOIN central_park_weather_observations weather ON weather.date = trips.pickup_datetime::date LEFT JOIN nyct2010 pick_up ON pick_up.gid = trips.pickup_nyct2010_gid LEFT JOIN nyct2010 drop_off ON drop_off.gid = trips.dropoff_nyct2010_gid ) TO '/matrixone/export_data/trips.tsv';","title":"2. Exporting the data from PostgreSQL"},{"location":"MatrixOne/Get-Started/Tutorial/NYC-test-with-matrixone/#3-create-tables-in-matrixone","text":"CREATE TABLE trips ( trip_id int unsigned, vendor_id varchar(64), pickup_datetime bigint unsigned, dropoff_datetime bigint unsigned, store_and_fwd_flag char(1), rate_code_id smallint unsigned, pickup_longitude double, pickup_latitude double, dropoff_longitude double, dropoff_latitude double, passenger_count smallint unsigned, trip_distance double, distance bigint, fare_amount float, extra float, mta_tax float, tip_amount float, tolls_amount float, ehail_fee float, improvement_surcharge float, total_amount float, payment_type varchar(64), trip_type smallint unsigned, pickup varchar(64), dropoff varchar(64), cab_type varchar(64), precipitation float, snow_depth float, snowfall float, max_temperature smallint, min_temperature smallint, average_wind_speed float, pickup_nyct2010_gid smallint unsigned, pickup_ctlabel varchar(64), pickup_borocode smallint unsigned, pickup_boroname varchar(64), pickup_ct2010 varchar(64), pickup_boroct2010 varchar(64), pickup_cdeligibil char(1), pickup_ntacode varchar(64), pickup_ntaname varchar(64), pickup_puma varchar(64), dropoff_nyct2010_gid smallint unsigned, dropoff_ctlabel varchar(64), dropoff_borocode smallint unsigned, dropoff_boroname varchar(64), dropoff_ct2010 varchar(64), dropoff_boroct2010 varchar(64), dropoff_cdeligibil varchar(64), dropoff_ntacode varchar(64), dropoff_ntaname varchar(64), dropoff_puma varchar(64) ) ;","title":"3. Create tables in MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/NYC-test-with-matrixone/#4-insert-data-into-the-created-tables","text":"load data infile '/matrixone/export_data/trips.tsv ' into table trips FIELDS TERMINATED BY ',' LINES TERMINATED BY '\\n'; Then you can query data in MatrixOne with the created table.","title":"4. Insert data into the created tables"},{"location":"MatrixOne/Get-Started/Tutorial/NYC-test-with-matrixone/#5-run-queries","text":"# Q1 SELECT cab_type, count(*) FROM trips GROUP BY cab_type; # Q2 SELECT passenger_count, avg(total_amount) FROM trips GROUP BY passenger_count; # Q3 SELECT passenger_count, year(pickup_datetime) as year, count(*) FROM trips GROUP BY passenger_count, year; # Q4 SELECT passenger_count, year(pickup_datetime) as year, round(trip_distance) AS distance, count(*) as count FROM trips GROUP BY passenger_count, year, distance ORDER BY year,count DESC;","title":"5. Run Queries"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/","text":"Complete a SSB Test with MatrixOne The Star Schema Benchmark\uff08SSB\uff09Test is a popular scenario for OLAP database performance tests. By going through this tutorial, you\u2019ll learn how to complete a SSB Test with MatrixOne. In v0.1.0, only single table can work in MatrixOne. The following contents can be followed for generating data, importing data, and querying data. Before you begin Make sure you have already installed MatrixOne and connected to MatrixOne Server . 1. Compile dbgen $ git clone git@github.com:vadimtk/ssb-dbgen.git $ cd ssb-dbgen $ make 2. Generate data With -s 1 dbgen generates 6 million rows (670MB), while while -s 10 it generates 60 million rows (which takes some time) $ ./dbgen -s 1 -T c $ ./dbgen -s 1 -T l $ ./dbgen -s 1 -T p $ ./dbgen -s 1 -T s $ ./dbgen -s 1 -T d 3. Create tables in MatrixOne create database if not exists ssb; use ssb; drop table if exists lineorder; drop table if exists part; drop table if exists supplier; drop table if exists customer; drop table if exists dates; drop table if exists lineorder_flat; create table lineorder ( lo_orderkey bigint, lo_linenumber int, lo_custkey int, lo_partkey int, lo_suppkey int, lo_orderdate date, lo_orderpriority char (15), lo_shippriority tinyint, lo_quantity double, lo_extendedprice double, lo_ordtotalprice double, lo_discount double, lo_revenue double, lo_supplycost double, lo_tax double, lo_commitdate date, lo_shipmode char (10) ) ; create table part ( p_partkey int, p_name varchar (22), p_mfgr char (6), p_category char (7), p_brand char (9), p_color varchar (11), p_type varchar (25), p_size int, p_container char (10) ) ; create table supplier ( s_suppkey int, s_name char (25), s_address varchar (25), s_city char (10), s_nation char (15), s_region char (12), s_phone char (15) ) ; create table customer ( c_custkey int, c_name varchar (25), c_address varchar (25), c_city char (10), c_nation char (15), c_region char (12), c_phone char (15), c_mktsegment char (10) ) ; create table dates ( d_datekey date, d_date char (18), d_dayofweek char (9), d_month char (9), d_yearmonthnum int, d_yearmonth char (7), d_daynuminweek varchar(12), d_daynuminmonth int, d_daynuminyear int, d_monthnuminyear int, d_weeknuminyear int, d_sellingseason varchar (12), d_lastdayinweekfl varchar (1), d_lastdayinmonthfl varchar (1), d_holidayfl varchar (1), d_weekdayfl varchar (1) ) ; CREATE TABLE lineorder_flat( LO_ORDERKEY bigint primary key, LO_LINENUMBER int, LO_CUSTKEY int, LO_PARTKEY int, LO_SUPPKEY int, LO_ORDERDATE date, LO_ORDERPRIORITY char(15), LO_SHIPPRIORITY tinyint, LO_QUANTITY double, LO_EXTENDEDPRICE double, LO_ORDTOTALPRICE double, LO_DISCOUNT double, LO_REVENUE int unsigned, LO_SUPPLYCOST int unsigned, LO_TAX double, LO_COMMITDATE date, LO_SHIPMODE char(10), C_NAME varchar(25), C_ADDRESS varchar(25), C_CITY char(10), C_NATION char(15), C_REGION char(12), C_PHONE char(15), C_MKTSEGMENT char(10), S_NAME char(25), S_ADDRESS varchar(25), S_CITY char(10), S_NATION char(15), S_REGION char(12), S_PHONE char(15), P_NAME varchar(22), P_MFGR char(6), P_CATEGORY char(7), P_BRAND char(9), P_COLOR varchar(11), P_TYPE varchar(25), P_SIZE int, P_CONTAINER char(10) ); 4. Load data into the created tables Modify the parameter of system_vars_config.toml to a larger one in matrixone directory, such as 10GB. And restart MatrixOne service. max-entry-bytes = \"10GB\" Load data into related tables with this command in MatrixOne. load data infile '/ssb-dbgen-path/supplier.tbl' into table supplier FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/customer.tbl' into table customer FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/date.tbl' into table dates FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/part.tbl' into table part FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/lineorder.tbl' into table lineorder FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; Then you can query data in MatrixOne with the created table. If you want to run a single table SSB query test, there is still one more data files needed for lineorder_flat. You can get the data files directly: https://community-shared-data-1308875761.cos.ap-beijing.myqcloud.com/lineorder_flat.tar.bz2 Load data into lineorder_flat. load data infile '/ssb-dbgen-path/lineorder_flat.tbl ' into table lineorder_flat FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; 5. Run SSB Queries Flat table queries --Q1.1 SELECT sum ( LO_EXTENDEDPRICE * LO_DISCOUNT ) AS revenue FROM lineorder_flat WHERE year ( LO_ORDERDATE ) = 1993 AND LO_DISCOUNT BETWEEN 1 AND 3 AND LO_QUANTITY < 25 ; --Q1.2 SELECT sum ( LO_EXTENDEDPRICE * LO_DISCOUNT ) AS revenue FROM lineorder_flat WHERE year ( LO_ORDERDATE ) = 1994 AND LO_DISCOUNT BETWEEN 4 AND 6 AND LO_QUANTITY BETWEEN 26 AND 35 ; --Q1.3 SELECT sum ( LO_EXTENDEDPRICE * LO_DISCOUNT ) AS revenue FROM lineorder_flat WHERE d_yearmonthnum = 1994 AND LO_DISCOUNT BETWEEN 5 AND 7 AND LO_QUANTITY BETWEEN 26 AND 35 ; --Q2.1 SELECT sum ( LO_REVENUE ), year ( LO_ORDERDATE ) AS year , P_BRAND FROM lineorder_flat WHERE P_CATEGORY = 'MFGR#12' AND S_REGION = 'AMERICA' GROUP BY year , P_BRAND ORDER BY year , P_BRAND ; --Q2.2 SELECT sum ( LO_REVENUE ), year ( LO_ORDERDATE ) AS year , P_BRAND FROM lineorder_flat WHERE P_BRAND BETWEEN 'MFGR#2221' AND 'MFGR#2228' AND S_REGION = 'ASIA' GROUP BY year , P_BRAND ORDER BY year , P_BRAND ; --Q2.3 SELECT sum ( LO_REVENUE ), year ( LO_ORDERDATE ) AS year , P_BRAND FROM lineorder_flat WHERE P_BRAND = 'MFGR#2239' AND S_REGION = 'EUROPE' GROUP BY year , P_BRAND ORDER BY year , P_BRAND ; --Q3.1 SELECT C_NATION , S_NATION , year ( LO_ORDERDATE ) AS year , sum ( LO_REVENUE ) AS revenue FROM lineorder_flat WHERE C_REGION = 'ASIA' AND S_REGION = 'ASIA' AND year ( LO_ORDERDATE ) between 1992 AND 1997 GROUP BY C_NATION , S_NATION , year ( LO_ORDERDATE ) ORDER BY year asc , revenue desc ; --Q3.2 SELECT C_CITY , S_CITY , year ( LO_ORDERDATE ) AS year , sum ( LO_REVENUE ) AS revenue FROM lineorder_flat WHERE C_NATION = 'CHINA' AND S_NATION = 'CHINA' AND year ( LO_ORDERDATE ) between 1992 AND 1997 GROUP BY C_CITY , S_CITY , year ( LO_ORDERDATE ) ORDER BY year asc , revenue desc ; --Q3.3 SELECT C_CITY , S_CITY , year ( LO_ORDERDATE ) AS year , sum ( LO_REVENUE ) AS revenue FROM lineorder_flat WHERE ( C_CITY = 'UNITED KI0' OR C_CITY = 'UNITED KI7' ) AND ( S_CITY = 'UNITED KI0' OR S_CITY = 'UNITED KI7' ) AND year ( LO_ORDERDATE ) between 1992 AND 1997 GROUP BY C_CITY , S_CITY , year ( LO_ORDERDATE ) ORDER BY year asc , revenue desc ; --Q3.4 SELECT C_CITY , S_CITY , year ( LO_ORDERDATE ) AS year , sum ( LO_REVENUE ) AS revenue FROM lineorder_flat WHERE ( C_CITY = 'UNITED KI0' OR C_CITY = 'UNITED KI7' ) AND ( S_CITY = 'MOZAMBIQU1' OR S_CITY = 'KENYA 4' ) AND year ( LO_ORDERDATE ) = 1997 GROUP BY C_CITY , S_CITY , year ( LO_ORDERDATE ) ORDER BY year asc , revenue desc ; --Q4.1 SELECT year ( LO_ORDERDATE ) AS year , C_NATION , sum ( LO_REVENUE - LO_SUPPLYCOST ) AS profit FROM lineorder_flat WHERE C_REGION = 'AMERICA' AND S_REGION = 'AMERICA' AND ( P_MFGR = 'MFGR#1' OR P_MFGR = 'MFGR#2' ) GROUP BY year ( LO_ORDERDATE ), C_NATION ORDER BY year , C_NATION ; --Q4.2 SELECT year ( LO_ORDERDATE ) AS year , S_NATION , P_CATEGORY , sum ( LO_REVENUE - LO_SUPPLYCOST ) AS profit FROM lineorder_flat WHERE C_REGION = 'AMERICA' AND S_REGION = 'AMERICA' AND ( year ( LO_ORDERDATE ) = 1997 OR year ( LO_ORDERDATE ) = 1998 ) AND ( P_MFGR = 'MFGR#1' OR P_MFGR = 'MFGR#2' ) GROUP BY year ( LO_ORDERDATE ), S_NATION , P_CATEGORY ORDER BY year , S_NATION , P_CATEGORY ; --Q4.3 SELECT year ( LO_ORDERDATE ) AS year , S_CITY , P_BRAND , sum ( LO_REVENUE - LO_SUPPLYCOST ) AS profit FROM lineorder_flat WHERE S_NATION = 'UNITED STATES' AND ( year ( LO_ORDERDATE ) = 1997 OR year ( LO_ORDERDATE ) = 1998 ) AND P_CATEGORY = 'MFGR#14' GROUP BY year ( LO_ORDERDATE ), S_CITY , P_BRAND ORDER BY year , S_CITY , P_BRAND ; Multiple tables queries --Q1.1 select sum ( lo_revenue ) as revenue from lineorder join dates on lo_orderdate = d_datekey where year ( d_datekey ) = 1993 and lo_discount between 1 and 3 and lo_quantity < 25 ; --Q1.2 select sum ( lo_revenue ) as revenue from lineorder join dates on lo_orderdate = d_datekey where d_yearmonthnum = 199401 and lo_discount between 4 and 6 and lo_quantity between 26 and 35 ; --Q1.3 select sum ( lo_revenue ) as revenue from lineorder join dates on lo_orderdate = d_datekey where d_weeknuminyear = 6 and year ( d_datekey ) = 1994 and lo_discount between 5 and 7 and lo_quantity between 26 and 35 ; --Q2.1 select sum ( lo_revenue ) as lo_revenue , year ( d_datekey ) as year , p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey where p_category = 'MFGR#12' and s_region = 'AMERICA' group by year , p_brand order by year , p_brand ; --Q2.2 select sum ( lo_revenue ) as lo_revenue , year ( d_datekey ) as year , p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey where p_brand between 'MFGR#2221' and 'MFGR#2228' and s_region = 'ASIA' group by year , p_brand order by year , p_brand ; --Q2.3 select sum ( lo_revenue ) as lo_revenue , year ( d_datekey ) as year , p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey where p_brand = 'MFGR#2239' and s_region = 'EUROPE' group by year , p_brand order by year , p_brand ; --Q3.1 select c_nation , s_nation , year ( d_datekey ) as year , sum ( lo_revenue ) as lo_revenue from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey where c_region = 'ASIA' and s_region = 'ASIA' and year ( d_datekey ) between 1992 and 1997 group by c_nation , s_nation , year order by year asc , lo_revenue desc ; --Q3.2 select c_city , s_city , year ( d_datekey ) as year , sum ( lo_revenue ) as lo_revenue from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey where c_nation = 'UNITED STATES' and s_nation = 'UNITED STATES' and year ( d_datekey ) between 1992 and 1997 group by c_city , s_city , year order by year asc , lo_revenue desc ; --Q3.3 select c_city , s_city , year ( d_datekey ) as year , sum ( lo_revenue ) as lo_revenue from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey where ( c_city = 'UNITED KI1' or c_city = 'UNITED KI5' ) and ( s_city = 'UNITED KI1' or s_city = 'UNITED KI5' ) and year ( d_datekey ) between 1992 and 1997 group by c_city , s_city , year order by year asc , lo_revenue desc ; --Q3.4 select c_city , s_city , year ( d_datekey ) as year , sum ( lo_revenue ) as lo_revenue from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey where ( c_city = 'UNITED KI1' or c_city = 'UNITED KI5' ) and ( s_city = 'UNITED KI1' or s_city = 'UNITED KI5' ) and d_yearmonth = 'Dec1997' group by c_city , s_city , year order by year asc , lo_revenue desc ; --Q4.1 select year ( d_datekey ) as year , c_nation , sum ( lo_revenue ) - sum ( lo_supplycost ) as profit from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey join part on lo_partkey = p_partkey where c_region = 'AMERICA' and s_region = 'AMERICA' and ( p_mfgr = 'MFGR#1' or p_mfgr = 'MFGR#2' ) group by year , c_nation order by year , c_nation ; --Q4.2 select year ( d_datekey ) as year , s_nation , p_category , sum ( lo_revenue ) - sum ( lo_supplycost ) as profit from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey join part on lo_partkey = p_partkey where c_region = 'AMERICA' and s_region = 'AMERICA' and ( year ( d_datekey ) = 1997 or year ( d_datekey ) = 1998 ) and ( p_mfgr = 'MFGR#1' or p_mfgr = 'MFGR#2' ) group by year , s_nation , p_category order by year , s_nation , p_category ; --Q4.3 select year ( d_datekey ) as year , s_city , p_brand , sum ( lo_revenue ) - sum ( lo_supplycost ) as profit , c_region , s_nation , p_category from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey join part on lo_partkey = p_partkey where ( year ( d_datekey ) = 1997 or year ( d_datekey ) = 1998 ) and s_nation = 'ALGERIA' group by year , s_city , p_brand order by year , s_city , p_brand ;","title":"SSB Test with MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#complete-a-ssb-test-with-matrixone","text":"The Star Schema Benchmark\uff08SSB\uff09Test is a popular scenario for OLAP database performance tests. By going through this tutorial, you\u2019ll learn how to complete a SSB Test with MatrixOne. In v0.1.0, only single table can work in MatrixOne. The following contents can be followed for generating data, importing data, and querying data.","title":"Complete a SSB Test with MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#before-you-begin","text":"Make sure you have already installed MatrixOne and connected to MatrixOne Server .","title":"Before you begin"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#1-compile-dbgen","text":"$ git clone git@github.com:vadimtk/ssb-dbgen.git $ cd ssb-dbgen $ make","title":"1. Compile dbgen"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#2-generate-data","text":"With -s 1 dbgen generates 6 million rows (670MB), while while -s 10 it generates 60 million rows (which takes some time) $ ./dbgen -s 1 -T c $ ./dbgen -s 1 -T l $ ./dbgen -s 1 -T p $ ./dbgen -s 1 -T s $ ./dbgen -s 1 -T d","title":"2. Generate data"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#3-create-tables-in-matrixone","text":"create database if not exists ssb; use ssb; drop table if exists lineorder; drop table if exists part; drop table if exists supplier; drop table if exists customer; drop table if exists dates; drop table if exists lineorder_flat; create table lineorder ( lo_orderkey bigint, lo_linenumber int, lo_custkey int, lo_partkey int, lo_suppkey int, lo_orderdate date, lo_orderpriority char (15), lo_shippriority tinyint, lo_quantity double, lo_extendedprice double, lo_ordtotalprice double, lo_discount double, lo_revenue double, lo_supplycost double, lo_tax double, lo_commitdate date, lo_shipmode char (10) ) ; create table part ( p_partkey int, p_name varchar (22), p_mfgr char (6), p_category char (7), p_brand char (9), p_color varchar (11), p_type varchar (25), p_size int, p_container char (10) ) ; create table supplier ( s_suppkey int, s_name char (25), s_address varchar (25), s_city char (10), s_nation char (15), s_region char (12), s_phone char (15) ) ; create table customer ( c_custkey int, c_name varchar (25), c_address varchar (25), c_city char (10), c_nation char (15), c_region char (12), c_phone char (15), c_mktsegment char (10) ) ; create table dates ( d_datekey date, d_date char (18), d_dayofweek char (9), d_month char (9), d_yearmonthnum int, d_yearmonth char (7), d_daynuminweek varchar(12), d_daynuminmonth int, d_daynuminyear int, d_monthnuminyear int, d_weeknuminyear int, d_sellingseason varchar (12), d_lastdayinweekfl varchar (1), d_lastdayinmonthfl varchar (1), d_holidayfl varchar (1), d_weekdayfl varchar (1) ) ; CREATE TABLE lineorder_flat( LO_ORDERKEY bigint primary key, LO_LINENUMBER int, LO_CUSTKEY int, LO_PARTKEY int, LO_SUPPKEY int, LO_ORDERDATE date, LO_ORDERPRIORITY char(15), LO_SHIPPRIORITY tinyint, LO_QUANTITY double, LO_EXTENDEDPRICE double, LO_ORDTOTALPRICE double, LO_DISCOUNT double, LO_REVENUE int unsigned, LO_SUPPLYCOST int unsigned, LO_TAX double, LO_COMMITDATE date, LO_SHIPMODE char(10), C_NAME varchar(25), C_ADDRESS varchar(25), C_CITY char(10), C_NATION char(15), C_REGION char(12), C_PHONE char(15), C_MKTSEGMENT char(10), S_NAME char(25), S_ADDRESS varchar(25), S_CITY char(10), S_NATION char(15), S_REGION char(12), S_PHONE char(15), P_NAME varchar(22), P_MFGR char(6), P_CATEGORY char(7), P_BRAND char(9), P_COLOR varchar(11), P_TYPE varchar(25), P_SIZE int, P_CONTAINER char(10) );","title":"3. Create tables in MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#4-load-data-into-the-created-tables","text":"Modify the parameter of system_vars_config.toml to a larger one in matrixone directory, such as 10GB. And restart MatrixOne service. max-entry-bytes = \"10GB\" Load data into related tables with this command in MatrixOne. load data infile '/ssb-dbgen-path/supplier.tbl' into table supplier FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/customer.tbl' into table customer FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/date.tbl' into table dates FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/part.tbl' into table part FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/lineorder.tbl' into table lineorder FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; Then you can query data in MatrixOne with the created table. If you want to run a single table SSB query test, there is still one more data files needed for lineorder_flat. You can get the data files directly: https://community-shared-data-1308875761.cos.ap-beijing.myqcloud.com/lineorder_flat.tar.bz2 Load data into lineorder_flat. load data infile '/ssb-dbgen-path/lineorder_flat.tbl ' into table lineorder_flat FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n';","title":"4. Load data into the created tables"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#5-run-ssb-queries","text":"","title":"5. Run SSB Queries"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#flat-table-queries","text":"--Q1.1 SELECT sum ( LO_EXTENDEDPRICE * LO_DISCOUNT ) AS revenue FROM lineorder_flat WHERE year ( LO_ORDERDATE ) = 1993 AND LO_DISCOUNT BETWEEN 1 AND 3 AND LO_QUANTITY < 25 ; --Q1.2 SELECT sum ( LO_EXTENDEDPRICE * LO_DISCOUNT ) AS revenue FROM lineorder_flat WHERE year ( LO_ORDERDATE ) = 1994 AND LO_DISCOUNT BETWEEN 4 AND 6 AND LO_QUANTITY BETWEEN 26 AND 35 ; --Q1.3 SELECT sum ( LO_EXTENDEDPRICE * LO_DISCOUNT ) AS revenue FROM lineorder_flat WHERE d_yearmonthnum = 1994 AND LO_DISCOUNT BETWEEN 5 AND 7 AND LO_QUANTITY BETWEEN 26 AND 35 ; --Q2.1 SELECT sum ( LO_REVENUE ), year ( LO_ORDERDATE ) AS year , P_BRAND FROM lineorder_flat WHERE P_CATEGORY = 'MFGR#12' AND S_REGION = 'AMERICA' GROUP BY year , P_BRAND ORDER BY year , P_BRAND ; --Q2.2 SELECT sum ( LO_REVENUE ), year ( LO_ORDERDATE ) AS year , P_BRAND FROM lineorder_flat WHERE P_BRAND BETWEEN 'MFGR#2221' AND 'MFGR#2228' AND S_REGION = 'ASIA' GROUP BY year , P_BRAND ORDER BY year , P_BRAND ; --Q2.3 SELECT sum ( LO_REVENUE ), year ( LO_ORDERDATE ) AS year , P_BRAND FROM lineorder_flat WHERE P_BRAND = 'MFGR#2239' AND S_REGION = 'EUROPE' GROUP BY year , P_BRAND ORDER BY year , P_BRAND ; --Q3.1 SELECT C_NATION , S_NATION , year ( LO_ORDERDATE ) AS year , sum ( LO_REVENUE ) AS revenue FROM lineorder_flat WHERE C_REGION = 'ASIA' AND S_REGION = 'ASIA' AND year ( LO_ORDERDATE ) between 1992 AND 1997 GROUP BY C_NATION , S_NATION , year ( LO_ORDERDATE ) ORDER BY year asc , revenue desc ; --Q3.2 SELECT C_CITY , S_CITY , year ( LO_ORDERDATE ) AS year , sum ( LO_REVENUE ) AS revenue FROM lineorder_flat WHERE C_NATION = 'CHINA' AND S_NATION = 'CHINA' AND year ( LO_ORDERDATE ) between 1992 AND 1997 GROUP BY C_CITY , S_CITY , year ( LO_ORDERDATE ) ORDER BY year asc , revenue desc ; --Q3.3 SELECT C_CITY , S_CITY , year ( LO_ORDERDATE ) AS year , sum ( LO_REVENUE ) AS revenue FROM lineorder_flat WHERE ( C_CITY = 'UNITED KI0' OR C_CITY = 'UNITED KI7' ) AND ( S_CITY = 'UNITED KI0' OR S_CITY = 'UNITED KI7' ) AND year ( LO_ORDERDATE ) between 1992 AND 1997 GROUP BY C_CITY , S_CITY , year ( LO_ORDERDATE ) ORDER BY year asc , revenue desc ; --Q3.4 SELECT C_CITY , S_CITY , year ( LO_ORDERDATE ) AS year , sum ( LO_REVENUE ) AS revenue FROM lineorder_flat WHERE ( C_CITY = 'UNITED KI0' OR C_CITY = 'UNITED KI7' ) AND ( S_CITY = 'MOZAMBIQU1' OR S_CITY = 'KENYA 4' ) AND year ( LO_ORDERDATE ) = 1997 GROUP BY C_CITY , S_CITY , year ( LO_ORDERDATE ) ORDER BY year asc , revenue desc ; --Q4.1 SELECT year ( LO_ORDERDATE ) AS year , C_NATION , sum ( LO_REVENUE - LO_SUPPLYCOST ) AS profit FROM lineorder_flat WHERE C_REGION = 'AMERICA' AND S_REGION = 'AMERICA' AND ( P_MFGR = 'MFGR#1' OR P_MFGR = 'MFGR#2' ) GROUP BY year ( LO_ORDERDATE ), C_NATION ORDER BY year , C_NATION ; --Q4.2 SELECT year ( LO_ORDERDATE ) AS year , S_NATION , P_CATEGORY , sum ( LO_REVENUE - LO_SUPPLYCOST ) AS profit FROM lineorder_flat WHERE C_REGION = 'AMERICA' AND S_REGION = 'AMERICA' AND ( year ( LO_ORDERDATE ) = 1997 OR year ( LO_ORDERDATE ) = 1998 ) AND ( P_MFGR = 'MFGR#1' OR P_MFGR = 'MFGR#2' ) GROUP BY year ( LO_ORDERDATE ), S_NATION , P_CATEGORY ORDER BY year , S_NATION , P_CATEGORY ; --Q4.3 SELECT year ( LO_ORDERDATE ) AS year , S_CITY , P_BRAND , sum ( LO_REVENUE - LO_SUPPLYCOST ) AS profit FROM lineorder_flat WHERE S_NATION = 'UNITED STATES' AND ( year ( LO_ORDERDATE ) = 1997 OR year ( LO_ORDERDATE ) = 1998 ) AND P_CATEGORY = 'MFGR#14' GROUP BY year ( LO_ORDERDATE ), S_CITY , P_BRAND ORDER BY year , S_CITY , P_BRAND ;","title":"Flat table queries"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#multiple-tables-queries","text":"--Q1.1 select sum ( lo_revenue ) as revenue from lineorder join dates on lo_orderdate = d_datekey where year ( d_datekey ) = 1993 and lo_discount between 1 and 3 and lo_quantity < 25 ; --Q1.2 select sum ( lo_revenue ) as revenue from lineorder join dates on lo_orderdate = d_datekey where d_yearmonthnum = 199401 and lo_discount between 4 and 6 and lo_quantity between 26 and 35 ; --Q1.3 select sum ( lo_revenue ) as revenue from lineorder join dates on lo_orderdate = d_datekey where d_weeknuminyear = 6 and year ( d_datekey ) = 1994 and lo_discount between 5 and 7 and lo_quantity between 26 and 35 ; --Q2.1 select sum ( lo_revenue ) as lo_revenue , year ( d_datekey ) as year , p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey where p_category = 'MFGR#12' and s_region = 'AMERICA' group by year , p_brand order by year , p_brand ; --Q2.2 select sum ( lo_revenue ) as lo_revenue , year ( d_datekey ) as year , p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey where p_brand between 'MFGR#2221' and 'MFGR#2228' and s_region = 'ASIA' group by year , p_brand order by year , p_brand ; --Q2.3 select sum ( lo_revenue ) as lo_revenue , year ( d_datekey ) as year , p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey where p_brand = 'MFGR#2239' and s_region = 'EUROPE' group by year , p_brand order by year , p_brand ; --Q3.1 select c_nation , s_nation , year ( d_datekey ) as year , sum ( lo_revenue ) as lo_revenue from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey where c_region = 'ASIA' and s_region = 'ASIA' and year ( d_datekey ) between 1992 and 1997 group by c_nation , s_nation , year order by year asc , lo_revenue desc ; --Q3.2 select c_city , s_city , year ( d_datekey ) as year , sum ( lo_revenue ) as lo_revenue from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey where c_nation = 'UNITED STATES' and s_nation = 'UNITED STATES' and year ( d_datekey ) between 1992 and 1997 group by c_city , s_city , year order by year asc , lo_revenue desc ; --Q3.3 select c_city , s_city , year ( d_datekey ) as year , sum ( lo_revenue ) as lo_revenue from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey where ( c_city = 'UNITED KI1' or c_city = 'UNITED KI5' ) and ( s_city = 'UNITED KI1' or s_city = 'UNITED KI5' ) and year ( d_datekey ) between 1992 and 1997 group by c_city , s_city , year order by year asc , lo_revenue desc ; --Q3.4 select c_city , s_city , year ( d_datekey ) as year , sum ( lo_revenue ) as lo_revenue from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey where ( c_city = 'UNITED KI1' or c_city = 'UNITED KI5' ) and ( s_city = 'UNITED KI1' or s_city = 'UNITED KI5' ) and d_yearmonth = 'Dec1997' group by c_city , s_city , year order by year asc , lo_revenue desc ; --Q4.1 select year ( d_datekey ) as year , c_nation , sum ( lo_revenue ) - sum ( lo_supplycost ) as profit from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey join part on lo_partkey = p_partkey where c_region = 'AMERICA' and s_region = 'AMERICA' and ( p_mfgr = 'MFGR#1' or p_mfgr = 'MFGR#2' ) group by year , c_nation order by year , c_nation ; --Q4.2 select year ( d_datekey ) as year , s_nation , p_category , sum ( lo_revenue ) - sum ( lo_supplycost ) as profit from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey join part on lo_partkey = p_partkey where c_region = 'AMERICA' and s_region = 'AMERICA' and ( year ( d_datekey ) = 1997 or year ( d_datekey ) = 1998 ) and ( p_mfgr = 'MFGR#1' or p_mfgr = 'MFGR#2' ) group by year , s_nation , p_category order by year , s_nation , p_category ; --Q4.3 select year ( d_datekey ) as year , s_city , p_brand , sum ( lo_revenue ) - sum ( lo_supplycost ) as profit , c_region , s_nation , p_category from lineorder join dates on lo_orderdate = d_datekey join customer on lo_custkey = c_custkey join supplier on lo_suppkey = s_suppkey join part on lo_partkey = p_partkey where ( year ( d_datekey ) = 1997 or year ( d_datekey ) = 1998 ) and s_nation = 'ALGERIA' group by year , s_city , p_brand order by year , s_city , p_brand ;","title":"Multiple tables queries"},{"location":"MatrixOne/Glossary/glossary/","text":"MatrixOne Glossary **","title":"**MatrixOne Glossary**"},{"location":"MatrixOne/Glossary/glossary/#matrixone-glossary","text":"**","title":"MatrixOne Glossary"},{"location":"MatrixOne/Overview/NYC%20Test%20Performance/","text":"NYC Test Performance Overview With MatrixOne v0.2.0, we follow the Tutorial to execute NYC Taxi test with a standalone server, and compare the results with that of other products, which shows the performance of MatrixOne in query processing time. note The following test results are the average of the three tests in seconds. Standalone node Info The following server was used: AMD EPYC\u2122 Rome CPU 2.6GHz/3.3GHz, 16 physical cores total, 32 GiB Memory. Query ID MatrixOne 0.2.0 ClickHouse v21.11.4.14 Starrocks v1.19.3 (Only 30M unique data) Q1 8.37 5.99 2.58 Q2 2.67 4.13 2.18 Q3 3.48 4.56 3.43 Q4 5.34 7.09 4.19 SUM 19.86 21.77 12.38 Limitations There are some limitations on queries in MatrixOne v0.2.0: The filter command WHERE is not supported The table cannot be partitioned currently, so commands as PARTITION series are not supported Learn More This page shows the results of NYC Test with MatrixOne. For information on other benchmarks that are available when trying out MatrixOne, see the following: SSB Test with MatrixOne SSB Test Performance","title":"NYC Test Performance"},{"location":"MatrixOne/Overview/NYC%20Test%20Performance/#nyc-test-performance","text":"","title":"NYC Test Performance"},{"location":"MatrixOne/Overview/NYC%20Test%20Performance/#overview","text":"With MatrixOne v0.2.0, we follow the Tutorial to execute NYC Taxi test with a standalone server, and compare the results with that of other products, which shows the performance of MatrixOne in query processing time. note The following test results are the average of the three tests in seconds.","title":"Overview"},{"location":"MatrixOne/Overview/NYC%20Test%20Performance/#standalone-node","text":"Info The following server was used: AMD EPYC\u2122 Rome CPU 2.6GHz/3.3GHz, 16 physical cores total, 32 GiB Memory. Query ID MatrixOne 0.2.0 ClickHouse v21.11.4.14 Starrocks v1.19.3 (Only 30M unique data) Q1 8.37 5.99 2.58 Q2 2.67 4.13 2.18 Q3 3.48 4.56 3.43 Q4 5.34 7.09 4.19 SUM 19.86 21.77 12.38","title":"Standalone node"},{"location":"MatrixOne/Overview/NYC%20Test%20Performance/#limitations","text":"There are some limitations on queries in MatrixOne v0.2.0: The filter command WHERE is not supported The table cannot be partitioned currently, so commands as PARTITION series are not supported","title":"Limitations"},{"location":"MatrixOne/Overview/NYC%20Test%20Performance/#learn-more","text":"This page shows the results of NYC Test with MatrixOne. For information on other benchmarks that are available when trying out MatrixOne, see the following: SSB Test with MatrixOne SSB Test Performance","title":"Learn More"},{"location":"MatrixOne/Overview/SSB%20Test%20Performance/","text":"SSB Test Performance Overview We present the SSB Test results for MatrixOne with different hardwares and query modes. For instructions to reproduce the SSB test results listed here, see SSB Test with MatrixOne , and if you fail to achieve similar results, there is likely a problem in either the hardware, workload, or test design. In v0.2.0, both single table and multiple tables can work in MatrixOne, and we compared results of MatrixOne with other similar database products. Through the clear comparison of the bar chart, you will see that MatrixOne has an obvious advantage in the query processing time. Recommended server specification: x86 CPU with 16 cores and 64GB memory, with CentOS 7+ OS. note The following test results are the average of the three tests in seconds. In order to show the single-table query performance, we combine five tables into a flat table called lineorder_flat . Standalone node&Single table We use standalone service to execute flat table( lineorder_flat ) queries with MatrixOne, and compared the results with ClickHouse in the same configuration. The table lineorder_flat has 600 million rows data and takes up 220 GB of space. Info The following server was used: AMD EPYC\u2122 Rome CPU 2.6GHz/3.3GHz, 16 physical cores total, 32 GiB Memory. Query ID MatrixOne v0.2.0 ClickHouse v21.11.4.14 Q2 2.71 3.82 Q3.1 4.23 5.01 Q3.2 11.05 21.34 Q4.1 2.94 3.1 Q4.2 4.27 5.32 Q4.3 16.91 26.32 SUM 42.11 64.91 Standalone node&Multiple tables With a standalone server again, now we execute multiple tables queries on the original tables of SSB Test. There are 600 million rows of data in all, and the main table takes up 67 GB of space. Query ID MatrixOne v0.2.0 ClickHouse v21.11.4.14 Starrocks v1.19.3 Q2 13.6 28.05 15.83 Q3.1 12.94 27.81 16.98 Q3.2 23.56 54.84 29.25 Q4.1 13.96 27.2 16.77 Q4.2 19.72 41.82 21.54 Q4.3 46.07 85.99 35.95 SUM 129.85 265.71 136.37 Cluster&Multiple tables There are three nodes in the cluster, each of which is installed as standalone version, and process time is shorter than that of standclone node, demonstrating the overall performance will improve as the number of nodes increases. Query ID MatrixOne v0.2.0 Starrocks v1.19.3 Q2 4.94 6.08 Q3.1 5.85 6.27 Q3.2 9.67 9.79 Q4.1 6.05 6.87 Q4.2 6.87 9.51 Q4.3 20.1 15.55 SUM 53.48 54.07 Limitations We didn't finished all the queries of SSB Test in MatrixOne v0.2.0 because: The filter command WHERE is not supported The table cannot be partitioned currently, so commands as PARTITION series are not supported Learn More This page shows the results of SSB Test with MatrixOne. For information on other benchmarks that are available when trying out MatrixOne, see the following: NYC Test with MatrixOne NYC Test Performance","title":"SSB Test Performance"},{"location":"MatrixOne/Overview/SSB%20Test%20Performance/#ssb-test-performance","text":"","title":"SSB Test Performance"},{"location":"MatrixOne/Overview/SSB%20Test%20Performance/#overview","text":"We present the SSB Test results for MatrixOne with different hardwares and query modes. For instructions to reproduce the SSB test results listed here, see SSB Test with MatrixOne , and if you fail to achieve similar results, there is likely a problem in either the hardware, workload, or test design. In v0.2.0, both single table and multiple tables can work in MatrixOne, and we compared results of MatrixOne with other similar database products. Through the clear comparison of the bar chart, you will see that MatrixOne has an obvious advantage in the query processing time. Recommended server specification: x86 CPU with 16 cores and 64GB memory, with CentOS 7+ OS. note The following test results are the average of the three tests in seconds. In order to show the single-table query performance, we combine five tables into a flat table called lineorder_flat .","title":"Overview"},{"location":"MatrixOne/Overview/SSB%20Test%20Performance/#standalone-nodesingle-table","text":"We use standalone service to execute flat table( lineorder_flat ) queries with MatrixOne, and compared the results with ClickHouse in the same configuration. The table lineorder_flat has 600 million rows data and takes up 220 GB of space. Info The following server was used: AMD EPYC\u2122 Rome CPU 2.6GHz/3.3GHz, 16 physical cores total, 32 GiB Memory. Query ID MatrixOne v0.2.0 ClickHouse v21.11.4.14 Q2 2.71 3.82 Q3.1 4.23 5.01 Q3.2 11.05 21.34 Q4.1 2.94 3.1 Q4.2 4.27 5.32 Q4.3 16.91 26.32 SUM 42.11 64.91","title":"Standalone node&amp;Single table"},{"location":"MatrixOne/Overview/SSB%20Test%20Performance/#standalone-nodemultiple-tables","text":"With a standalone server again, now we execute multiple tables queries on the original tables of SSB Test. There are 600 million rows of data in all, and the main table takes up 67 GB of space. Query ID MatrixOne v0.2.0 ClickHouse v21.11.4.14 Starrocks v1.19.3 Q2 13.6 28.05 15.83 Q3.1 12.94 27.81 16.98 Q3.2 23.56 54.84 29.25 Q4.1 13.96 27.2 16.77 Q4.2 19.72 41.82 21.54 Q4.3 46.07 85.99 35.95 SUM 129.85 265.71 136.37","title":"Standalone node&amp;Multiple tables"},{"location":"MatrixOne/Overview/SSB%20Test%20Performance/#clustermultiple-tables","text":"There are three nodes in the cluster, each of which is installed as standalone version, and process time is shorter than that of standclone node, demonstrating the overall performance will improve as the number of nodes increases. Query ID MatrixOne v0.2.0 Starrocks v1.19.3 Q2 4.94 6.08 Q3.1 5.85 6.27 Q3.2 9.67 9.79 Q4.1 6.05 6.87 Q4.2 6.87 9.51 Q4.3 20.1 15.55 SUM 53.48 54.07","title":"Cluster&amp;Multiple tables"},{"location":"MatrixOne/Overview/SSB%20Test%20Performance/#limitations","text":"We didn't finished all the queries of SSB Test in MatrixOne v0.2.0 because: The filter command WHERE is not supported The table cannot be partitioned currently, so commands as PARTITION series are not supported","title":"Limitations"},{"location":"MatrixOne/Overview/SSB%20Test%20Performance/#learn-more","text":"This page shows the results of SSB Test with MatrixOne. For information on other benchmarks that are available when trying out MatrixOne, see the following: NYC Test with MatrixOne NYC Test Performance","title":"Learn More"},{"location":"MatrixOne/Overview/matrixone-architecture/","text":"MatrixOne Architecture Architecture MatrixOne is totally redesigned. It consists of multiple components and form a complete system. The architecture is as follows: Query Parser Layer Parser: Parses SQL, Streaming Query, or Python language into an abstract syntax tree for further processing. Planner: Finds the best execution plan through rule-based, cost-based optimization algorithms, and transfers the abstract syntax tree to plan tree. IR Generator: Converts Python code into an intermediate representation. Computation Layer JIT Compilation: Turns SQL plan tree or IR code into a native program using LLVM at runtime. Vectorized Execution: MatrixOne leverages SIMD instructions to construct vectorized execution pipelines. Cache: Multi-version cache of data, indexes, and metadata for queries. Cluster Management Layer (MatrixCube) MatrixCube is a fundamental library for building distributed systems. It guarantees reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers to focus on the business logic for a single node. MatrixCube is currently built upon multi-raft to provide replicated state machines and will migrate to Paxos families to increase friendliness to scenarios spanning multiple data centers. Prophet: Used by MatrixCube to manage and schedule the MatrixOne cluster. Transaction Manager: MatrixOne supports distributed transaction of snapshot isolation level. Replicated State Machine: MatrixOne uses RAFT-based consensus algorithms and hyper logic clocks to implement strong consistency of the clusters. Introduction of more advanced state-machine replication protocols is yet to come. Replicated Storage Layer Row Storage: Stores serving workload, metadata, and catalog. Column Storage: Stores analytical workload and materialized views. Storage Provision Layer As an infrastructure agnostic DBMS, MatrixOne stores data in shared storage of S3 / HDFS, or the local disk, on-premise server, hybrid and any cloud, or even smart devices. Learn More This page outlines the overall architecture design of MatrixOne. For information on other options that are available when trying out MatrixOne, see the following: MatrixOne Tech Design Install MatrixOne MySQL Compatibility What's New","title":"MatrixOne Architecture"},{"location":"MatrixOne/Overview/matrixone-architecture/#matrixone-architecture","text":"","title":"MatrixOne Architecture"},{"location":"MatrixOne/Overview/matrixone-architecture/#architecture","text":"MatrixOne is totally redesigned. It consists of multiple components and form a complete system. The architecture is as follows:","title":"Architecture"},{"location":"MatrixOne/Overview/matrixone-architecture/#query-parser-layer","text":"Parser: Parses SQL, Streaming Query, or Python language into an abstract syntax tree for further processing. Planner: Finds the best execution plan through rule-based, cost-based optimization algorithms, and transfers the abstract syntax tree to plan tree. IR Generator: Converts Python code into an intermediate representation.","title":"Query Parser Layer"},{"location":"MatrixOne/Overview/matrixone-architecture/#computation-layer","text":"JIT Compilation: Turns SQL plan tree or IR code into a native program using LLVM at runtime. Vectorized Execution: MatrixOne leverages SIMD instructions to construct vectorized execution pipelines. Cache: Multi-version cache of data, indexes, and metadata for queries.","title":"Computation Layer"},{"location":"MatrixOne/Overview/matrixone-architecture/#cluster-management-layer-matrixcube","text":"MatrixCube is a fundamental library for building distributed systems. It guarantees reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers to focus on the business logic for a single node. MatrixCube is currently built upon multi-raft to provide replicated state machines and will migrate to Paxos families to increase friendliness to scenarios spanning multiple data centers. Prophet: Used by MatrixCube to manage and schedule the MatrixOne cluster. Transaction Manager: MatrixOne supports distributed transaction of snapshot isolation level. Replicated State Machine: MatrixOne uses RAFT-based consensus algorithms and hyper logic clocks to implement strong consistency of the clusters. Introduction of more advanced state-machine replication protocols is yet to come.","title":"Cluster Management Layer (MatrixCube)"},{"location":"MatrixOne/Overview/matrixone-architecture/#replicated-storage-layer","text":"Row Storage: Stores serving workload, metadata, and catalog. Column Storage: Stores analytical workload and materialized views.","title":"Replicated Storage Layer"},{"location":"MatrixOne/Overview/matrixone-architecture/#storage-provision-layer","text":"As an infrastructure agnostic DBMS, MatrixOne stores data in shared storage of S3 / HDFS, or the local disk, on-premise server, hybrid and any cloud, or even smart devices.","title":"Storage Provision Layer"},{"location":"MatrixOne/Overview/matrixone-architecture/#learn-more","text":"This page outlines the overall architecture design of MatrixOne. For information on other options that are available when trying out MatrixOne, see the following: MatrixOne Tech Design Install MatrixOne MySQL Compatibility What's New","title":"Learn More"},{"location":"MatrixOne/Overview/matrixone-introduction/","text":"MatrixOne Introduction MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine working across multiple datacenters, clouds, edges and other heterogenous infrastructures. Key Features Hyperconverged Engine Monolithic Engine A monolithic database engine is designed to support hybrid workloads: transactional, analytical, streaming, time-series, machine learning, etc. Built-in Streaming Engine With the built-in streaming engine, MatrixOne supports in-database streaming processing by groundbreaking incremental materialized view maintenance. Cloud & Edge Native Real Infrastructure Agnostic MatrixOne supports seemless workload migration and bursting among different locations and infrastructures. Multi-site Active/Active MatrixOne provides industry-leading latency control with optimized consistency protocol. Extreme Performance High Performance Accelerated queries supported by patented vectorized execution as well as optimal computation push down strategies through factorization techniques. Strong Consistency MatrixOne introduces a global, high-performance distributed transaction protocol across storage engines. High Scalability Seamless and non-disruptive scaling by disaggregated storage and compute. User Values Simplify Database Management and Maintenance To solve the problem of high and unpredictable costs of database selection process, management & maintenance due to database overabundance, MatrixOne's all-in-one architecture will significantly simplify database management and maintenance, single database can serve multiple data applications. Reduce Data Fragmentation and Inconsistency Data flow and copy between different databases makes data sync and consistency increasingly difficult. The unified and incrementally materialized view of MatrixOne allows the downstream to support real-time upstream update, and achieve the end-to-end data processing without redundant ETL process. Decoupling Data Architecture From Infrastructure Currently the architecture design across different infrastructures is complicated, causing new data silos between cloud and edge, cloud and on-premise. MatrixOne is designed with a unified architecture to support simplified data management and operations across different types of infrastructures. Extremely Fast Complex Query Performance Poor business agility is a result of slow complex queries and redundant intermediate tables in current data warehousing solutions. MatrixOne supports blazing fast experience even for star and snowflake schema queries, improving business agility by real-time analytics. An Solid OLTP-like OLAP Experience Current data warehousing solutions have the following problems such as high latency and absence of immediate visibility for data updates. MatrixOne brings OLTP (Online Transactional Processing) level consistency and high availability to CRUD operations in OLAP (Online Analytical Processing). Seamless and Non-disruptive Scaling It is difficult to balance performance and scalability to achieve optimum price-performance ratio in current data warehousing solutions. MatrixOne's disaggregated storage and compute architecture makes it fully automated and efficient scale in/out and up/down without disrupting applications. Learn More This page outlines the overall introduction of MatrixOne. For information on other options that are available when you what to know more about MatrixOne product design, see the following: MatrixOne Architecture MatrixOne Tech Design","title":"MatrixOne Introduction"},{"location":"MatrixOne/Overview/matrixone-introduction/#matrixone-introduction","text":"MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine working across multiple datacenters, clouds, edges and other heterogenous infrastructures.","title":"MatrixOne Introduction"},{"location":"MatrixOne/Overview/matrixone-introduction/#key-features","text":"","title":"Key Features"},{"location":"MatrixOne/Overview/matrixone-introduction/#hyperconverged-engine","text":"Monolithic Engine A monolithic database engine is designed to support hybrid workloads: transactional, analytical, streaming, time-series, machine learning, etc. Built-in Streaming Engine With the built-in streaming engine, MatrixOne supports in-database streaming processing by groundbreaking incremental materialized view maintenance.","title":"Hyperconverged Engine"},{"location":"MatrixOne/Overview/matrixone-introduction/#cloud-edge-native","text":"Real Infrastructure Agnostic MatrixOne supports seemless workload migration and bursting among different locations and infrastructures. Multi-site Active/Active MatrixOne provides industry-leading latency control with optimized consistency protocol.","title":"Cloud &amp; Edge Native"},{"location":"MatrixOne/Overview/matrixone-introduction/#extreme-performance","text":"High Performance Accelerated queries supported by patented vectorized execution as well as optimal computation push down strategies through factorization techniques. Strong Consistency MatrixOne introduces a global, high-performance distributed transaction protocol across storage engines. High Scalability Seamless and non-disruptive scaling by disaggregated storage and compute.","title":"Extreme Performance"},{"location":"MatrixOne/Overview/matrixone-introduction/#user-values","text":"Simplify Database Management and Maintenance To solve the problem of high and unpredictable costs of database selection process, management & maintenance due to database overabundance, MatrixOne's all-in-one architecture will significantly simplify database management and maintenance, single database can serve multiple data applications. Reduce Data Fragmentation and Inconsistency Data flow and copy between different databases makes data sync and consistency increasingly difficult. The unified and incrementally materialized view of MatrixOne allows the downstream to support real-time upstream update, and achieve the end-to-end data processing without redundant ETL process. Decoupling Data Architecture From Infrastructure Currently the architecture design across different infrastructures is complicated, causing new data silos between cloud and edge, cloud and on-premise. MatrixOne is designed with a unified architecture to support simplified data management and operations across different types of infrastructures. Extremely Fast Complex Query Performance Poor business agility is a result of slow complex queries and redundant intermediate tables in current data warehousing solutions. MatrixOne supports blazing fast experience even for star and snowflake schema queries, improving business agility by real-time analytics. An Solid OLTP-like OLAP Experience Current data warehousing solutions have the following problems such as high latency and absence of immediate visibility for data updates. MatrixOne brings OLTP (Online Transactional Processing) level consistency and high availability to CRUD operations in OLAP (Online Analytical Processing). Seamless and Non-disruptive Scaling It is difficult to balance performance and scalability to achieve optimum price-performance ratio in current data warehousing solutions. MatrixOne's disaggregated storage and compute architecture makes it fully automated and efficient scale in/out and up/down without disrupting applications.","title":"User Values"},{"location":"MatrixOne/Overview/matrixone-introduction/#learn-more","text":"This page outlines the overall introduction of MatrixOne. For information on other options that are available when you what to know more about MatrixOne product design, see the following: MatrixOne Architecture MatrixOne Tech Design","title":"Learn More"},{"location":"MatrixOne/Overview/mysql-compatibility/","text":"MySQL Compatibility MatrixOne SQL syntax conforms with MySQL 8.0.23 version. SQL Type SQL Syntax Compability with MySQL8.0.23 DDL CREATE DATABASE A database with Chinese name will be displayed incorrectly. Names with Latins support limitedly. ENCRYPTION can be used but doesn't work till now. CREATE TABLE Temporary tables are not supported separately. Partition tables are not supported. Create table .. as clause is not supported now. All column level constraints are not supported now. DEFAULT can be supported now. For cluster table, there should be properties(\"bucket\"=\"n\") in the end of DDL. KEY(column) is not supported yet. CREATE other projects Not supported now. ALTER Not supported now. DROP DATABASE Same as MySQL. DROP TABLE Same as MySQL. Drop Other objects Only DROP INDEX is supported. DML INSERT LOW_PRIORITY, DELAYED, HIGH_PRIORITY are not supported now. Insert with select is not supported now. Batch Insert can be supported less than 5,000 rows. ON DUPLICATE KEY UPDATE is not supported now. DELAYED is not supported now. HAVING clause is not supported now. Names with Latins support limitedly. The current mode is just like only_full_group_by mode in MySQL. DELETE Not supported now. UPDATE Not supported now. SELECT Only INNER JOIN with GROUP BY and ORDER BY is supported in multi table scenarios. Table alias is not supported in INNER JOIN. Sub query is not supported now. Distinct is limitedly support. For clause is not supported now. INTO OUTFILE is limitedly support. LOAD DATA Only csv files can be loaded currently. The enclosed character should be \"\". FIELDS TERMINATED BY should be \",\" or \" LINES TERMINATED BY should be \"\\n\". SET is not supported now. Local key word is not supported now. Relative path is limited supported now. Only based on mo-server file can be supported. Database Administration Statements SHOW Only show tables and show databases are supported. Show CREATE TABLE and CREATE DATABASE are supported. Where can be supported limitedly. Other statements Not supported now. Utility Statements USE Use database is the same as MySQL. Explain The result of explain a SQL is quite different with MySQL. Other statements Not supported now. Data Types Int/Bigint/Smallint/Tinyint Same as MySQL. char/varchar Same as MySQL. Float/double The precision is a bit different with MySQL. It will be adjusted in future release. Date Only 'YYYY-MM-DD' and 'YYYYMMDD' formats are supported. Datetime Only 'YYYY-MM-DD HH:MM:SS' and 'YYYYMMDD HH:MM:SS' formats are supported. Other types Not supported now. Operators \"+\",\"-\",\"*\",\"/\" Same as MySQL. DIV, %, MOD Not supported now. LIKE Supported with constraints. IN Supported for constant lists NOT, AND, &&,OR, \"||\" Same as MySQL. XOR Not supported now. MAX, MIN, COUNT, AVG Same as MySQL. CAST Supported limitedly.","title":"MySQL Compatibility"},{"location":"MatrixOne/Overview/mysql-compatibility/#mysql-compatibility","text":"MatrixOne SQL syntax conforms with MySQL 8.0.23 version. SQL Type SQL Syntax Compability with MySQL8.0.23 DDL CREATE DATABASE A database with Chinese name will be displayed incorrectly. Names with Latins support limitedly. ENCRYPTION can be used but doesn't work till now. CREATE TABLE Temporary tables are not supported separately. Partition tables are not supported. Create table .. as clause is not supported now. All column level constraints are not supported now. DEFAULT can be supported now. For cluster table, there should be properties(\"bucket\"=\"n\") in the end of DDL. KEY(column) is not supported yet. CREATE other projects Not supported now. ALTER Not supported now. DROP DATABASE Same as MySQL. DROP TABLE Same as MySQL. Drop Other objects Only DROP INDEX is supported. DML INSERT LOW_PRIORITY, DELAYED, HIGH_PRIORITY are not supported now. Insert with select is not supported now. Batch Insert can be supported less than 5,000 rows. ON DUPLICATE KEY UPDATE is not supported now. DELAYED is not supported now. HAVING clause is not supported now. Names with Latins support limitedly. The current mode is just like only_full_group_by mode in MySQL. DELETE Not supported now. UPDATE Not supported now. SELECT Only INNER JOIN with GROUP BY and ORDER BY is supported in multi table scenarios. Table alias is not supported in INNER JOIN. Sub query is not supported now. Distinct is limitedly support. For clause is not supported now. INTO OUTFILE is limitedly support. LOAD DATA Only csv files can be loaded currently. The enclosed character should be \"\". FIELDS TERMINATED BY should be \",\" or \" LINES TERMINATED BY should be \"\\n\". SET is not supported now. Local key word is not supported now. Relative path is limited supported now. Only based on mo-server file can be supported. Database Administration Statements SHOW Only show tables and show databases are supported. Show CREATE TABLE and CREATE DATABASE are supported. Where can be supported limitedly. Other statements Not supported now. Utility Statements USE Use database is the same as MySQL. Explain The result of explain a SQL is quite different with MySQL. Other statements Not supported now. Data Types Int/Bigint/Smallint/Tinyint Same as MySQL. char/varchar Same as MySQL. Float/double The precision is a bit different with MySQL. It will be adjusted in future release. Date Only 'YYYY-MM-DD' and 'YYYYMMDD' formats are supported. Datetime Only 'YYYY-MM-DD HH:MM:SS' and 'YYYYMMDD HH:MM:SS' formats are supported. Other types Not supported now. Operators \"+\",\"-\",\"*\",\"/\" Same as MySQL. DIV, %, MOD Not supported now. LIKE Supported with constraints. IN Supported for constant lists NOT, AND, &&,OR, \"||\" Same as MySQL. XOR Not supported now. MAX, MIN, COUNT, AVG Same as MySQL. CAST Supported limitedly.","title":"MySQL Compatibility"},{"location":"MatrixOne/Overview/whats-new/","text":"What's New The lastest version of MatrixOne is 0.4.0, releases on 5th May, 2022. See the following: v0.4.0 Release Notes","title":"What's New"},{"location":"MatrixOne/Overview/whats-new/#whats-new","text":"The lastest version of MatrixOne is 0.4.0, releases on 5th May, 2022. See the following: v0.4.0 Release Notes","title":"What's New"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/","text":"MatrixOne Tech Design In MatrixOne Introduction we have introduced the key features and core concepts of MatrixOne and in MatrixOne Architecture we show you the overall architecture of MatrixOne. This chapter will unfold the architecture and explain about the tech design. MatrixOne Architectural Features The current design of MatrixOne is a combination of NewSQL and MPP, and we call it an HTAP DBMS with OLAP enhancement. Simplicity is the most important design principle for both usage, deployment and maintenance. Despite being a distributed database, MatrixOne only provides a single binary for deployment, with each node running exactly the same single process. NewSQL As we all know, relational databases have existed for more than 30 years with relational model , SQL , and transaction processing . NewSQL emerged recently. NewSQL refers to a distributed architecture starting with Google Spanner, using Replicate State Machine as the core to solve the scalability and high availability problems of traditional standalone relational databases. Replicate State Machine is the main method to implement fault-tolerant services. The state machine starts at a given initial state, and each input received is used by a state transition mechanism to generate a new state and corresponding output. In replicate state machines, the state machines of a set of servers compute copies of the same state and can continue to run even if a portion of the servers go down. In the context of replicate state machines, consistency protocols are proposed to ensure the consistency of replicate logs. Common consistency protocols include Paxos and Raft. In the architecture of replicate state machine, OLTP capability is realized by mounting the Key Value storage engine, which is the main design of NewSQL. The biggest difference between MatrixOne's design and other NewSQL databases is that the former one can mount various storage engines. In the 0.2 version, the Key-Value storage engine is mounted to store Catalog and other metadata and a column storage engine is mounted to provide OLAP capability. In fact, any storage engine can be mounted including but not limited to row storage, graph, time series, dedicated NoSQL and other multimodal engines. Different storage engines can be adapted for different scenarios. We welcome community developers to contribute ideas and code to this part. MPP MPP(Massively Parallel Processing) is a computing architecture that is used to analyze large-scale data. In simple terms, MPP is used to distribute tasks to multiple servers and nodes in parallel. After the computation is completed on each node, the results of each part are aggregated together to obtain the final result. This architecture was adopted by first-generation OLAP databases such as Teradata and Greenplum. MapReduce, the key component for Hadoop, also borrowed from the MPP architecture. However, between Hadoop and MPP OLAP databases, differences are obvious in the amount of data processed, SQL support, data processing types and efficiency. Hadoop is more like a data lake that can store and process hundreds of PB data, define schema when reading, and store a large amount of unstructured and semi-structured data. However, SQL support, query performance, and real-time streaming processing are not ideal. A database solution based on the MPP architecture is more like a relational database with substantially enhanced query capabilities, still with good SQL support and ACID transaction properties. The latest generation of open-source MPP compute engines includes: Clickhouse, Presto, Impala, SparkSQL, Apache Doris, etc. MatrixOne also provides great OLAP performance based on the MPP architecture. However, the MPP compute engine is different from other projects because it is based on Golang. When compared to C++ computing engines, it can compete in terms of performance. After acceleration through vectorization and factorization, it performs even better in scenarios such as non-primary key join, multi-table complex join, and other aspects. MatrixOne's Designed Modules and Current Progress MatrixOne is divided into SQL Frontend , Computing Layer , Metadata Layer , Distributed Framework and Storage Layer . SQL Frontend The entry of the MatrixOne. Currently MatrixOne provides MySQL compatibility protocol and support part of MySQL dialact. SQL Frontend receives requests from MySQL clients and pass to the next layer after parsing them. Learn more about MatrixOne MySQL Compatibility SQL Parser in Computing Layer After receiving a request from the SQL Frontend, SQL Parser parses it and transforms it into an abstract syntax tree (AST). MatrixOne doesn't use the popular open-source query parser, such as TiDB, Vitess parser, etc. In fact, TiDB parser was used in MatrixOne version 0.1, but we developed a new parser for version 0.2, because: MatrixOne intends to create a hyperconverged database where lots of custom syntax not necessarily consistent to MySQL. Currently, MatrixOne enhances more OLAP capabilities, whereas the current open-source parser is basically designed for OLTP scenarios, and has high performance overhead for some OLAP scenarios, such as mass insertion. MatrixOne also plans to offer multi-dialect protocol compatibility in the future, including PostgreSQL, Hive, ClickHouse and so on. Therefore, MatrixOne needs to own its own Query Parser, which can be customized arbitrarily, and provides the basis for multi-dialect syntactic compatibility. MPP SQL Execution in Computing Layer This part is the MPP compute engine established by Golang. The MatrixOne compute engine accelerates SQL excutions by vectorization acceleration. The vectorization is achieved by leveraging hardware features. At present, only the adaptation and acceleration of AVX2 and AVX512 instruction sets in Intel X86 architecture are realized. More hardware platform support for accleration can be an interesting subject for community participations. Another important design in compute engine is factorization, which breaks down the complex SQL join into an linear polynomial calculation, and significantly reduces the time consumed for complex join. Catalog as Metadata Layer It's the component that holds the overall metadata of the database, such as Table/Schema definitions. Currently, Catalog is still a temporary solution using Key-Value engine, and the subsequent Catalog will be migrated to a standard OLTP engine to provide further and more complete ACID capability to support the Catalog component. MatrixCube as Distributed Framework This component is a distributed infrastructure library that implements the NewSQL architecture and is currently a separate repository. It contains two parts of functionality. One is to provide the consensus protocol of the Replicate State Machine implementation, currently using Multi Raft mechanism. The other is to provide a replica scheduling mechanism based on Raft, which is called Prophet in the code. MatrixCube is a universal library that can interface with various storage engines, which is why we set it as a separate repository currently. Any third party developer can easily use it to implement distributed storage engines and databases with strong consistency. Another important functionality of MatrixCube is to provide distributed transaction capabilities, which is currently being designed and will soon be available for discussion by developers. Please refer to MatrixCube introduction for more details. Storage Engine In MatrixOne, the storage engine is selectable, and thus you can specify an engine to determine which one will be used to store data when creating tables with DDL syntax. In the current version, only one engine is implemented: AOE Engine(which stood for \"Analytics Optimized Engine\", evolving from \"Append Only Engine\", which is a column storage engine with \"Append Only\" mode. An evolution of AOE is called TAE(Transactional Analytical Engine) , a column-based HTAP Engine that provides complete ACID capability and powerful OLAP capability, and it's currently under development. When completed, MatrixOne will have complete distribution HTAP ability. Please refer to AOE Technical Design for more details. Another TPE(Transaction Processing Engine) is under development. TPE is designed to support catalog usage, for now, it will not provide transactional service for the external users. In the future, it's possible that TPE provides complete SQL capabilities externally. Learn More If you are interested in a particular module and would like to contribute, please refer to contribution guide to check out MatrixOne codebase structure.","title":"MatrixOne Modules"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#matrixone-tech-design","text":"In MatrixOne Introduction we have introduced the key features and core concepts of MatrixOne and in MatrixOne Architecture we show you the overall architecture of MatrixOne. This chapter will unfold the architecture and explain about the tech design.","title":"MatrixOne Tech Design"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#matrixone-architectural-features","text":"The current design of MatrixOne is a combination of NewSQL and MPP, and we call it an HTAP DBMS with OLAP enhancement. Simplicity is the most important design principle for both usage, deployment and maintenance. Despite being a distributed database, MatrixOne only provides a single binary for deployment, with each node running exactly the same single process.","title":"MatrixOne Architectural Features"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#newsql","text":"As we all know, relational databases have existed for more than 30 years with relational model , SQL , and transaction processing . NewSQL emerged recently. NewSQL refers to a distributed architecture starting with Google Spanner, using Replicate State Machine as the core to solve the scalability and high availability problems of traditional standalone relational databases. Replicate State Machine is the main method to implement fault-tolerant services. The state machine starts at a given initial state, and each input received is used by a state transition mechanism to generate a new state and corresponding output. In replicate state machines, the state machines of a set of servers compute copies of the same state and can continue to run even if a portion of the servers go down. In the context of replicate state machines, consistency protocols are proposed to ensure the consistency of replicate logs. Common consistency protocols include Paxos and Raft. In the architecture of replicate state machine, OLTP capability is realized by mounting the Key Value storage engine, which is the main design of NewSQL. The biggest difference between MatrixOne's design and other NewSQL databases is that the former one can mount various storage engines. In the 0.2 version, the Key-Value storage engine is mounted to store Catalog and other metadata and a column storage engine is mounted to provide OLAP capability. In fact, any storage engine can be mounted including but not limited to row storage, graph, time series, dedicated NoSQL and other multimodal engines. Different storage engines can be adapted for different scenarios. We welcome community developers to contribute ideas and code to this part.","title":"NewSQL"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#mpp","text":"MPP(Massively Parallel Processing) is a computing architecture that is used to analyze large-scale data. In simple terms, MPP is used to distribute tasks to multiple servers and nodes in parallel. After the computation is completed on each node, the results of each part are aggregated together to obtain the final result. This architecture was adopted by first-generation OLAP databases such as Teradata and Greenplum. MapReduce, the key component for Hadoop, also borrowed from the MPP architecture. However, between Hadoop and MPP OLAP databases, differences are obvious in the amount of data processed, SQL support, data processing types and efficiency. Hadoop is more like a data lake that can store and process hundreds of PB data, define schema when reading, and store a large amount of unstructured and semi-structured data. However, SQL support, query performance, and real-time streaming processing are not ideal. A database solution based on the MPP architecture is more like a relational database with substantially enhanced query capabilities, still with good SQL support and ACID transaction properties. The latest generation of open-source MPP compute engines includes: Clickhouse, Presto, Impala, SparkSQL, Apache Doris, etc. MatrixOne also provides great OLAP performance based on the MPP architecture. However, the MPP compute engine is different from other projects because it is based on Golang. When compared to C++ computing engines, it can compete in terms of performance. After acceleration through vectorization and factorization, it performs even better in scenarios such as non-primary key join, multi-table complex join, and other aspects.","title":"MPP"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#matrixones-designed-modules-and-current-progress","text":"MatrixOne is divided into SQL Frontend , Computing Layer , Metadata Layer , Distributed Framework and Storage Layer .","title":"MatrixOne's Designed Modules and Current Progress"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#sql-frontend","text":"The entry of the MatrixOne. Currently MatrixOne provides MySQL compatibility protocol and support part of MySQL dialact. SQL Frontend receives requests from MySQL clients and pass to the next layer after parsing them. Learn more about MatrixOne MySQL Compatibility","title":"SQL Frontend"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#sql-parser-in-computing-layer","text":"After receiving a request from the SQL Frontend, SQL Parser parses it and transforms it into an abstract syntax tree (AST). MatrixOne doesn't use the popular open-source query parser, such as TiDB, Vitess parser, etc. In fact, TiDB parser was used in MatrixOne version 0.1, but we developed a new parser for version 0.2, because: MatrixOne intends to create a hyperconverged database where lots of custom syntax not necessarily consistent to MySQL. Currently, MatrixOne enhances more OLAP capabilities, whereas the current open-source parser is basically designed for OLTP scenarios, and has high performance overhead for some OLAP scenarios, such as mass insertion. MatrixOne also plans to offer multi-dialect protocol compatibility in the future, including PostgreSQL, Hive, ClickHouse and so on. Therefore, MatrixOne needs to own its own Query Parser, which can be customized arbitrarily, and provides the basis for multi-dialect syntactic compatibility.","title":"SQL Parser in Computing Layer"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#mpp-sql-execution-in-computing-layer","text":"This part is the MPP compute engine established by Golang. The MatrixOne compute engine accelerates SQL excutions by vectorization acceleration. The vectorization is achieved by leveraging hardware features. At present, only the adaptation and acceleration of AVX2 and AVX512 instruction sets in Intel X86 architecture are realized. More hardware platform support for accleration can be an interesting subject for community participations. Another important design in compute engine is factorization, which breaks down the complex SQL join into an linear polynomial calculation, and significantly reduces the time consumed for complex join.","title":"MPP SQL Execution in Computing Layer"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#catalog-as-metadata-layer","text":"It's the component that holds the overall metadata of the database, such as Table/Schema definitions. Currently, Catalog is still a temporary solution using Key-Value engine, and the subsequent Catalog will be migrated to a standard OLTP engine to provide further and more complete ACID capability to support the Catalog component.","title":"Catalog as Metadata Layer"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#matrixcube-as-distributed-framework","text":"This component is a distributed infrastructure library that implements the NewSQL architecture and is currently a separate repository. It contains two parts of functionality. One is to provide the consensus protocol of the Replicate State Machine implementation, currently using Multi Raft mechanism. The other is to provide a replica scheduling mechanism based on Raft, which is called Prophet in the code. MatrixCube is a universal library that can interface with various storage engines, which is why we set it as a separate repository currently. Any third party developer can easily use it to implement distributed storage engines and databases with strong consistency. Another important functionality of MatrixCube is to provide distributed transaction capabilities, which is currently being designed and will soon be available for discussion by developers. Please refer to MatrixCube introduction for more details.","title":"MatrixCube as Distributed Framework"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#storage-engine","text":"In MatrixOne, the storage engine is selectable, and thus you can specify an engine to determine which one will be used to store data when creating tables with DDL syntax. In the current version, only one engine is implemented: AOE Engine(which stood for \"Analytics Optimized Engine\", evolving from \"Append Only Engine\", which is a column storage engine with \"Append Only\" mode. An evolution of AOE is called TAE(Transactional Analytical Engine) , a column-based HTAP Engine that provides complete ACID capability and powerful OLAP capability, and it's currently under development. When completed, MatrixOne will have complete distribution HTAP ability. Please refer to AOE Technical Design for more details. Another TPE(Transaction Processing Engine) is under development. TPE is designed to support catalog usage, for now, it will not provide transactional service for the external users. In the future, it's possible that TPE provides complete SQL capabilities externally.","title":"Storage Engine"},{"location":"MatrixOne/Overview/MatrixOne-Tech-Design/matrixone-techdesign/#learn-more","text":"If you are interested in a particular module and would like to contribute, please refer to contribution guide to check out MatrixOne codebase structure.","title":"Learn More"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/","text":"Auto-Rebalance & Scheduling MatrixCube is a framework used to implement distributed systems. For a distributed system, data is stored across many machines. When the number of machines changes, with cluster scaling out or machine crash for example, the data needs to be moved across machines. Prophet is the key component of MatrixCube for Auto-Rebalance and Scheduling. An Etcd Server is embedded inside Prophet for storing the metadata of the cluster. It has three main objectives: Keep the storage level of each Store balanced. Keep the write/read requests balanced. Keep the logical table distribution balanced. We designed a mechanism called Heartbeat and Event Notify to achieve these objectives. Each Store and Leader Replica will send Hearbeat information to Prophet . Prophet will make scheduling decision based on the information. We need to configure certain Store s to take over the duty of Prophet . Store Hearbeat Each Store sends Heartbeat periodically to Prophet , the Heartbeat includes: At the moment, how many Replicas are in this Store . At the moment, how much storage space does this Store have, how much space is already used, and how much space is remaining. The Prophet collects all Heartbeats , and the Prophet will understand a global Replica mapping and the storage space of each Store . Based on this information, the Prophet sends scheduling orders, moving some Replica s to proper Store s in order to balance the Replica numbers for each Store . Since each Replica of a Shard is the same size, the storage space is thus equalized. Replica Hearbeat For each Shard , it has several Replicas distributed in several Stores . These Replica s form a Raft-Group and a Leader is elected. This Leader sends periodic Heartbeats to Prophet . This Heartbeat has information such as: At the moment, how many Replicas a Shard has, and the latest active time of each Replica . At the moment, who is the Leader Replica . Prophet collects all Hearbeat s and constructs a global Shard Replica and Replica Leader mapping. With this information, Prophet launches scheduling orders under the following circumstances: Add Replica order: if the number of Shard Replica is not enough, look for appropriate Stores to add Replicas . Remove Replica order: if the number of Shard Replica exceeds the limit, delete Replicas in appropriate Stores . Move Replica order: if the number of Shard Replica is not balanced, some Replicas will be moved to achieve the balance. Transfer Leader order: if the Leader number is not balanced in the cluster, some Leaders will be transferred. Event Notify The Heartbeat information collected will be synchronized to all MatrixCube Stores . Each Store will form the global routing table.","title":"Auto Rebalancing and Scheduling"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/#auto-rebalance-scheduling","text":"MatrixCube is a framework used to implement distributed systems. For a distributed system, data is stored across many machines. When the number of machines changes, with cluster scaling out or machine crash for example, the data needs to be moved across machines. Prophet is the key component of MatrixCube for Auto-Rebalance and Scheduling. An Etcd Server is embedded inside Prophet for storing the metadata of the cluster. It has three main objectives: Keep the storage level of each Store balanced. Keep the write/read requests balanced. Keep the logical table distribution balanced. We designed a mechanism called Heartbeat and Event Notify to achieve these objectives. Each Store and Leader Replica will send Hearbeat information to Prophet . Prophet will make scheduling decision based on the information. We need to configure certain Store s to take over the duty of Prophet .","title":"Auto-Rebalance &amp; Scheduling"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/#store-hearbeat","text":"Each Store sends Heartbeat periodically to Prophet , the Heartbeat includes: At the moment, how many Replicas are in this Store . At the moment, how much storage space does this Store have, how much space is already used, and how much space is remaining. The Prophet collects all Heartbeats , and the Prophet will understand a global Replica mapping and the storage space of each Store . Based on this information, the Prophet sends scheduling orders, moving some Replica s to proper Store s in order to balance the Replica numbers for each Store . Since each Replica of a Shard is the same size, the storage space is thus equalized.","title":"Store Hearbeat"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/#replica-hearbeat","text":"For each Shard , it has several Replicas distributed in several Stores . These Replica s form a Raft-Group and a Leader is elected. This Leader sends periodic Heartbeats to Prophet . This Heartbeat has information such as: At the moment, how many Replicas a Shard has, and the latest active time of each Replica . At the moment, who is the Leader Replica . Prophet collects all Hearbeat s and constructs a global Shard Replica and Replica Leader mapping. With this information, Prophet launches scheduling orders under the following circumstances: Add Replica order: if the number of Shard Replica is not enough, look for appropriate Stores to add Replicas . Remove Replica order: if the number of Shard Replica exceeds the limit, delete Replicas in appropriate Stores . Move Replica order: if the number of Shard Replica is not balanced, some Replicas will be moved to achieve the balance. Transfer Leader order: if the Leader number is not balanced in the cluster, some Leaders will be transferred.","title":"Replica Hearbeat"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/#event-notify","text":"The Heartbeat information collected will be synchronized to all MatrixCube Stores . Each Store will form the global routing table.","title":"Event Notify"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/","text":"MatrixCube Introduction MatrixCube is a fundamental library for building distributed systems, which guarantees reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers to focus on the business logic for a single node. MatrixCube is currently built upon multi-raft to provide replicated state machine and will migrate to Paxos families to increase friendliness in scenarios spanning multiple data centers. Unlike many other distributed systems, MatrixCube is designed as part of the storage nodes. A matrixone distributed deployment does not have dedicated scheduling nodes. MatrixCube cannot work as a standalone module. MatrixCube Architecture Key Concepts There are several key concepts for understanding how MatrixCube works. Store A MatrixCube distributed system consists of several physical computers and our data is stored across these physical computers. We call each computer inside this cluster a Store . Shard Our data in the database is organized in tables logically. But for physical storage, the data is split into different partitions to store in order to get better scalability. Each partition is called a Shard . In our design, a new created table is initially a Shard . When the size of the table exceeds the Shard size limit, the Shard will split. Replica To provide reliable service, each Shard is stored not only once, but will have several copies stored in different Stores . We call each copy a Replica . A Shard can have multiple Replica , the data in each Replica are the same. Raft-group and Leader Since multiple Replicas are located in different Stores . Once a Replica is updated, the other Replicas must be updated to keep data consistency. When a client makes a query to any Replica , it always gets the same result. We deploy Raft protocol to implement the concensus process. The Replicas of a particular Shard group into a Raft-group . In each Raft-group , a Leader is elected to be the representative of this group. All consistent read and write requests are handled only by the leader. Learn more about: How does a Leader get elected in Raft? Data Storage A DataStorage is an interface for implementing distributed storage service. It must be defined prior to using MatrixCube. DataStorage needs to be implemented based on the characteristics of a storage engine. Some common distributed storage services can be easily constructed based on DataStorage , such as Distributed Redis , Distributed Key-Value , Distributed File System etc. A default Key-Value based DataStorage is provided to meet the requirements of most scenarios. Prophet Prophet is a scheduling module. It takes charge of Auto-Rebalance , which keeps the system storage level and read/write throughput level balanced across Stores . The inital 3 Stores of a MatrixCube cluster are all Prophet Nodes . Learn more about How does Prophet handle the scheduling? Raftstore Raftstore is the core component of MatrixCube, it implements the most important features of MatrixCube: Metadata storage: including the metadata of Store , Shard , Raft-log . Multi-Raft management: the relationship between Store , Shard , Replica , Raft-Group , the communication between multiple Raft-Group s, Leader election and re-election. Global Routing: a global routing table will be constructed with the Event Notify mechanism of Prophet . The read/write routing will be based on this routing table. Shard Proxy: a proxy for read/write request for Shard . With the proxy, the detailed implementation of Multi-Raft is senseless and all Store s are equal for users. The user can make requests to any Store . All requests will be routed to the right Store by Shard Proxy . Learn more about How do the Shard Proxy and Global Routing work? Key Features Strong Consistency MatrixCube provides a strong consistency. It is guaranteed that after any successful data write, the reading afterwards will get the latest value no matter from which store. Fault Tolerance The distributed storage service implemented by MatrixCube is a fault tolerant and highly available service. When a Shard has 2*N+1 Replicas , the system can still work until N+1 Replicas fail. For example, a cluster with 3 Stores can survive with 1 Store failure; a cluster with 5 Stores can survive with 2 Stores failure. Shard Splitting There is a certain limit to a Shard size. Whenever a Shard exceeds its storage limit, MatrixCube splits a Shard into two Shards , and keeps each Shard with the same storage level. You can checkout a more detailed descripition about this process with How does the Shard Splitting work? . Auto-Rebalance A distributed system should leverage all the computation power and storage of all nodes. For a MatrixCube cluster, when there is an increase or decrease of Stores , an Auto-Rebalance will occur, which moves data across Stores to reach balance for each single Store . Learn more about: How does the Auto-Rebalance work? . Scale-out With shard splitting and auto-rebalance, a MatrixCube distributed system is capable of scaling out. The cluster storage and throughput capability are proportional to the number of Stores . User-defined storage engine MatrixCube has no limit to standalone data storage engine. Any storage engine implementing DataStorage interface defined by MatrixCube could construct a MatrixCube-based distributed system. By default, MatrixCube provides a Pebble -based Key-Value storage engine. ( Pebble is a Go version of RocksDB ). User-defined Read/Write As a general distributed framework, different distributed storage systems could be built based on MatrixCube. A user can also customize their read/write commands. As long as it works in a standalone version, MatrixCube can help you upgrade it to a distributed version.","title":"MatrixCube Introduction"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#matrixcube-introduction","text":"MatrixCube is a fundamental library for building distributed systems, which guarantees reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers to focus on the business logic for a single node. MatrixCube is currently built upon multi-raft to provide replicated state machine and will migrate to Paxos families to increase friendliness in scenarios spanning multiple data centers. Unlike many other distributed systems, MatrixCube is designed as part of the storage nodes. A matrixone distributed deployment does not have dedicated scheduling nodes. MatrixCube cannot work as a standalone module.","title":"MatrixCube Introduction"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#matrixcube-architecture","text":"","title":"MatrixCube Architecture"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#key-concepts","text":"There are several key concepts for understanding how MatrixCube works.","title":"Key Concepts"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#store","text":"A MatrixCube distributed system consists of several physical computers and our data is stored across these physical computers. We call each computer inside this cluster a Store .","title":"Store"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#shard","text":"Our data in the database is organized in tables logically. But for physical storage, the data is split into different partitions to store in order to get better scalability. Each partition is called a Shard . In our design, a new created table is initially a Shard . When the size of the table exceeds the Shard size limit, the Shard will split.","title":"Shard"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#replica","text":"To provide reliable service, each Shard is stored not only once, but will have several copies stored in different Stores . We call each copy a Replica . A Shard can have multiple Replica , the data in each Replica are the same.","title":"Replica"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#raft-group-and-leader","text":"Since multiple Replicas are located in different Stores . Once a Replica is updated, the other Replicas must be updated to keep data consistency. When a client makes a query to any Replica , it always gets the same result. We deploy Raft protocol to implement the concensus process. The Replicas of a particular Shard group into a Raft-group . In each Raft-group , a Leader is elected to be the representative of this group. All consistent read and write requests are handled only by the leader. Learn more about: How does a Leader get elected in Raft?","title":"Raft-group and Leader"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#data-storage","text":"A DataStorage is an interface for implementing distributed storage service. It must be defined prior to using MatrixCube. DataStorage needs to be implemented based on the characteristics of a storage engine. Some common distributed storage services can be easily constructed based on DataStorage , such as Distributed Redis , Distributed Key-Value , Distributed File System etc. A default Key-Value based DataStorage is provided to meet the requirements of most scenarios.","title":"Data Storage"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#prophet","text":"Prophet is a scheduling module. It takes charge of Auto-Rebalance , which keeps the system storage level and read/write throughput level balanced across Stores . The inital 3 Stores of a MatrixCube cluster are all Prophet Nodes . Learn more about How does Prophet handle the scheduling?","title":"Prophet"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#raftstore","text":"Raftstore is the core component of MatrixCube, it implements the most important features of MatrixCube: Metadata storage: including the metadata of Store , Shard , Raft-log . Multi-Raft management: the relationship between Store , Shard , Replica , Raft-Group , the communication between multiple Raft-Group s, Leader election and re-election. Global Routing: a global routing table will be constructed with the Event Notify mechanism of Prophet . The read/write routing will be based on this routing table. Shard Proxy: a proxy for read/write request for Shard . With the proxy, the detailed implementation of Multi-Raft is senseless and all Store s are equal for users. The user can make requests to any Store . All requests will be routed to the right Store by Shard Proxy . Learn more about How do the Shard Proxy and Global Routing work?","title":"Raftstore"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#key-features","text":"","title":"Key Features"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#strong-consistency","text":"MatrixCube provides a strong consistency. It is guaranteed that after any successful data write, the reading afterwards will get the latest value no matter from which store.","title":"Strong Consistency"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#fault-tolerance","text":"The distributed storage service implemented by MatrixCube is a fault tolerant and highly available service. When a Shard has 2*N+1 Replicas , the system can still work until N+1 Replicas fail. For example, a cluster with 3 Stores can survive with 1 Store failure; a cluster with 5 Stores can survive with 2 Stores failure.","title":"Fault Tolerance"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#shard-splitting","text":"There is a certain limit to a Shard size. Whenever a Shard exceeds its storage limit, MatrixCube splits a Shard into two Shards , and keeps each Shard with the same storage level. You can checkout a more detailed descripition about this process with How does the Shard Splitting work? .","title":"Shard Splitting"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#auto-rebalance","text":"A distributed system should leverage all the computation power and storage of all nodes. For a MatrixCube cluster, when there is an increase or decrease of Stores , an Auto-Rebalance will occur, which moves data across Stores to reach balance for each single Store . Learn more about: How does the Auto-Rebalance work? .","title":"Auto-Rebalance"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#scale-out","text":"With shard splitting and auto-rebalance, a MatrixCube distributed system is capable of scaling out. The cluster storage and throughput capability are proportional to the number of Stores .","title":"Scale-out"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#user-defined-storage-engine","text":"MatrixCube has no limit to standalone data storage engine. Any storage engine implementing DataStorage interface defined by MatrixCube could construct a MatrixCube-based distributed system. By default, MatrixCube provides a Pebble -based Key-Value storage engine. ( Pebble is a Go version of RocksDB ).","title":"User-defined storage engine"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#user-defined-readwrite","text":"As a general distributed framework, different distributed storage systems could be built based on MatrixCube. A user can also customize their read/write commands. As long as it works in a standalone version, MatrixCube can help you upgrade it to a distributed version.","title":"User-defined Read/Write"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-proxy-routing/","text":"Shard Proxy and Global Routing A distributed system consists of multiple servers. A lot of complicated traffic and coordination mechanisms are implemented to make the data stored in all servers balanced and the service equally scaled. Users usually have little intention to understand the distributed detail. Therefore, we designed a Shard Proxy to achieve a simple user experience just like working with a standalone database.The Shard Proxy is a central module to accept all user read/write requests. For example, when a user is querying for a certain table from a database. For a distributed database system, this request is actually looking for a Shard in a ceratin Store . A user can send this request to any Store of the system. The Shard Proxy of the Store will take that request and it will look for the Global Routing table to find the correct Store . As we have explained in the Raft Group and Leader , Leader is the representative of a Raft Group . All read and write requests are handled only by the leader. Therefore, when a request for certain row is executed. First, we need to locate the Shard where these rows are stored. Second, locate the Leader Replica of this Shard group. Third, route the request to the Store where the Leader Replica is located. Finally, Leader Replica executes the request and returns response. Example We have a cluster of 3 Stores , and their status are as below: Range Store1 Store2 Store3 Shard1 [key1-key10) Leader Follower Follower Shard2 [key10-key20) Follower Leader Follower Shard3 [key20-key30) Follower Follower Leader A user sends requests on key1, key10 and key20, the following diagram illustrates how the requests gets through Shard Proxy and being routed.","title":"Shard Proxy and Routing"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-proxy-routing/#shard-proxy-and-global-routing","text":"A distributed system consists of multiple servers. A lot of complicated traffic and coordination mechanisms are implemented to make the data stored in all servers balanced and the service equally scaled. Users usually have little intention to understand the distributed detail. Therefore, we designed a Shard Proxy to achieve a simple user experience just like working with a standalone database.The Shard Proxy is a central module to accept all user read/write requests. For example, when a user is querying for a certain table from a database. For a distributed database system, this request is actually looking for a Shard in a ceratin Store . A user can send this request to any Store of the system. The Shard Proxy of the Store will take that request and it will look for the Global Routing table to find the correct Store . As we have explained in the Raft Group and Leader , Leader is the representative of a Raft Group . All read and write requests are handled only by the leader. Therefore, when a request for certain row is executed. First, we need to locate the Shard where these rows are stored. Second, locate the Leader Replica of this Shard group. Third, route the request to the Store where the Leader Replica is located. Finally, Leader Replica executes the request and returns response.","title":"Shard Proxy and Global Routing"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-proxy-routing/#example","text":"We have a cluster of 3 Stores , and their status are as below: Range Store1 Store2 Store3 Shard1 [key1-key10) Leader Follower Follower Shard2 [key10-key20) Follower Leader Follower Shard3 [key20-key30) Follower Follower Leader A user sends requests on key1, key10 and key20, the following diagram illustrates how the requests gets through Shard Proxy and being routed.","title":"Example"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-shard-splitting/","text":"Shard Splitting A Shard is a data partition, or a data slice. A distributed system ususally cuts a big data trunk to pieces, and places these pieces into different machines to increase the overall storage capability and handle greater workloads. A Shard will also have several Replicas to maintain a high availability. All these Replicas form a Raft-Group . In our design, a created new table is a Shard . A Shard has a certain size limit based on a user-defined parameter. As size of a table increases, it will exceed the size limit of a Shard . At that moment, a Shard Splitting will occur. The original Shard will be cut in into two Shards with each Shard having relatively equal storage level. In the meantime, all other Replicas of this Raft-Group will be splitted with the same behavior. The original Raft-Group will be removed, and two new Raft-Groups will be created . Once two new Raft-Groups are created, a re-election will immediately be held. In most cases, the original Replica leader will still be elected as leaders . The belowing diagram illustrates how the shard splitting works:","title":"Shard Splitting"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-shard-splitting/#shard-splitting","text":"A Shard is a data partition, or a data slice. A distributed system ususally cuts a big data trunk to pieces, and places these pieces into different machines to increase the overall storage capability and handle greater workloads. A Shard will also have several Replicas to maintain a high availability. All these Replicas form a Raft-Group . In our design, a created new table is a Shard . A Shard has a certain size limit based on a user-defined parameter. As size of a table increases, it will exceed the size limit of a Shard . At that moment, a Shard Splitting will occur. The original Shard will be cut in into two Shards with each Shard having relatively equal storage level. In the meantime, all other Replicas of this Raft-Group will be splitted with the same behavior. The original Raft-Group will be removed, and two new Raft-Groups will be created . Once two new Raft-Groups are created, a re-election will immediately be held. In most cases, the original Replica leader will still be elected as leaders . The belowing diagram illustrates how the shard splitting works:","title":"Shard Splitting"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-add/","text":"DATE_ADD() Description The DATE_ADD() function adds a time/date interval to a date and then returns the date. If date is NULL , the function returns NULL . Syntax > DATE_ADD(date,INTERVAL expr unit) Arguments Arguments Description date Required. The date/datetime to extract the date from. expr Required. The expr is an expression specifying the interval value to be added or subtracted from the starting date. The expr is evaluated as a string; it may start with a - for negative intervals. unit Required. The unit is a keyword indicating the units in which the expression should be interpreted. The unit argument can have the following values: MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUA TER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH Examples > create table t2 ( orderid int , productname varchar ( 20 ), orderdate datetime ); > insert into t2 values ( '1' , 'Jarl' , '2008-11-11 13:23:44.657' ); > SELECT OrderId , DATE_ADD ( OrderDate , INTERVAL 45 DAY ) AS OrderPayDate FROM t2 ; + ---------+---------------------+ | orderid | orderpaydate | + ---------+---------------------+ | 1 | 2008 - 12 - 26 13 : 23 : 44 | + ---------+---------------------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"DATE_ADD()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-add/#date_add","text":"","title":"DATE_ADD()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-add/#description","text":"The DATE_ADD() function adds a time/date interval to a date and then returns the date. If date is NULL , the function returns NULL .","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-add/#syntax","text":"> DATE_ADD(date,INTERVAL expr unit)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-add/#arguments","text":"Arguments Description date Required. The date/datetime to extract the date from. expr Required. The expr is an expression specifying the interval value to be added or subtracted from the starting date. The expr is evaluated as a string; it may start with a - for negative intervals. unit Required. The unit is a keyword indicating the units in which the expression should be interpreted. The unit argument can have the following values: MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUA TER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-add/#examples","text":"> create table t2 ( orderid int , productname varchar ( 20 ), orderdate datetime ); > insert into t2 values ( '1' , 'Jarl' , '2008-11-11 13:23:44.657' ); > SELECT OrderId , DATE_ADD ( OrderDate , INTERVAL 45 DAY ) AS OrderPayDate FROM t2 ; + ---------+---------------------+ | orderid | orderpaydate | + ---------+---------------------+ | 1 | 2008 - 12 - 26 13 : 23 : 44 | + ---------+---------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-add/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-sub/","text":"DATE_SUB() Description The DATE_SUB() function subtracts a time/date interval from a date and then returns the date. If date is NULL , the function returns NULL . Syntax DATE_SUB(date,INTERVAL expr unit) Arguments Arguments Description date Required. The date/datetime to extract the date from. expr Required. The expr is an expression specifying the interval value to be added or subtracted from the starting date. The expr is evaluated as a string; it may start with a - for negative intervals. unit Required. The unit is a keyword indicating the units in which the expression should be interpreted. The unit argument can have the following values: MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUA TER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH Examples > create table t2 ( orderid int , productname varchar ( 20 ), orderdate datetime ); > insert into t2 values ( '1' , 'Jarl' , '2008-11-11 13:23:44.657' ); > SELECT OrderId , DATE_SUB ( OrderDate , INTERVAL 5 DAY ) AS SubtractDate FROM t2 ; + ---------+---------------------+ | orderid | subtractdate | + ---------+---------------------+ | 1 | 2008 - 11 - 06 13 : 23 : 44 | + ---------+---------------------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"DATE_SUB()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-sub/#date_sub","text":"","title":"DATE_SUB()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-sub/#description","text":"The DATE_SUB() function subtracts a time/date interval from a date and then returns the date. If date is NULL , the function returns NULL .","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-sub/#syntax","text":"DATE_SUB(date,INTERVAL expr unit)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-sub/#arguments","text":"Arguments Description date Required. The date/datetime to extract the date from. expr Required. The expr is an expression specifying the interval value to be added or subtracted from the starting date. The expr is evaluated as a string; it may start with a - for negative intervals. unit Required. The unit is a keyword indicating the units in which the expression should be interpreted. The unit argument can have the following values: MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUA TER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-sub/#examples","text":"> create table t2 ( orderid int , productname varchar ( 20 ), orderdate datetime ); > insert into t2 values ( '1' , 'Jarl' , '2008-11-11 13:23:44.657' ); > SELECT OrderId , DATE_SUB ( OrderDate , INTERVAL 5 DAY ) AS SubtractDate FROM t2 ; + ---------+---------------------+ | orderid | subtractdate | + ---------+---------------------+ | 1 | 2008 - 11 - 06 13 : 23 : 44 | + ---------+---------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date-sub/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date/","text":"DATE() Description Extracts the date part of the date or datetime expression expr. Syntax > DATE(expr) Arguments Arguments Description expr Required. The date/datetime to extract the date from. Examples > drop table if exists t1 ; > create table t1 ( a date , b datetime ); > insert into t1 values ( '2022-01-01' , '2022-01-01 01:01:01' ); > insert into t1 values ( '2022-01-01' , '2022-01-01 01:01:01' ); > insert into t1 values ( 20220101 , '2022-01-01 01:01:01' ); > insert into t1 values ( '2022-01-02' , '2022-01-02 23:01:01' ); > insert into t1 values ( '2021-12-31' , '2021-12-30 23:59:59' ); > insert into t1 values ( '2022-06-30' , '2021-12-30 23:59:59' ); > select date ( a ), date ( b ) from t1 ; + ------------+------------+ | date ( a ) | date ( b ) | + ------------+------------+ | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 02 | 2022 - 01 - 02 | | 2021 - 12 - 31 | 2021 - 12 - 30 | | 2022 - 06 - 30 | 2021 - 12 - 30 | + ------------+------------+ > select date ( a ), date ( date ( a )) as dda from t1 ; + ------------+------------+ | date ( a ) | dda | + ------------+------------+ | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 02 | 2022 - 01 - 02 | | 2021 - 12 - 31 | 2021 - 12 - 31 | | 2022 - 06 - 30 | 2022 - 06 - 30 | + ------------+------------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"DATE()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date/#date","text":"","title":"DATE()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date/#description","text":"Extracts the date part of the date or datetime expression expr.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date/#syntax","text":"> DATE(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date/#arguments","text":"Arguments Description expr Required. The date/datetime to extract the date from.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date/#examples","text":"> drop table if exists t1 ; > create table t1 ( a date , b datetime ); > insert into t1 values ( '2022-01-01' , '2022-01-01 01:01:01' ); > insert into t1 values ( '2022-01-01' , '2022-01-01 01:01:01' ); > insert into t1 values ( 20220101 , '2022-01-01 01:01:01' ); > insert into t1 values ( '2022-01-02' , '2022-01-02 23:01:01' ); > insert into t1 values ( '2021-12-31' , '2021-12-30 23:59:59' ); > insert into t1 values ( '2022-06-30' , '2021-12-30 23:59:59' ); > select date ( a ), date ( b ) from t1 ; + ------------+------------+ | date ( a ) | date ( b ) | + ------------+------------+ | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 02 | 2022 - 01 - 02 | | 2021 - 12 - 31 | 2021 - 12 - 30 | | 2022 - 06 - 30 | 2021 - 12 - 30 | + ------------+------------+ > select date ( a ), date ( date ( a )) as dda from t1 ; + ------------+------------+ | date ( a ) | dda | + ------------+------------+ | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 | | 2022 - 01 - 02 | 2022 - 01 - 02 | | 2021 - 12 - 31 | 2021 - 12 - 31 | | 2022 - 06 - 30 | 2022 - 06 - 30 | + ------------+------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/date/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/dayofyear/","text":"DAYOFYEAR() Description Returns the day of the year for date, in the range 1 to 366. Syntax > DAYOFYEAR(expr) Arguments Arguments Description expr Required. The date to get the day from. Must be date type. Examples > drop table if exists t1 ; > create table t1 ( a date , b datetime , c varchar ( 30 )); > insert into t1 values ( '2022-01-01' , '2022-01-01 01:01:01' , '2022-01-01 01:01:01' ); > insert into t1 values ( '2022-01-01' , '2022-01-01 01:01:01' , '2022-01-01 01:01:01' ); > insert into t1 values ( 20220101 , '2022-01-01 01:01:01' , '2022-13-13 01:01:01' ); > insert into t1 values ( '2022-01-02' , '2022-01-02 23:01:01' , '2022-01-01 23:01:01' ); > insert into t1 values ( '2021-12-31' , '2021-12-30 23:59:59' , '2021-12-30 23:59:59' ); > insert into t1 values ( '2022-06-30' , '2021-12-30 23:59:59' , '2021-12-30 23:59:59' ); > select distinct dayofyear ( a ) as dya from t1 ; + ------+ | dya | + ------+ | 1 | | 2 | | 365 | | 181 | + ------+ > select * from t1 where dayofyear ( a ) > 120 ; + ------------+---------------------+---------------------+ | a | b | c | + ------------+---------------------+---------------------+ | 2021 - 12 - 31 | 2021 - 12 - 30 23 : 59 : 59 | 2021 - 12 - 30 23 : 59 : 59 | | 2022 - 06 - 30 | 2021 - 12 - 30 23 : 59 : 59 | 2021 - 12 - 30 23 : 59 : 59 | + ------------+---------------------+---------------------+ > select * from t1 where dayofyear ( a ) between 1 and 184 ; + ------------+---------------------+---------------------+ | a | b | c | + ------------+---------------------+---------------------+ | 2022 - 01 - 01 | 2022 - 01 - 01 01 : 01 : 01 | 2022 - 01 - 01 01 : 01 : 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 01 : 01 : 01 | 2022 - 01 - 01 01 : 01 : 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 01 : 01 : 01 | 2022 - 13 - 13 01 : 01 : 01 | | 2022 - 01 - 02 | 2022 - 01 - 02 23 : 01 : 01 | 2022 - 01 - 01 23 : 01 : 01 | | 2022 - 06 - 30 | 2021 - 12 - 30 23 : 59 : 59 | 2021 - 12 - 30 23 : 59 : 59 | + ------------+---------------------+---------------------+ Constraints DAYOFYEAR() only supports date type for now. The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"DAYOFYEAR()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/dayofyear/#dayofyear","text":"","title":"DAYOFYEAR()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/dayofyear/#description","text":"Returns the day of the year for date, in the range 1 to 366.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/dayofyear/#syntax","text":"> DAYOFYEAR(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/dayofyear/#arguments","text":"Arguments Description expr Required. The date to get the day from. Must be date type.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/dayofyear/#examples","text":"> drop table if exists t1 ; > create table t1 ( a date , b datetime , c varchar ( 30 )); > insert into t1 values ( '2022-01-01' , '2022-01-01 01:01:01' , '2022-01-01 01:01:01' ); > insert into t1 values ( '2022-01-01' , '2022-01-01 01:01:01' , '2022-01-01 01:01:01' ); > insert into t1 values ( 20220101 , '2022-01-01 01:01:01' , '2022-13-13 01:01:01' ); > insert into t1 values ( '2022-01-02' , '2022-01-02 23:01:01' , '2022-01-01 23:01:01' ); > insert into t1 values ( '2021-12-31' , '2021-12-30 23:59:59' , '2021-12-30 23:59:59' ); > insert into t1 values ( '2022-06-30' , '2021-12-30 23:59:59' , '2021-12-30 23:59:59' ); > select distinct dayofyear ( a ) as dya from t1 ; + ------+ | dya | + ------+ | 1 | | 2 | | 365 | | 181 | + ------+ > select * from t1 where dayofyear ( a ) > 120 ; + ------------+---------------------+---------------------+ | a | b | c | + ------------+---------------------+---------------------+ | 2021 - 12 - 31 | 2021 - 12 - 30 23 : 59 : 59 | 2021 - 12 - 30 23 : 59 : 59 | | 2022 - 06 - 30 | 2021 - 12 - 30 23 : 59 : 59 | 2021 - 12 - 30 23 : 59 : 59 | + ------------+---------------------+---------------------+ > select * from t1 where dayofyear ( a ) between 1 and 184 ; + ------------+---------------------+---------------------+ | a | b | c | + ------------+---------------------+---------------------+ | 2022 - 01 - 01 | 2022 - 01 - 01 01 : 01 : 01 | 2022 - 01 - 01 01 : 01 : 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 01 : 01 : 01 | 2022 - 01 - 01 01 : 01 : 01 | | 2022 - 01 - 01 | 2022 - 01 - 01 01 : 01 : 01 | 2022 - 13 - 13 01 : 01 : 01 | | 2022 - 01 - 02 | 2022 - 01 - 02 23 : 01 : 01 | 2022 - 01 - 01 23 : 01 : 01 | | 2022 - 06 - 30 | 2021 - 12 - 30 23 : 59 : 59 | 2021 - 12 - 30 23 : 59 : 59 | + ------------+---------------------+---------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/dayofyear/#constraints","text":"DAYOFYEAR() only supports date type for now. The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/extract/","text":"EXTRACT() Description The EXTRACT() function uses the same kinds of unit specifiers as DATE_ADD() or DATE_SUB() , but extracts parts from the date rather than performing date arithmetic. Returns NULL if date is NULL . Syntax > EXTRACT(unit FROM date) Arguments Arguments Description date Required. The date/datetime to extract the date from. unit Required. The unit argument can have the following values: MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUA TER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH Examples > create table t2 ( orderid int , productname varchar ( 20 ), orderdate datetime ); > insert into t2 values ( '1' , 'Jarl' , '2008-11-11 13:23:44.657' ); > SELECT EXTRACT ( YEAR FROM OrderDate ) AS OrderYear , EXTRACT ( MONTH FROM OrderDate ) AS OrderMonth FROM t2 WHERE OrderId = 1 ; + -----------+------------+ | orderyear | ordermonth | + -----------+------------+ | 2008 | 11 | + -----------+------------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"EXTRACT()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/extract/#extract","text":"","title":"EXTRACT()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/extract/#description","text":"The EXTRACT() function uses the same kinds of unit specifiers as DATE_ADD() or DATE_SUB() , but extracts parts from the date rather than performing date arithmetic. Returns NULL if date is NULL .","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/extract/#syntax","text":"> EXTRACT(unit FROM date)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/extract/#arguments","text":"Arguments Description date Required. The date/datetime to extract the date from. unit Required. The unit argument can have the following values: MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUA TER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/extract/#examples","text":"> create table t2 ( orderid int , productname varchar ( 20 ), orderdate datetime ); > insert into t2 values ( '1' , 'Jarl' , '2008-11-11 13:23:44.657' ); > SELECT EXTRACT ( YEAR FROM OrderDate ) AS OrderYear , EXTRACT ( MONTH FROM OrderDate ) AS OrderMonth FROM t2 WHERE OrderId = 1 ; + -----------+------------+ | orderyear | ordermonth | + -----------+------------+ | 2008 | 11 | + -----------+------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/extract/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/from-unixtime/","text":"FROM_UNIXTIME() Description The FROM_UNIXTIME() function returns a representation of unix_timestamp as a datetime or character string value. The value returned is expressed using the session time zone. For example, the return value is in \u2018YYYYY-MM-DD HH:MM:SS\u2019 format or YYYYMMDDHHMMSS. unix_timestamp is an internal timestamp value representing seconds since 1970-01-01 00:00:00 UTC, such as produced by the UNIX_TIMESTAMP() function. Syntax > FROM_UNIXTIME(unix_timestamp[,format]) Arguments Arguments Description format Optional. A format string indicating the format of the return value. If the format is omitted, this function returns a DATETIME value. If the format is NULL , this function returns NULL . If the format is supplied, the value returned is a VARCHAR. unix_timestamp Required. If the unix_timestamp is NULL , this function returns NULL . If the unix_timestamp is an integer , the fractional seconds precision of the DATETIME is zero. When unix_timestamp is a decimal value, the fractional seconds precision of the DATETIME is the same as the precision of the decimal value, up to a maximum of 6. When unix_timestamp is a floating point number, the fractional seconds precision of the datetime is 6. Examples > select from_unixtime ( 1459338786 ); + ---------------------------+ | from_unixtime ( 1459338786 ) | + ---------------------------+ | 2016 - 03 - 30 11 : 53 : 06 | + ---------------------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"FROM_UNIXTIME"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/from-unixtime/#from_unixtime","text":"","title":"FROM_UNIXTIME()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/from-unixtime/#description","text":"The FROM_UNIXTIME() function returns a representation of unix_timestamp as a datetime or character string value. The value returned is expressed using the session time zone. For example, the return value is in \u2018YYYYY-MM-DD HH:MM:SS\u2019 format or YYYYMMDDHHMMSS. unix_timestamp is an internal timestamp value representing seconds since 1970-01-01 00:00:00 UTC, such as produced by the UNIX_TIMESTAMP() function.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/from-unixtime/#syntax","text":"> FROM_UNIXTIME(unix_timestamp[,format])","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/from-unixtime/#arguments","text":"Arguments Description format Optional. A format string indicating the format of the return value. If the format is omitted, this function returns a DATETIME value. If the format is NULL , this function returns NULL . If the format is supplied, the value returned is a VARCHAR. unix_timestamp Required. If the unix_timestamp is NULL , this function returns NULL . If the unix_timestamp is an integer , the fractional seconds precision of the DATETIME is zero. When unix_timestamp is a decimal value, the fractional seconds precision of the DATETIME is the same as the precision of the decimal value, up to a maximum of 6. When unix_timestamp is a floating point number, the fractional seconds precision of the datetime is 6.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/from-unixtime/#examples","text":"> select from_unixtime ( 1459338786 ); + ---------------------------+ | from_unixtime ( 1459338786 ) | + ---------------------------+ | 2016 - 03 - 30 11 : 53 : 06 | + ---------------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/from-unixtime/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/month/","text":"MONTH() Description The MONTH() function returns the month part for a given date (a number from 1 to 12). Syntax > MONTH(date) Arguments Arguments Description date Required. The date/datetime to extract the month from Examples > drop table if exists t1 ; > create table t1 ( a date , b datetime ); > insert into t1 values ( '20211223' , '2021-10-22 09:23:23' ); > insert into t1 values ( '2021-12-23' , '2021-10-22 00:23:23' ); > select month ( a ) from t1 ; + ----------+----------+ | month ( a ) | month ( b ) | + ----------+----------+ | 12 | 10 | | 12 | 10 | + ----------+----------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"MONTH()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/month/#month","text":"","title":"MONTH()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/month/#description","text":"The MONTH() function returns the month part for a given date (a number from 1 to 12).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/month/#syntax","text":"> MONTH(date)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/month/#arguments","text":"Arguments Description date Required. The date/datetime to extract the month from","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/month/#examples","text":"> drop table if exists t1 ; > create table t1 ( a date , b datetime ); > insert into t1 values ( '20211223' , '2021-10-22 09:23:23' ); > insert into t1 values ( '2021-12-23' , '2021-10-22 00:23:23' ); > select month ( a ) from t1 ; + ----------+----------+ | month ( a ) | month ( b ) | + ----------+----------+ | 12 | 10 | | 12 | 10 | + ----------+----------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/month/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/to-date/","text":"TO_DATE() Description STR_TO_DATE() returns a DATETIME value if the format string contains both date and time parts, or a DATE or TIME value if the string contains only date or time parts. Syntax > TO_DATE(str,format) Arguments Arguments Description str Required. If the date, time, or datetime value extracted from str is illegal, STR_TO_DATE() returns NULL and produces a warning. If str is NULL , the function returns NULL . format Required. A format string indicating the format of the return value. If the format is omitted, this function returns a DATETIME value. If the format is NULL , this function returns NULL . If the format is supplied, the value returned is a VARCHAR. note The format string can contain literal characters and format specifiers beginning with %. Literal characters in format must match literally in str. Format specifiers in format must match a date or time part in str . Examples > SELECT TO_DATE ( '2022-01-06 10:20:30' , '%Y-%m-%d %H:%i:%s' ) as result ; + ---------------------+ | result | + ---------------------+ | 2022 - 01 - 06 10 : 20 : 30 | + ---------------------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"TO_DATE()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/to-date/#to_date","text":"","title":"TO_DATE()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/to-date/#description","text":"STR_TO_DATE() returns a DATETIME value if the format string contains both date and time parts, or a DATE or TIME value if the string contains only date or time parts.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/to-date/#syntax","text":"> TO_DATE(str,format)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/to-date/#arguments","text":"Arguments Description str Required. If the date, time, or datetime value extracted from str is illegal, STR_TO_DATE() returns NULL and produces a warning. If str is NULL , the function returns NULL . format Required. A format string indicating the format of the return value. If the format is omitted, this function returns a DATETIME value. If the format is NULL , this function returns NULL . If the format is supplied, the value returned is a VARCHAR. note The format string can contain literal characters and format specifiers beginning with %. Literal characters in format must match literally in str. Format specifiers in format must match a date or time part in str .","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/to-date/#examples","text":"> SELECT TO_DATE ( '2022-01-06 10:20:30' , '%Y-%m-%d %H:%i:%s' ) as result ; + ---------------------+ | result | + ---------------------+ | 2022 - 01 - 06 10 : 20 : 30 | + ---------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/to-date/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/unix-timestamp/","text":"UNIX_TIMESTAMP() Description If UNIX_TIMESTAMP() is called with no date argument, it returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC. If UNIX_TIMESTAMP() is called with a date argument, it returns the value of the argument as seconds since '1970-01-01 00:00:00' UTC. The server interprets date as a value in the session time zone and converts it to an internal Unix timestamp value in UTC. If you pass an out-of-range date to UNIX_TIMESTAMP(), it returns 0. If date is NULL , it returns NULL . The return value is an integer if no argument is given or the argument does not include a fractional seconds part, or DECIMAL if an argument is given that includes a fractional seconds part. Syntax > UNIX_TIMESTAMP([date]) Arguments Arguments Description date Optional. The date/datetime to extract the date from. The date argument may be a DATE, DATETIME, or TIMESTAMP string, or a number in YYMMDD, YYMMDDhhmmss, YYYYMMDD, or YYYYMMDDhhmmss format. If the argument includes a time part, it may optionally include a fractional seconds part. When the date argument is a TIMESTAMP column, UNIX_TIMESTAMP() returns the internal timestamp value directly, with no implicit string-to-Unix-timestamp conversion. Examples > SELECT UNIX_TIMESTAMP ( \"2016-07-11\" ); + ----------------------------+ | unix_timestamp ( 2016 - 07 - 11 ) | + ----------------------------+ | 1468195200 | + ----------------------------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"UNIX_TIMESTAMP"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/unix-timestamp/#unix_timestamp","text":"","title":"UNIX_TIMESTAMP()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/unix-timestamp/#description","text":"If UNIX_TIMESTAMP() is called with no date argument, it returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC. If UNIX_TIMESTAMP() is called with a date argument, it returns the value of the argument as seconds since '1970-01-01 00:00:00' UTC. The server interprets date as a value in the session time zone and converts it to an internal Unix timestamp value in UTC. If you pass an out-of-range date to UNIX_TIMESTAMP(), it returns 0. If date is NULL , it returns NULL . The return value is an integer if no argument is given or the argument does not include a fractional seconds part, or DECIMAL if an argument is given that includes a fractional seconds part.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/unix-timestamp/#syntax","text":"> UNIX_TIMESTAMP([date])","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/unix-timestamp/#arguments","text":"Arguments Description date Optional. The date/datetime to extract the date from. The date argument may be a DATE, DATETIME, or TIMESTAMP string, or a number in YYMMDD, YYMMDDhhmmss, YYYYMMDD, or YYYYMMDDhhmmss format. If the argument includes a time part, it may optionally include a fractional seconds part. When the date argument is a TIMESTAMP column, UNIX_TIMESTAMP() returns the internal timestamp value directly, with no implicit string-to-Unix-timestamp conversion.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/unix-timestamp/#examples","text":"> SELECT UNIX_TIMESTAMP ( \"2016-07-11\" ); + ----------------------------+ | unix_timestamp ( 2016 - 07 - 11 ) | + ----------------------------+ | 1468195200 | + ----------------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/unix-timestamp/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/utc-timestamp/","text":"UTC_TIMESTAMP() Description Returns the current UTC date and time as a value in 'YYYY-MM-DD hh:mm:ss' or YYYYMMDDhhmmss format, depending on whether the function is used in string or numeric context. Syntax > UTC_TIMESTAMP() Examples > SELECT UTC_TIMESTAMP (); + ---------------------+ | utc_timestamp () | + ---------------------+ | 2022 - 06 - 22 22 : 31 : 13 | + ---------------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"UTC_TIMESTAMP()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/utc-timestamp/#utc_timestamp","text":"","title":"UTC_TIMESTAMP()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/utc-timestamp/#description","text":"Returns the current UTC date and time as a value in 'YYYY-MM-DD hh:mm:ss' or YYYYMMDDhhmmss format, depending on whether the function is used in string or numeric context.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/utc-timestamp/#syntax","text":"> UTC_TIMESTAMP()","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/utc-timestamp/#examples","text":"> SELECT UTC_TIMESTAMP (); + ---------------------+ | utc_timestamp () | + ---------------------+ | 2022 - 06 - 22 22 : 31 : 13 | + ---------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/utc-timestamp/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/weekday/","text":"WEEKDAY() Description This function returns the weekday index for date (0 = Monday, 1 = Tuesday, \u2026 6 = Sunday). Syntax > WEEKDAY(date) Arguments Arguments Description date Required. Examples > drop table if exists t1 ; > create table t1 ( a date , b datetime ); > insert into t1 values ( '20220202' , '2021-12-24 09:23:23' ); > insert into t1 values ( '2022-02-02' , '2021-12-24' ); > select weekday ( a ), weekday ( b ) from t1 ; + ------------+------------+ | weekday ( a ) | weekday ( b ) | + ------------+------------+ | 2 | 4 | | 2 | 4 | + ------------+------------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"WEEKDAY()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/weekday/#weekday","text":"","title":"WEEKDAY()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/weekday/#description","text":"This function returns the weekday index for date (0 = Monday, 1 = Tuesday, \u2026 6 = Sunday).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/weekday/#syntax","text":"> WEEKDAY(date)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/weekday/#arguments","text":"Arguments Description date Required.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/weekday/#examples","text":"> drop table if exists t1 ; > create table t1 ( a date , b datetime ); > insert into t1 values ( '20220202' , '2021-12-24 09:23:23' ); > insert into t1 values ( '2022-02-02' , '2021-12-24' ); > select weekday ( a ), weekday ( b ) from t1 ; + ------------+------------+ | weekday ( a ) | weekday ( b ) | + ------------+------------+ | 2 | 4 | | 2 | 4 | + ------------+------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/weekday/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/year/","text":"YEAR() Description The YEAR() or TOYEAR() function returns the year part for a given date (a number from 1000 to 9999). Syntax > YEAR(date) > TOYEAR(date) Arguments Arguments Description date Required. The date/datetime to extract the year from Examples > drop table if exists t1 ; > create table t1 ( a date , b datetime ); > insert into t1 values ( '20211223' , '2021-10-22 09:23:23' ); > insert into t1 values ( '2021-12-23' , '2021-10-22 00:23:23' ); > select year ( a ), toyear ( b ) from t1 ; + ---------+-----------+ | year ( a ) | toyear ( b ) | + ---------+-----------+ | 2021 | 2021 | | 2021 | 2021 | + ---------+-----------+ Constraints The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"YEAR()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/year/#year","text":"","title":"YEAR()"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/year/#description","text":"The YEAR() or TOYEAR() function returns the year part for a given date (a number from 1000 to 9999).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/year/#syntax","text":"> YEAR(date) > TOYEAR(date)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/year/#arguments","text":"Arguments Description date Required. The date/datetime to extract the year from","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/year/#examples","text":"> drop table if exists t1 ; > create table t1 ( a date , b datetime ); > insert into t1 values ( '20211223' , '2021-10-22 09:23:23' ); > insert into t1 values ( '2021-12-23' , '2021-10-22 00:23:23' ); > select year ( a ), toyear ( b ) from t1 ; + ---------+-----------+ | year ( a ) | toyear ( b ) | + ---------+-----------+ | 2021 | 2021 | | 2021 | 2021 | + ---------+-----------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Datetime/year/#constraints","text":"The date type supports only yyyy-mm-dd and yyyymmdd for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/abs/","text":"ABS() Description ABS(X) Returns the absolute value of X, or NULL if X is NULL. Syntax > ABS(number) Arguments Arguments Description number Required. Any numeric data type supported now. The result type is derived from the argument type. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , - 3 . 1416 ); > insert into t1 values ( - 1 , 1 . 57 ); > select abs ( a ), abs ( b ) from t1 ; + --------+--------+ | abs ( a ) | abs ( b ) | + --------+--------+ | 1 | 3 . 1416 | | 1 | 1 . 5700 | + --------+--------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"ABS()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/abs/#abs","text":"","title":"ABS()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/abs/#description","text":"ABS(X) Returns the absolute value of X, or NULL if X is NULL.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/abs/#syntax","text":"> ABS(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/abs/#arguments","text":"Arguments Description number Required. Any numeric data type supported now. The result type is derived from the argument type.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/abs/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , - 3 . 1416 ); > insert into t1 values ( - 1 , 1 . 57 ); > select abs ( a ), abs ( b ) from t1 ; + --------+--------+ | abs ( a ) | abs ( b ) | + --------+--------+ | 1 | 3 . 1416 | | 1 | 1 . 5700 | + --------+--------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/abs/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/acos/","text":"ACOS() Description The ACOS() function returns the arccosine(given in radians) of the input number. Syntax > ACOS(number) Arguments Arguments Description number Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a float , b int ); > insert into t1 values ( 0 . 5 , 1 ); > insert into t1 values ( - 0 . 5 , - 1 ); > select acos ( a ), acos ( b ) from t1 ; + ---------+---------+ | acos ( a ) | acos ( b ) | + ---------+---------+ | 1 . 0472 | 0 . 0000 | | 2 . 0944 | 3 . 1416 | + ---------+---------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"ACOS()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/acos/#acos","text":"","title":"ACOS()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/acos/#description","text":"The ACOS() function returns the arccosine(given in radians) of the input number.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/acos/#syntax","text":"> ACOS(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/acos/#arguments","text":"Arguments Description number Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/acos/#examples","text":"> drop table if exists t1 ; > create table t1 ( a float , b int ); > insert into t1 values ( 0 . 5 , 1 ); > insert into t1 values ( - 0 . 5 , - 1 ); > select acos ( a ), acos ( b ) from t1 ; + ---------+---------+ | acos ( a ) | acos ( b ) | + ---------+---------+ | 1 . 0472 | 0 . 0000 | | 2 . 0944 | 3 . 1416 | + ---------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/acos/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/atan/","text":"ATAN() Description The ATAN() function returns the arctangent(given in radians) of the input number. Syntax > ATAN(number) Arguments Arguments Description number Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( 0 , 1 ); > select atan ( a ), atan ( tan ( b )) from t1 ; + ---------+--------------+ | atan ( a ) | atan ( tan ( b )) | + ---------+--------------+ | 0 . 7854 | - 0 . 0000 | | 0 . 0000 | 1 . 0000 | + ---------+--------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"ATAN()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/atan/#atan","text":"","title":"ATAN()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/atan/#description","text":"The ATAN() function returns the arctangent(given in radians) of the input number.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/atan/#syntax","text":"> ATAN(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/atan/#arguments","text":"Arguments Description number Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/atan/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( 0 , 1 ); > select atan ( a ), atan ( tan ( b )) from t1 ; + ---------+--------------+ | atan ( a ) | atan ( tan ( b )) | + ---------+--------------+ | 0 . 7854 | - 0 . 0000 | | 0 . 0000 | 1 . 0000 | + ---------+--------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/atan/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ceil/","text":"CEIL() Description The CEIL(X) function returns the smallest integer value not less than X. Syntax > CEIL(X) Arguments Arguments Description X Required. Any numeric data type supported now. For exact-value numeric arguments, the return value has an exact-value numeric type. For floating-point arguments, the return value has a floating-point type. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 0 . 5 ); > insert into t1 values ( 2 , 0 . 499 ); > insert into t1 values ( 3 , 0 . 501 ); > insert into t1 values ( 4 , 20 . 5 ); > insert into t1 values ( 5 , 20 . 499 ); > insert into t1 values ( 6 , 13 . 500 ); > insert into t1 values ( 7 , - 0 . 500 ); > insert into t1 values ( 8 , - 0 . 499 ); > insert into t1 values ( 9 , - 0 . 501 ); > insert into t1 values ( 10 , - 20 . 499 ); > insert into t1 values ( 11 , - 20 . 500 ); > insert into t1 values ( 12 , - 13 . 500 ); > select a , ceil ( b ) from t1 ; + ------+----------+ | a | ceil ( b ) | + ------+----------+ | 1 | 1 . 0000 | | 2 | 1 . 0000 | | 3 | 1 . 0000 | | 4 | 21 . 0000 | | 5 | 21 . 0000 | | 6 | 14 . 0000 | | 7 | - 0 . 0000 | | 8 | - 0 . 0000 | | 9 | - 0 . 0000 | | 10 | - 20 . 0000 | | 11 | - 20 . 0000 | | 12 | - 13 . 0000 | + ------+----------+ > select sum ( ceil ( b )) from t1 ; + --------------+ | sum ( ceil ( b )) | + --------------+ | 6 . 0000 | + --------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"CEIL()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ceil/#ceil","text":"","title":"CEIL()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ceil/#description","text":"The CEIL(X) function returns the smallest integer value not less than X.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ceil/#syntax","text":"> CEIL(X)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ceil/#arguments","text":"Arguments Description X Required. Any numeric data type supported now. For exact-value numeric arguments, the return value has an exact-value numeric type. For floating-point arguments, the return value has a floating-point type.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ceil/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 0 . 5 ); > insert into t1 values ( 2 , 0 . 499 ); > insert into t1 values ( 3 , 0 . 501 ); > insert into t1 values ( 4 , 20 . 5 ); > insert into t1 values ( 5 , 20 . 499 ); > insert into t1 values ( 6 , 13 . 500 ); > insert into t1 values ( 7 , - 0 . 500 ); > insert into t1 values ( 8 , - 0 . 499 ); > insert into t1 values ( 9 , - 0 . 501 ); > insert into t1 values ( 10 , - 20 . 499 ); > insert into t1 values ( 11 , - 20 . 500 ); > insert into t1 values ( 12 , - 13 . 500 ); > select a , ceil ( b ) from t1 ; + ------+----------+ | a | ceil ( b ) | + ------+----------+ | 1 | 1 . 0000 | | 2 | 1 . 0000 | | 3 | 1 . 0000 | | 4 | 21 . 0000 | | 5 | 21 . 0000 | | 6 | 14 . 0000 | | 7 | - 0 . 0000 | | 8 | - 0 . 0000 | | 9 | - 0 . 0000 | | 10 | - 20 . 0000 | | 11 | - 20 . 0000 | | 12 | - 13 . 0000 | + ------+----------+ > select sum ( ceil ( b )) from t1 ; + --------------+ | sum ( ceil ( b )) | + --------------+ | 6 . 0000 | + --------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ceil/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cos/","text":"COS() Description The COS() function returns the cosine of input number(given in radians). Syntax > COS(number) Arguments Arguments Description number Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( - 1 , 1 . 57 ); > select cos ( a ), cos ( b ) from t1 ; + --------+---------+ | cos ( a ) | cos ( b ) | + --------+---------+ | 0 . 5403 | - 1 . 0000 | | 0 . 5403 | 0 . 0008 | + --------+---------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"COS()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cos/#cos","text":"","title":"COS()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cos/#description","text":"The COS() function returns the cosine of input number(given in radians).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cos/#syntax","text":"> COS(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cos/#arguments","text":"Arguments Description number Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cos/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( - 1 , 1 . 57 ); > select cos ( a ), cos ( b ) from t1 ; + --------+---------+ | cos ( a ) | cos ( b ) | + --------+---------+ | 0 . 5403 | - 1 . 0000 | | 0 . 5403 | 0 . 0008 | + --------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cos/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cot/","text":"COT() Description The COT() function returns the cotangent of input number(given in radians). Syntax > COT(number) Arguments Arguments Description number Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( - 1 , 0 ); > select cot ( a ), cot ( b ) from t1 ; + ---------+--------+ | cot ( a ) | cot ( b ) | + ---------+--------+ | - 0 . 5574 | 1 . 0000 | | 2 . 5574 | 1 . 0000 | + ---------+--------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"COT()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cot/#cot","text":"","title":"COT()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cot/#description","text":"The COT() function returns the cotangent of input number(given in radians).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cot/#syntax","text":"> COT(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cot/#arguments","text":"Arguments Description number Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cot/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( - 1 , 0 ); > select cot ( a ), cot ( b ) from t1 ; + ---------+--------+ | cot ( a ) | cot ( b ) | + ---------+--------+ | - 0 . 5574 | 1 . 0000 | | 2 . 5574 | 1 . 0000 | + ---------+--------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/cot/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/exp/","text":"EXP() Description The EXP() function returns the value of e (the base of natural logarithms) raised to the power of X. Syntax > EXP(number) Arguments Arguments Description number Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( - 4 , 2 . 45 ); > insert into t1 values ( 6 , - 3 . 62 ); > select exp ( a ), exp ( b ) from t1 ; + ----------+---------+ | exp ( a ) | exp ( b ) | + ----------+---------+ | 0 . 0183 | 11 . 5883 | | 403 . 4288 | 0 . 0268 | + ----------+---------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"EXP()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/exp/#exp","text":"","title":"EXP()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/exp/#description","text":"The EXP() function returns the value of e (the base of natural logarithms) raised to the power of X.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/exp/#syntax","text":"> EXP(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/exp/#arguments","text":"Arguments Description number Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/exp/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( - 4 , 2 . 45 ); > insert into t1 values ( 6 , - 3 . 62 ); > select exp ( a ), exp ( b ) from t1 ; + ----------+---------+ | exp ( a ) | exp ( b ) | + ----------+---------+ | 0 . 0183 | 11 . 5883 | | 403 . 4288 | 0 . 0268 | + ----------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/exp/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/floor/","text":"FLOOR() Description The FLOOR() function returns the largest round number that is less than or equal to the number. Syntax > FLOOR(number, decimals) > FLOOR(number) Arguments Arguments Description number Required. Any numeric data type supported now. decimals Optional. An integer that represents the number of decimal places. By default it is zero, which means to round to an integer. decimals may also be negative. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 0 . 5 ); > insert into t1 values ( 2 , 0 . 499 ); > insert into t1 values ( 3 , 0 . 501 ); > insert into t1 values ( 4 , 20 . 5 ); > insert into t1 values ( 5 , 20 . 499 ); > insert into t1 values ( 6 , 13 . 500 ); > insert into t1 values ( 7 , - 0 . 500 ); > insert into t1 values ( 8 , - 0 . 499 ); > insert into t1 values ( 9 , - 0 . 501 ); > insert into t1 values ( 10 , - 20 . 499 ); > insert into t1 values ( 11 , - 20 . 500 ); > insert into t1 values ( 12 , - 13 . 500 ); > select a , floor ( b ) from t1 ; + ------+----------+ | a | floor ( b ) | + ------+----------+ | 1 | 0 . 0000 | | 2 | 0 . 0000 | | 3 | 0 . 0000 | | 4 | 20 . 0000 | | 5 | 20 . 0000 | | 6 | 13 . 0000 | | 7 | - 1 . 0000 | | 8 | - 1 . 0000 | | 9 | - 1 . 0000 | | 10 | - 21 . 0000 | | 11 | - 21 . 0000 | | 12 | - 14 . 0000 | + ------+----------+ > select sum ( floor ( b )) from t1 ; + ---------------+ | sum ( floor ( b )) | + ---------------+ | - 6 . 0000 | + ---------------+ > select a , sum ( floor ( b )) from t1 group by a order by a ; + ------+---------------+ | a | sum ( floor ( b )) | + ------+---------------+ | 1 | 0 . 0000 | | 2 | 0 . 0000 | | 3 | 0 . 0000 | | 4 | 20 . 0000 | | 5 | 20 . 0000 | | 6 | 13 . 0000 | | 7 | - 1 . 0000 | | 8 | - 1 . 0000 | | 9 | - 1 . 0000 | | 10 | - 21 . 0000 | | 11 | - 21 . 0000 | | 12 | - 14 . 0000 | + ------+---------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"FLOOR()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/floor/#floor","text":"","title":"FLOOR()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/floor/#description","text":"The FLOOR() function returns the largest round number that is less than or equal to the number.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/floor/#syntax","text":"> FLOOR(number, decimals) > FLOOR(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/floor/#arguments","text":"Arguments Description number Required. Any numeric data type supported now. decimals Optional. An integer that represents the number of decimal places. By default it is zero, which means to round to an integer. decimals may also be negative.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/floor/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 0 . 5 ); > insert into t1 values ( 2 , 0 . 499 ); > insert into t1 values ( 3 , 0 . 501 ); > insert into t1 values ( 4 , 20 . 5 ); > insert into t1 values ( 5 , 20 . 499 ); > insert into t1 values ( 6 , 13 . 500 ); > insert into t1 values ( 7 , - 0 . 500 ); > insert into t1 values ( 8 , - 0 . 499 ); > insert into t1 values ( 9 , - 0 . 501 ); > insert into t1 values ( 10 , - 20 . 499 ); > insert into t1 values ( 11 , - 20 . 500 ); > insert into t1 values ( 12 , - 13 . 500 ); > select a , floor ( b ) from t1 ; + ------+----------+ | a | floor ( b ) | + ------+----------+ | 1 | 0 . 0000 | | 2 | 0 . 0000 | | 3 | 0 . 0000 | | 4 | 20 . 0000 | | 5 | 20 . 0000 | | 6 | 13 . 0000 | | 7 | - 1 . 0000 | | 8 | - 1 . 0000 | | 9 | - 1 . 0000 | | 10 | - 21 . 0000 | | 11 | - 21 . 0000 | | 12 | - 14 . 0000 | + ------+----------+ > select sum ( floor ( b )) from t1 ; + ---------------+ | sum ( floor ( b )) | + ---------------+ | - 6 . 0000 | + ---------------+ > select a , sum ( floor ( b )) from t1 group by a order by a ; + ------+---------------+ | a | sum ( floor ( b )) | + ------+---------------+ | 1 | 0 . 0000 | | 2 | 0 . 0000 | | 3 | 0 . 0000 | | 4 | 20 . 0000 | | 5 | 20 . 0000 | | 6 | 13 . 0000 | | 7 | - 1 . 0000 | | 8 | - 1 . 0000 | | 9 | - 1 . 0000 | | 10 | - 21 . 0000 | | 11 | - 21 . 0000 | | 12 | - 14 . 0000 | + ------+---------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/floor/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ln/","text":"LN() Description LN(X) returns the natural logarithm of X. This function is synonymous with LOG(X). Syntax > LN(X) Reference to LOG(X) .","title":"LN()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ln/#ln","text":"","title":"LN()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ln/#description","text":"LN(X) returns the natural logarithm of X. This function is synonymous with LOG(X).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/ln/#syntax","text":"> LN(X) Reference to LOG(X) .","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/log/","text":"LOG() Description LOG(X) returns the natural logarithm of X. Syntax > LOG(X) Arguments Arguments Description X Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a float , b float ); > insert into t1 values ( 2 , - 2 ); > select log ( a ), log ( b ) from t1 ; + --------+--------+ | log ( a ) | log ( b ) | + --------+--------+ | 0 . 6931 | NULL | + --------+--------+ Constraints LOG(X) only support one parameter input for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"LOG()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/log/#log","text":"","title":"LOG()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/log/#description","text":"LOG(X) returns the natural logarithm of X.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/log/#syntax","text":"> LOG(X)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/log/#arguments","text":"Arguments Description X Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/log/#examples","text":"> drop table if exists t1 ; > create table t1 ( a float , b float ); > insert into t1 values ( 2 , - 2 ); > select log ( a ), log ( b ) from t1 ; + --------+--------+ | log ( a ) | log ( b ) | + --------+--------+ | 0 . 6931 | NULL | + --------+--------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/log/#constraints","text":"LOG(X) only support one parameter input for now. Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/pi/","text":"PI() Description PI() returns the value of \u03c0 (pi). Syntax > PI() Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 0 , 0 ),( - 15 , - 20 ),( - 22 , - 12 . 5 ); > insert into t1 values ( 0 , 360 ),( 30 , 390 ),( 90 , 450 ),( 180 , 270 ),( 180 , 180 ); > select acos ( a * pi () / 180 ) as acosa , acos ( b * pi () / 180 ) acosb from t1 ; + --------+--------+ | acosa | acosb | + --------+--------+ | 1 . 5708 | 1 . 5708 | | 1 . 8357 | 1 . 9274 | | 1 . 9649 | 1 . 7907 | | 1 . 5708 | NULL | | 1 . 0197 | NULL | | NULL | NULL | | NULL | NULL | | NULL | NULL | + --------+--------+ > select acos ( a * pi () / 180 ) * acos ( b * pi () / 180 ) as acosab , acos ( acos ( a * pi () / 180 )) as c from t1 ; + --------+------+ | acosab | c | + --------+------+ | 2 . 4674 | NULL | | 3 . 5380 | NULL | | 3 . 5186 | NULL | | NULL | NULL | | NULL | NULL | | NULL | NULL | | NULL | NULL | | NULL | NULL | + --------+------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"PI()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/pi/#pi","text":"","title":"PI()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/pi/#description","text":"PI() returns the value of \u03c0 (pi).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/pi/#syntax","text":"> PI()","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/pi/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 0 , 0 ),( - 15 , - 20 ),( - 22 , - 12 . 5 ); > insert into t1 values ( 0 , 360 ),( 30 , 390 ),( 90 , 450 ),( 180 , 270 ),( 180 , 180 ); > select acos ( a * pi () / 180 ) as acosa , acos ( b * pi () / 180 ) acosb from t1 ; + --------+--------+ | acosa | acosb | + --------+--------+ | 1 . 5708 | 1 . 5708 | | 1 . 8357 | 1 . 9274 | | 1 . 9649 | 1 . 7907 | | 1 . 5708 | NULL | | 1 . 0197 | NULL | | NULL | NULL | | NULL | NULL | | NULL | NULL | + --------+--------+ > select acos ( a * pi () / 180 ) * acos ( b * pi () / 180 ) as acosab , acos ( acos ( a * pi () / 180 )) as c from t1 ; + --------+------+ | acosab | c | + --------+------+ | 2 . 4674 | NULL | | 3 . 5380 | NULL | | 3 . 5186 | NULL | | NULL | NULL | | NULL | NULL | | NULL | NULL | | NULL | NULL | | NULL | NULL | + --------+------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/pi/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/power/","text":"POWER() Description POWER(X, Y) returns the value of X raised to the power of Y. Syntax > POWER(X, Y) Arguments Arguments Description X Required. Any numeric data type supported now. Y Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a int , b int ); > insert into t1 values ( 5 , - 2 ),( 10 , 3 ),( 100 , 0 ),( 4 , 3 ),( 6 , - 3 ); > select power ( a , b ) from t1 ; + -------------+ | power ( a , b ) | + -------------+ | 0 . 0400 | | 1000 . 0000 | | 1 . 0000 | | 64 . 0000 | | 0 . 0046 | + -------------+ > select power ( a , 2 ) as a1 , power ( b , 2 ) as b1 from t1 where power ( a , 2 ) > power ( b , 2 ) order by a1 asc ; + ------------+--------+ | a1 | b1 | + ------------+--------+ | 16 . 0000 | 9 . 0000 | | 25 . 0000 | 4 . 0000 | | 36 . 0000 | 9 . 0000 | | 100 . 0000 | 9 . 0000 | | 10000 . 0000 | 0 . 0000 | + ------------+--------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"POWER()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/power/#power","text":"","title":"POWER()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/power/#description","text":"POWER(X, Y) returns the value of X raised to the power of Y.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/power/#syntax","text":"> POWER(X, Y)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/power/#arguments","text":"Arguments Description X Required. Any numeric data type supported now. Y Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/power/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b int ); > insert into t1 values ( 5 , - 2 ),( 10 , 3 ),( 100 , 0 ),( 4 , 3 ),( 6 , - 3 ); > select power ( a , b ) from t1 ; + -------------+ | power ( a , b ) | + -------------+ | 0 . 0400 | | 1000 . 0000 | | 1 . 0000 | | 64 . 0000 | | 0 . 0046 | + -------------+ > select power ( a , 2 ) as a1 , power ( b , 2 ) as b1 from t1 where power ( a , 2 ) > power ( b , 2 ) order by a1 asc ; + ------------+--------+ | a1 | b1 | + ------------+--------+ | 16 . 0000 | 9 . 0000 | | 25 . 0000 | 4 . 0000 | | 36 . 0000 | 9 . 0000 | | 100 . 0000 | 9 . 0000 | | 10000 . 0000 | 0 . 0000 | + ------------+--------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/power/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/round/","text":"ROUND() Description The ROUND() function rounds a number to a specified number of decimal places. The function returns the nearest number of the specified order. In case when given number has equal distance to surrounding numbers, the function uses banker\u2019s rounding for float number types and rounds away from zero for the other number types (Decimal). Syntax > ROUND(number, decimals) > ROUND(number) Arguments Arguments Description number Required. The number to round, including any numeric data type supported now. decimals Optional. An integer that represents the number of decimal places you want to round to. Default value is 0. decimals>0 then the function rounds the value to the right of the decimal point. decimals<0 then the function rounds the value to the left of the decimal point. decimals=0 then the function rounds the value to integer. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 0 . 5 ); > insert into t1 values ( 2 , 0 . 499 ); > insert into t1 values ( 3 , 0 . 501 ); > insert into t1 values ( 4 , 20 . 5 ); > insert into t1 values ( 5 , 20 . 499 ); > insert into t1 values ( 6 , 13 . 500 ); > insert into t1 values ( 7 , - 0 . 500 ); > insert into t1 values ( 8 , - 0 . 499 ); > insert into t1 values ( 9 , - 0 . 501 ); > insert into t1 values ( 10 , - 20 . 499 ); > insert into t1 values ( 11 , - 20 . 500 ); > insert into t1 values ( 12 , - 13 . 500 ); > select a , round ( b ) from t1 ; + ------+----------+ | a | round ( b ) | + ------+----------+ | 1 | 0 . 0000 | | 2 | 0 . 0000 | | 3 | 1 . 0000 | | 4 | 20 . 0000 | | 5 | 20 . 0000 | | 6 | 14 . 0000 | | 7 | - 0 . 0000 | | 8 | - 0 . 0000 | | 9 | - 1 . 0000 | | 10 | - 20 . 0000 | | 11 | - 20 . 0000 | | 12 | - 14 . 0000 | + ------+----------+ > select a , round ( b , - 1 ) from t1 ; + ------+--------------+ | a | round ( b , - 1 ) | + ------+--------------+ | 1 | 0 . 0000 | | 2 | 0 . 0000 | | 3 | 0 . 0000 | | 4 | 20 . 0000 | | 5 | 20 . 0000 | | 6 | 10 . 0000 | | 7 | - 0 . 0000 | | 8 | - 0 . 0000 | | 9 | - 0 . 0000 | | 10 | - 20 . 0000 | | 11 | - 20 . 0000 | | 12 | - 10 . 0000 | + ------+--------------+ > select round ( a * b ) from t1 ; + --------------+ | round ( a * b ) | + --------------+ | 0 . 0000 | | 1 . 0000 | | 2 . 0000 | | 82 . 0000 | | 102 . 0000 | | 81 . 0000 | | - 4 . 0000 | | - 4 . 0000 | | - 5 . 0000 | | - 205 . 0000 | | - 226 . 0000 | | - 162 . 0000 | + --------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"ROUND()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/round/#round","text":"","title":"ROUND()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/round/#description","text":"The ROUND() function rounds a number to a specified number of decimal places. The function returns the nearest number of the specified order. In case when given number has equal distance to surrounding numbers, the function uses banker\u2019s rounding for float number types and rounds away from zero for the other number types (Decimal).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/round/#syntax","text":"> ROUND(number, decimals) > ROUND(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/round/#arguments","text":"Arguments Description number Required. The number to round, including any numeric data type supported now. decimals Optional. An integer that represents the number of decimal places you want to round to. Default value is 0. decimals>0 then the function rounds the value to the right of the decimal point. decimals<0 then the function rounds the value to the left of the decimal point. decimals=0 then the function rounds the value to integer.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/round/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 0 . 5 ); > insert into t1 values ( 2 , 0 . 499 ); > insert into t1 values ( 3 , 0 . 501 ); > insert into t1 values ( 4 , 20 . 5 ); > insert into t1 values ( 5 , 20 . 499 ); > insert into t1 values ( 6 , 13 . 500 ); > insert into t1 values ( 7 , - 0 . 500 ); > insert into t1 values ( 8 , - 0 . 499 ); > insert into t1 values ( 9 , - 0 . 501 ); > insert into t1 values ( 10 , - 20 . 499 ); > insert into t1 values ( 11 , - 20 . 500 ); > insert into t1 values ( 12 , - 13 . 500 ); > select a , round ( b ) from t1 ; + ------+----------+ | a | round ( b ) | + ------+----------+ | 1 | 0 . 0000 | | 2 | 0 . 0000 | | 3 | 1 . 0000 | | 4 | 20 . 0000 | | 5 | 20 . 0000 | | 6 | 14 . 0000 | | 7 | - 0 . 0000 | | 8 | - 0 . 0000 | | 9 | - 1 . 0000 | | 10 | - 20 . 0000 | | 11 | - 20 . 0000 | | 12 | - 14 . 0000 | + ------+----------+ > select a , round ( b , - 1 ) from t1 ; + ------+--------------+ | a | round ( b , - 1 ) | + ------+--------------+ | 1 | 0 . 0000 | | 2 | 0 . 0000 | | 3 | 0 . 0000 | | 4 | 20 . 0000 | | 5 | 20 . 0000 | | 6 | 10 . 0000 | | 7 | - 0 . 0000 | | 8 | - 0 . 0000 | | 9 | - 0 . 0000 | | 10 | - 20 . 0000 | | 11 | - 20 . 0000 | | 12 | - 10 . 0000 | + ------+--------------+ > select round ( a * b ) from t1 ; + --------------+ | round ( a * b ) | + --------------+ | 0 . 0000 | | 1 . 0000 | | 2 . 0000 | | 82 . 0000 | | 102 . 0000 | | 81 . 0000 | | - 4 . 0000 | | - 4 . 0000 | | - 5 . 0000 | | - 205 . 0000 | | - 226 . 0000 | | - 162 . 0000 | + --------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/round/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sin/","text":"SIN() Description The SIN() function returns the sine of input number(given in radians). Syntax > SIN(number) Arguments Arguments Description number Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( - 1 , 1 . 57 ); > select sin ( a ), sin ( b ) from t1 ; + ---------+--------+ | sin ( a ) | sin ( b ) | + ---------+--------+ | 0 . 8415 | 0 . 0000 | | - 0 . 8415 | 1 . 0000 | + ---------+--------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"SIN()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sin/#sin","text":"","title":"SIN()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sin/#description","text":"The SIN() function returns the sine of input number(given in radians).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sin/#syntax","text":"> SIN(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sin/#arguments","text":"Arguments Description number Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sin/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( - 1 , 1 . 57 ); > select sin ( a ), sin ( b ) from t1 ; + ---------+--------+ | sin ( a ) | sin ( b ) | + ---------+--------+ | 0 . 8415 | 0 . 0000 | | - 0 . 8415 | 1 . 0000 | + ---------+--------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sin/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sinh/","text":"SINH() Description The SINH() function returns the hyperbolic sine of the input number(given in radians). Syntax > SINH(number) Arguments Arguments Description number Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ), ( - 1 , - 3 . 14159 ); > select sinh ( a ), sinh ( b ) from t1 ; Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"SINH()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sinh/#sinh","text":"","title":"SINH()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sinh/#description","text":"The SINH() function returns the hyperbolic sine of the input number(given in radians).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sinh/#syntax","text":"> SINH(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sinh/#arguments","text":"Arguments Description number Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sinh/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ), ( - 1 , - 3 . 14159 ); > select sinh ( a ), sinh ( b ) from t1 ;","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/sinh/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/tan/","text":"TAN() Description The TAN() function returns the tangent of input number(given in radians). Syntax > SIN(number) Arguments Arguments Description number Required. Any numeric data type supported now. Examples > drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( - 1 , - 3 . 14159 ); > select tan ( a ), tan ( b ) from t1 ; + ---------+---------+ | tan ( a ) | tan ( b ) | + ---------+---------+ | 1 . 5574 | - 0 . 0000 | | - 1 . 5574 | 0 . 0000 | + ---------+---------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"TAN()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/tan/#tan","text":"","title":"TAN()"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/tan/#description","text":"The TAN() function returns the tangent of input number(given in radians).","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/tan/#syntax","text":"> SIN(number)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/tan/#arguments","text":"Arguments Description number Required. Any numeric data type supported now.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/tan/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b float ); > insert into t1 values ( 1 , 3 . 14159 ); > insert into t1 values ( - 1 , - 3 . 14159 ); > select tan ( a ), tan ( b ) from t1 ; + ---------+---------+ | tan ( a ) | tan ( b ) | + ---------+---------+ | 1 . 5574 | - 0 . 0000 | | - 1 . 5574 | 0 . 0000 | + ---------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/Mathematical/tan/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/bin/","text":"BIN() Description This function BIN() returns a string representation of the binary value of N , where N is a longlong (BIGINT) number. Returns NULL if N is NULL . Syntax > BIN(N) Arguments Arguments Description N Required. UINT Type Examples","title":"**BIN()**"},{"location":"MatrixOne/Reference/Builtin-Functions/String/bin/#bin","text":"","title":"BIN()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/bin/#description","text":"This function BIN() returns a string representation of the binary value of N , where N is a longlong (BIGINT) number. Returns NULL if N is NULL .","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/bin/#syntax","text":"> BIN(N)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/bin/#arguments","text":"Arguments Description N Required. UINT Type","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/bin/#examples","text":"","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/cancat_ws/","text":"CONCAT_WS() Description This function CONCAT_WS() stands for Concatenate With Separator and is a special form of CONCAT() . The first argument is the separator for the rest of the arguments. The separator is added between the strings to be concatenated. The separator can be a string, as can the rest of the arguments. If the separator is NULL , the result is NULL . Syntax Syntax 1 > CONCAT_WS(separator,str1,str2,...) Syntax 2 > CONCAT_WS(separator,str1,NULL,str1,...); Arguments Arguments Description str Required. both CHAR and VARCHAR are supported. Examples SELECT CONCAT_WS ( ',' , 'First name' , 'Second name' , 'Last Name' ); + --------------------------------------------------+ | concat_ws (,, First name , Second name , Last Name ) | + --------------------------------------------------+ | First name , Second name , Last Name | + --------------------------------------------------+ 1 row in set ( 0 . 01 sec ) > SELECT CONCAT_WS ( ',' , 'First name' , NULL , 'Last Name' ); + -------------------------------------------+ | concat_ws (,, First name , null , Last Name ) | + -------------------------------------------+ | First name , Last Name | + -------------------------------------------+ 1 row in set ( 0 . 01 sec )","title":"**CONCAT_WS()**"},{"location":"MatrixOne/Reference/Builtin-Functions/String/cancat_ws/#concat_ws","text":"","title":"CONCAT_WS()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/cancat_ws/#description","text":"This function CONCAT_WS() stands for Concatenate With Separator and is a special form of CONCAT() . The first argument is the separator for the rest of the arguments. The separator is added between the strings to be concatenated. The separator can be a string, as can the rest of the arguments. If the separator is NULL , the result is NULL .","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/cancat_ws/#syntax","text":"Syntax 1 > CONCAT_WS(separator,str1,str2,...) Syntax 2 > CONCAT_WS(separator,str1,NULL,str1,...);","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/cancat_ws/#arguments","text":"Arguments Description str Required. both CHAR and VARCHAR are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/cancat_ws/#examples","text":"SELECT CONCAT_WS ( ',' , 'First name' , 'Second name' , 'Last Name' ); + --------------------------------------------------+ | concat_ws (,, First name , Second name , Last Name ) | + --------------------------------------------------+ | First name , Second name , Last Name | + --------------------------------------------------+ 1 row in set ( 0 . 01 sec ) > SELECT CONCAT_WS ( ',' , 'First name' , NULL , 'Last Name' ); + -------------------------------------------+ | concat_ws (,, First name , null , Last Name ) | + -------------------------------------------+ | First name , Last Name | + -------------------------------------------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/empty/","text":"EMPTY() Description Checks whether the input string is empty. A string is considered non-empty if it contains at least one byte, even if this is a space or a null byte. Syntax > EMPTY(str) Arguments Arguments Description str Required. both CHAR and VARCHAR are supported. Returned Values Returns 1 for an empty string or 0 for a non-empty string. Examples > drop table if exists t1 ; > create table t1 ( a varchar ( 255 ), b varchar ( 255 )); > insert into t1 values ( '' , 'abcd' ); > insert into t1 values ( '1111' , '' ); > select empty ( a ), empty ( b ) from t1 ; + ----------+----------+ | empty ( a ) | empty ( b ) | + ----------+----------+ | 1 | 0 | | 0 | 1 | + ----------+----------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"EMPTY()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/empty/#empty","text":"","title":"EMPTY()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/empty/#description","text":"Checks whether the input string is empty. A string is considered non-empty if it contains at least one byte, even if this is a space or a null byte.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/empty/#syntax","text":"> EMPTY(str)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/empty/#arguments","text":"Arguments Description str Required. both CHAR and VARCHAR are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/empty/#returned-values","text":"Returns 1 for an empty string or 0 for a non-empty string.","title":"Returned Values"},{"location":"MatrixOne/Reference/Builtin-Functions/String/empty/#examples","text":"> drop table if exists t1 ; > create table t1 ( a varchar ( 255 ), b varchar ( 255 )); > insert into t1 values ( '' , 'abcd' ); > insert into t1 values ( '1111' , '' ); > select empty ( a ), empty ( b ) from t1 ; + ----------+----------+ | empty ( a ) | empty ( b ) | + ----------+----------+ | 1 | 0 | | 0 | 1 | + ----------+----------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/empty/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/endswith/","text":"ENDSWITH() Description Returns whether to end with the specified suffix. Returns 1 if the string ends with the specified suffix, otherwise it returns 0. This function is case sensitive. Syntax > ENDSWITH(str,suffix) Arguments Arguments Description str Required. CHAR and VARCHAR both are supported. suffix Required. CHAR and VARCHAR both are supported. Returned Values 1, if the string ends with the specified suffix. 0, if the string does not end with the specified suffix. Examples > drop table if exists t1 ; > create table t1 ( a int , b varchar ( 100 ), c char ( 20 )); > insert into t1 values ( 1 , 'Ananya Majumdar' , 'XI' ), ( 2 , 'Anushka Samanta' , 'X' ), ( 3 , 'Aniket Sharma' , 'XI' ), ( 4 , 'Anik Das' , 'X' ), ( 5 , 'Riya Jain' , 'IX' ), ( 6 , 'Tapan Samanta' , 'XI' ); > select a , endsWith ( b , 'a' ) from t1 ; + ------+----------------+ | a | endswith ( b , a ) | + ------+----------------+ | 1 | 0 | | 2 | 1 | | 3 | 1 | | 4 | 0 | | 5 | 0 | | 6 | 1 | + ------+----------------+ > select a , b , c from t1 where endswith ( b , 'a' ) = 1 and endswith ( c , 'I' ) = 1 ; + ------+---------------+------+ | a | b | c | + ------+---------------+------+ | 3 | Aniket Sharma | XI | | 6 | Tapan Samanta | XI | + ------+---------------+------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"ENDSWITH()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/endswith/#endswith","text":"","title":"ENDSWITH()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/endswith/#description","text":"Returns whether to end with the specified suffix. Returns 1 if the string ends with the specified suffix, otherwise it returns 0. This function is case sensitive.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/endswith/#syntax","text":"> ENDSWITH(str,suffix)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/endswith/#arguments","text":"Arguments Description str Required. CHAR and VARCHAR both are supported. suffix Required. CHAR and VARCHAR both are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/endswith/#returned-values","text":"1, if the string ends with the specified suffix. 0, if the string does not end with the specified suffix.","title":"Returned Values"},{"location":"MatrixOne/Reference/Builtin-Functions/String/endswith/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b varchar ( 100 ), c char ( 20 )); > insert into t1 values ( 1 , 'Ananya Majumdar' , 'XI' ), ( 2 , 'Anushka Samanta' , 'X' ), ( 3 , 'Aniket Sharma' , 'XI' ), ( 4 , 'Anik Das' , 'X' ), ( 5 , 'Riya Jain' , 'IX' ), ( 6 , 'Tapan Samanta' , 'XI' ); > select a , endsWith ( b , 'a' ) from t1 ; + ------+----------------+ | a | endswith ( b , a ) | + ------+----------------+ | 1 | 0 | | 2 | 1 | | 3 | 1 | | 4 | 0 | | 5 | 0 | | 6 | 1 | + ------+----------------+ > select a , b , c from t1 where endswith ( b , 'a' ) = 1 and endswith ( c , 'I' ) = 1 ; + ------+---------------+------+ | a | b | c | + ------+---------------+------+ | 3 | Aniket Sharma | XI | | 6 | Tapan Samanta | XI | + ------+---------------+------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/endswith/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/find_in_set/","text":"FIND_IN_SET() Description This function FIND_IN_SET() returns a value in the range of 1 to N if the string str is in the string list strlist consisting of N substrings. A string list is a string composed of substrings separated by , characters. If the first argument is a constant string and the second is a column of type SET , the FIND_IN_SET() function is optimized to use bit arithmetic. Returns 0 if str is not in strlist or if strlist is the empty string. Returns NULL if either argument is NULL . This function does not work properly if the first argument contains a comma (,) character. Syntax > FIND_IN_SET(str,strlist) Arguments Arguments Description str Required. both CHAR and VARCHAR are supported. strlist Required. Examples select find_in_set ( 'b' , 'a,b,c,d' ); + -------------------------+ | find_in_set ( b , a , b , c , d ) | + -------------------------+ | 2 | + -------------------------+","title":"FIND_IN_SET()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/find_in_set/#find_in_set","text":"","title":"FIND_IN_SET()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/find_in_set/#description","text":"This function FIND_IN_SET() returns a value in the range of 1 to N if the string str is in the string list strlist consisting of N substrings. A string list is a string composed of substrings separated by , characters. If the first argument is a constant string and the second is a column of type SET , the FIND_IN_SET() function is optimized to use bit arithmetic. Returns 0 if str is not in strlist or if strlist is the empty string. Returns NULL if either argument is NULL . This function does not work properly if the first argument contains a comma (,) character.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/find_in_set/#syntax","text":"> FIND_IN_SET(str,strlist)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/find_in_set/#arguments","text":"Arguments Description str Required. both CHAR and VARCHAR are supported. strlist Required.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/find_in_set/#examples","text":"select find_in_set ( 'b' , 'a,b,c,d' ); + -------------------------+ | find_in_set ( b , a , b , c , d ) | + -------------------------+ | 2 | + -------------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/length/","text":"LENGTH() Description The length() function returns the length of the string. Syntax > LENGTH(str) Arguments Arguments Description str Required. String you want to calculate. Examples > select a,length(a) from t1; a length(a) a 1 ab 2 abc 3 Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"LENGTH()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/length/#length","text":"","title":"LENGTH()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/length/#description","text":"The length() function returns the length of the string.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/length/#syntax","text":"> LENGTH(str)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/length/#arguments","text":"Arguments Description str Required. String you want to calculate.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/length/#examples","text":"> select a,length(a) from t1; a length(a) a 1 ab 2 abc 3","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/length/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lengthUTF8/","text":"LENGTHUTF8() Description The lengthUTF8() function returns the length of the string str, measured in code points. A multibyte character counts as a single code point. This means that, for a string containing two 3-byte characters, LENGTH() returns 6, whereas LENGTHUTF8() returns 2. Syntax > LENGTHUTF8(str) Arguments Arguments Description str Required. String you want to calculate. Examples > drop table if exists t1 ; > create table t1 ( a varchar ( 255 ), b varchar ( 255 )); > insert into t1 values ( 'nihao' , '\u4f60\u597d' ); > select lengthUTF8 ( a ), lengthUTF8 ( b ) from t1 ; + ---------------+---------------+ | lengthutf8 ( a ) | lengthutf8 ( b ) | + ---------------+---------------+ | 5 | 2 | + ---------------+---------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"LENGTHUTF8()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lengthUTF8/#lengthutf8","text":"","title":"LENGTHUTF8()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lengthUTF8/#description","text":"The lengthUTF8() function returns the length of the string str, measured in code points. A multibyte character counts as a single code point. This means that, for a string containing two 3-byte characters, LENGTH() returns 6, whereas LENGTHUTF8() returns 2.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lengthUTF8/#syntax","text":"> LENGTHUTF8(str)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lengthUTF8/#arguments","text":"Arguments Description str Required. String you want to calculate.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lengthUTF8/#examples","text":"> drop table if exists t1 ; > create table t1 ( a varchar ( 255 ), b varchar ( 255 )); > insert into t1 values ( 'nihao' , '\u4f60\u597d' ); > select lengthUTF8 ( a ), lengthUTF8 ( b ) from t1 ; + ---------------+---------------+ | lengthutf8 ( a ) | lengthutf8 ( b ) | + ---------------+---------------+ | 5 | 2 | + ---------------+---------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lengthUTF8/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lpad/","text":"LPAD() Description This function LPAD(str,len,padstr) returns the string str , left-padded with the string padstr to a length of len characters. If str is longer than len , the return value is shortened to len characters. Syntax > LPAD(str,len,padstr) Arguments Arguments Description str Required. The string to be padded. CHAR and VARCHAR both are supported. len Required. padstr Required. The string used to pad on the left. CHAR and VARCHAR both are supported. Examples > drop table if exists t1 ; > CREATE TABLE t1 ( Student_id INT , Student_name VARCHAR ( 100 ), Student_Class CHAR ( 20 )); > INSERT INTO t1 VALUES ( 1 , 'Ananya Majumdar' , 'IX' ), ( 2 , 'Anushka Samanta' , 'X' ), ( 3 , 'Aniket Sharma' , 'XI' ), ( 4 , 'Anik Das' , 'X' ), ( 5 , 'Riya Jain' , 'IX' ), ( 6 , 'Tapan Samanta' , 'X' ); > SELECT Student_id , Student_name , LPAD ( Student_Class , 10 , ' _' ) AS LeftPaddedString FROM t1 ; + ------------+-----------------+------------------+ | Student_id | Student_name | LeftPaddedString | + ------------+-----------------+------------------+ | 1 | Ananya Majumdar | _ _ _ _IX | | 2 | Anushka Samanta | _ _ _ _ X | | 3 | Aniket Sharma | _ _ _ _XI | | 4 | Anik Das | _ _ _ _ X | | 5 | Riya Jain | _ _ _ _IX | | 6 | Tapan Samanta | _ _ _ _ X | + ------------+-----------------+------------------+ > SELECT Student_id , lpad ( Student_name , 4 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | Anan | | 2 | Anus | | 3 | Anik | | 4 | Anik | | 5 | Riya | | 6 | Tapa | + ------------+------------------+ > SELECT Student_id , lpad ( Student_name , - 4 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | NULL | | 2 | NULL | | 3 | NULL | | 4 | NULL | | 5 | NULL | | 6 | NULL | + ------------+------------------+ > SELECT Student_id , lpad ( Student_name , 0 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | | | 2 | | | 3 | | | 4 | | | 5 | | | 6 | | + ------------+------------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"LPAD()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lpad/#lpad","text":"","title":"LPAD()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lpad/#description","text":"This function LPAD(str,len,padstr) returns the string str , left-padded with the string padstr to a length of len characters. If str is longer than len , the return value is shortened to len characters.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lpad/#syntax","text":"> LPAD(str,len,padstr)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lpad/#arguments","text":"Arguments Description str Required. The string to be padded. CHAR and VARCHAR both are supported. len Required. padstr Required. The string used to pad on the left. CHAR and VARCHAR both are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lpad/#examples","text":"> drop table if exists t1 ; > CREATE TABLE t1 ( Student_id INT , Student_name VARCHAR ( 100 ), Student_Class CHAR ( 20 )); > INSERT INTO t1 VALUES ( 1 , 'Ananya Majumdar' , 'IX' ), ( 2 , 'Anushka Samanta' , 'X' ), ( 3 , 'Aniket Sharma' , 'XI' ), ( 4 , 'Anik Das' , 'X' ), ( 5 , 'Riya Jain' , 'IX' ), ( 6 , 'Tapan Samanta' , 'X' ); > SELECT Student_id , Student_name , LPAD ( Student_Class , 10 , ' _' ) AS LeftPaddedString FROM t1 ; + ------------+-----------------+------------------+ | Student_id | Student_name | LeftPaddedString | + ------------+-----------------+------------------+ | 1 | Ananya Majumdar | _ _ _ _IX | | 2 | Anushka Samanta | _ _ _ _ X | | 3 | Aniket Sharma | _ _ _ _XI | | 4 | Anik Das | _ _ _ _ X | | 5 | Riya Jain | _ _ _ _IX | | 6 | Tapan Samanta | _ _ _ _ X | + ------------+-----------------+------------------+ > SELECT Student_id , lpad ( Student_name , 4 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | Anan | | 2 | Anus | | 3 | Anik | | 4 | Anik | | 5 | Riya | | 6 | Tapa | + ------------+------------------+ > SELECT Student_id , lpad ( Student_name , - 4 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | NULL | | 2 | NULL | | 3 | NULL | | 4 | NULL | | 5 | NULL | | 6 | NULL | + ------------+------------------+ > SELECT Student_id , lpad ( Student_name , 0 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | | | 2 | | | 3 | | | 4 | | | 5 | | | 6 | | + ------------+------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/lpad/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/ltrim/","text":"LTRIM() Description This function LTRIM() returns the string with leading space characters removed. Syntax > LTRIM(str) Arguments Arguments Description str Required. CHAR and VARCHAR both are supported. Examples > drop table if exists t1 ; > create table t1 ( a char ( 8 ), b varchar ( 10 )); > insert into t1 values ( ' matrix' , ' matrixone' ); > select ltrim ( a ), ltrim ( b ) from t1 ; + ----------+-----------+ | ltrim ( a ) | ltrim ( b ) | + ----------+-----------+ | matrix | matrixone | + ----------+-----------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"LTRIM()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/ltrim/#ltrim","text":"","title":"LTRIM()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/ltrim/#description","text":"This function LTRIM() returns the string with leading space characters removed.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/ltrim/#syntax","text":"> LTRIM(str)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/ltrim/#arguments","text":"Arguments Description str Required. CHAR and VARCHAR both are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/ltrim/#examples","text":"> drop table if exists t1 ; > create table t1 ( a char ( 8 ), b varchar ( 10 )); > insert into t1 values ( ' matrix' , ' matrixone' ); > select ltrim ( a ), ltrim ( b ) from t1 ; + ----------+-----------+ | ltrim ( a ) | ltrim ( b ) | + ----------+-----------+ | matrix | matrixone | + ----------+-----------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/ltrim/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/oct/","text":"OCT(N) Description This function OCT(N) returns a string representation of the octal value of N , where N is a longlong (BIGINT) number. Returns NULL if N is NULL . Syntax > OCT(N) Arguments Arguments Description N Required. UINT Type Examples SELECT OCT ( 12 ); + ---------+ | oct ( 12 ) | + ---------+ | 14 . 0000 | + ---------+ 1 row in set ( 0 . 00 sec )","title":"OCT()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/oct/#octn","text":"","title":"OCT(N)"},{"location":"MatrixOne/Reference/Builtin-Functions/String/oct/#description","text":"This function OCT(N) returns a string representation of the octal value of N , where N is a longlong (BIGINT) number. Returns NULL if N is NULL .","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/oct/#syntax","text":"> OCT(N)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/oct/#arguments","text":"Arguments Description N Required. UINT Type","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/oct/#examples","text":"SELECT OCT ( 12 ); + ---------+ | oct ( 12 ) | + ---------+ | 14 . 0000 | + ---------+ 1 row in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/reverse/","text":"REVERSE() Description Returns the string str with the order of the characters reversed. Syntax > REVERSE(str) Arguments Arguments Description Str Required. both CHAR and VARCHAR are supported. Examples > drop table if exists t1 ; > create table t1 ( a varchar ( 12 ), c char ( 30 )); > insert into t1 values ( 'sdfad ' , '2022-02-02 22:22:22' ); > insert into t1 values ( ' sdfad ' , '2022-02-02 22:22:22' ); > insert into t1 values ( 'adsf sdfad' , '2022-02-02 22:22:22' ); > insert into t1 values ( ' sdfad' , '2022-02-02 22:22:22' ); > select reverse ( a ), reverse ( c ) from t1 ; + -------------+---------------------+ | reverse ( a ) | reverse ( c ) | + -------------+---------------------+ | dafds | 22 : 22 : 22 20 - 20 - 2202 | | dafds | 22 : 22 : 22 20 - 20 - 2202 | | dafds fsda | 22 : 22 : 22 20 - 20 - 2202 | | dafds | 22 : 22 : 22 20 - 20 - 2202 | + -------------+---------------------+ > select a from t1 where reverse ( a ) like 'daf%' ; + -------------+ | a | + -------------+ | adsf sdfad | | sdfad | + -------------+ > select reverse ( a ) reversea , reverse ( reverse ( a )) normala from t1 ; + -------------+-------------+ | reversea | normala | + -------------+-------------+ | dafds | sdfad | | dafds | sdfad | | dafds fsda | adsf sdfad | | dafds | sdfad | + -------------+-------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"REVERSE()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/reverse/#reverse","text":"","title":"REVERSE()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/reverse/#description","text":"Returns the string str with the order of the characters reversed.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/reverse/#syntax","text":"> REVERSE(str)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/reverse/#arguments","text":"Arguments Description Str Required. both CHAR and VARCHAR are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/reverse/#examples","text":"> drop table if exists t1 ; > create table t1 ( a varchar ( 12 ), c char ( 30 )); > insert into t1 values ( 'sdfad ' , '2022-02-02 22:22:22' ); > insert into t1 values ( ' sdfad ' , '2022-02-02 22:22:22' ); > insert into t1 values ( 'adsf sdfad' , '2022-02-02 22:22:22' ); > insert into t1 values ( ' sdfad' , '2022-02-02 22:22:22' ); > select reverse ( a ), reverse ( c ) from t1 ; + -------------+---------------------+ | reverse ( a ) | reverse ( c ) | + -------------+---------------------+ | dafds | 22 : 22 : 22 20 - 20 - 2202 | | dafds | 22 : 22 : 22 20 - 20 - 2202 | | dafds fsda | 22 : 22 : 22 20 - 20 - 2202 | | dafds | 22 : 22 : 22 20 - 20 - 2202 | + -------------+---------------------+ > select a from t1 where reverse ( a ) like 'daf%' ; + -------------+ | a | + -------------+ | adsf sdfad | | sdfad | + -------------+ > select reverse ( a ) reversea , reverse ( reverse ( a )) normala from t1 ; + -------------+-------------+ | reversea | normala | + -------------+-------------+ | dafds | sdfad | | dafds | sdfad | | dafds fsda | adsf sdfad | | dafds | sdfad | + -------------+-------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/reverse/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rpad/","text":"RPAD() Description This function RPAD(str,len,padstr) returns the string str , right-padded with the string padstr to a length of len characters. If str is longer than len , the return value is shortened to len characters. Syntax > RPAD(str,len,padstr) Arguments Arguments Description str Required. The string to be padded. CHAR and VARCHAR both are supported. len Required. padstr Required. The string used to pad on the right. CHAR and VARCHAR both are supported. Examples > drop table if exists t1 ; > CREATE TABLE t1 ( Student_id INT , Student_name VARCHAR ( 100 ), Student_Class CHAR ( 20 )); > INSERT INTO t1 VALUES ( 1 , 'Ananya Majumdar' , 'IX' ), ( 2 , 'Anushka Samanta' , 'X' ), ( 3 , 'Aniket Sharma' , 'XI' ), ( 4 , 'Anik Das' , 'X' ), ( 5 , 'Riya Jain' , 'IX' ), ( 6 , 'Tapan Samanta' , 'X' ); > SELECT Student_id , Student_name , RPAD ( Student_Class , 10 , ' _' ) AS LeftPaddedString FROM t1 ; + ------------+-----------------+------------------+ | Student_id | Student_name | LeftPaddedString | + ------------+-----------------+------------------+ | 1 | Ananya Majumdar | IX _ _ _ _ | | 2 | Anushka Samanta | X _ _ _ _ | | 3 | Aniket Sharma | XI _ _ _ _ | | 4 | Anik Das | X _ _ _ _ | | 5 | Riya Jain | IX _ _ _ _ | | 6 | Tapan Samanta | X _ _ _ _ | + ------------+-----------------+------------------+ > SELECT Student_id , rpad ( Student_name , 4 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | Anan | | 2 | Anus | | 3 | Anik | | 4 | Anik | | 5 | Riya | | 6 | Tapa | + ------------+------------------+ > SELECT Student_id , rpad ( Student_name , - 4 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | NULL | | 2 | NULL | | 3 | NULL | | 4 | NULL | | 5 | NULL | | 6 | NULL | + ------------+------------------+ > SELECT Student_id , rpad ( Student_name , 0 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | | | 2 | | | 3 | | | 4 | | | 5 | | | 6 | | + ------------+------------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"RPAD()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rpad/#rpad","text":"","title":"RPAD()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rpad/#description","text":"This function RPAD(str,len,padstr) returns the string str , right-padded with the string padstr to a length of len characters. If str is longer than len , the return value is shortened to len characters.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rpad/#syntax","text":"> RPAD(str,len,padstr)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rpad/#arguments","text":"Arguments Description str Required. The string to be padded. CHAR and VARCHAR both are supported. len Required. padstr Required. The string used to pad on the right. CHAR and VARCHAR both are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rpad/#examples","text":"> drop table if exists t1 ; > CREATE TABLE t1 ( Student_id INT , Student_name VARCHAR ( 100 ), Student_Class CHAR ( 20 )); > INSERT INTO t1 VALUES ( 1 , 'Ananya Majumdar' , 'IX' ), ( 2 , 'Anushka Samanta' , 'X' ), ( 3 , 'Aniket Sharma' , 'XI' ), ( 4 , 'Anik Das' , 'X' ), ( 5 , 'Riya Jain' , 'IX' ), ( 6 , 'Tapan Samanta' , 'X' ); > SELECT Student_id , Student_name , RPAD ( Student_Class , 10 , ' _' ) AS LeftPaddedString FROM t1 ; + ------------+-----------------+------------------+ | Student_id | Student_name | LeftPaddedString | + ------------+-----------------+------------------+ | 1 | Ananya Majumdar | IX _ _ _ _ | | 2 | Anushka Samanta | X _ _ _ _ | | 3 | Aniket Sharma | XI _ _ _ _ | | 4 | Anik Das | X _ _ _ _ | | 5 | Riya Jain | IX _ _ _ _ | | 6 | Tapan Samanta | X _ _ _ _ | + ------------+-----------------+------------------+ > SELECT Student_id , rpad ( Student_name , 4 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | Anan | | 2 | Anus | | 3 | Anik | | 4 | Anik | | 5 | Riya | | 6 | Tapa | + ------------+------------------+ > SELECT Student_id , rpad ( Student_name , - 4 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | NULL | | 2 | NULL | | 3 | NULL | | 4 | NULL | | 5 | NULL | | 6 | NULL | + ------------+------------------+ > SELECT Student_id , rpad ( Student_name , 0 , 'new' ) AS LeftPaddedString FROM t1 ; + ------------+------------------+ | Student_id | LeftPaddedString | + ------------+------------------+ | 1 | | | 2 | | | 3 | | | 4 | | | 5 | | | 6 | | + ------------+------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rpad/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rtrim/","text":"RTRIM() Description This function RTRIM() returns the string with trailing space characters removed. Syntax > RTRIM(str) Arguments Arguments Description str Required. CHAR and VARCHAR both are supported. Examples > drop table if exists t1 ; > create table t1 ( a char ( 8 ), b varchar ( 10 )); > insert into t1 values ( 'matrix ' , 'matrixone ' ); > select rtrim ( a ), rtrim ( b ) from t1 ; + ----------+-----------+ | rtrim ( a ) | rtrim ( b ) | + ----------+-----------+ | matrix | matrixone | + ----------+-----------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"RTRIM()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rtrim/#rtrim","text":"","title":"RTRIM()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rtrim/#description","text":"This function RTRIM() returns the string with trailing space characters removed.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rtrim/#syntax","text":"> RTRIM(str)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rtrim/#arguments","text":"Arguments Description str Required. CHAR and VARCHAR both are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rtrim/#examples","text":"> drop table if exists t1 ; > create table t1 ( a char ( 8 ), b varchar ( 10 )); > insert into t1 values ( 'matrix ' , 'matrixone ' ); > select rtrim ( a ), rtrim ( b ) from t1 ; + ----------+-----------+ | rtrim ( a ) | rtrim ( b ) | + ----------+-----------+ | matrix | matrixone | + ----------+-----------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/rtrim/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/space/","text":"SPACE() Description SPACE(N) Returns a string consisting of N space characters. Syntax > SPACE(N) Arguments Arguments Description N Required. UINT Type Examples > drop table if exists t1 ; > CREATE TABLE t1 ( Employee_name VARCHAR ( 100 ) NOT NULL , Joining_Date DATE NOT NULL ); > INSERT INTO t1 ( Employee_name , Joining_Date ) VALUES ( ' Ananya Majumdar' , '2000-01-11' ), ( ' Anushka Samanta' , '2002-11-10' ), ( ' Aniket Sharma ' , '2005-06-11' ), ( ' Anik Das' , '2008-01-21' ), ( ' Riya Jain' , '2008-02-01' ), ( ' Tapan Samanta' , '2010-01-11' ), ( ' Deepak Sharma' , '2014-12-01' ), ( ' Ankana Jana' , '2018-08-17' ), ( ' Shreya Ghosh' , '2020-09-10' ) ; > INSERT INTO t1 ( Employee_name , Joining_Date ) values ( ' ' , '2014-12-01' ); > select * from t1 where Employee_name = space ( 5 ); + ---------------+--------------+ | Employee_name | Joining_Date | + ---------------+--------------+ | | 2014 - 12 - 01 | + ---------------+--------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"SPACE()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/space/#space","text":"","title":"SPACE()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/space/#description","text":"SPACE(N) Returns a string consisting of N space characters.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/space/#syntax","text":"> SPACE(N)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/space/#arguments","text":"Arguments Description N Required. UINT Type","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/space/#examples","text":"> drop table if exists t1 ; > CREATE TABLE t1 ( Employee_name VARCHAR ( 100 ) NOT NULL , Joining_Date DATE NOT NULL ); > INSERT INTO t1 ( Employee_name , Joining_Date ) VALUES ( ' Ananya Majumdar' , '2000-01-11' ), ( ' Anushka Samanta' , '2002-11-10' ), ( ' Aniket Sharma ' , '2005-06-11' ), ( ' Anik Das' , '2008-01-21' ), ( ' Riya Jain' , '2008-02-01' ), ( ' Tapan Samanta' , '2010-01-11' ), ( ' Deepak Sharma' , '2014-12-01' ), ( ' Ankana Jana' , '2018-08-17' ), ( ' Shreya Ghosh' , '2020-09-10' ) ; > INSERT INTO t1 ( Employee_name , Joining_Date ) values ( ' ' , '2014-12-01' ); > select * from t1 where Employee_name = space ( 5 ); + ---------------+--------------+ | Employee_name | Joining_Date | + ---------------+--------------+ | | 2014 - 12 - 01 | + ---------------+--------------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/space/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/startswith/","text":"STARTSWITH() Description Returns 1 whether string starts with the specified prefix, otherwise it returns 0.This function is case sensitive. Syntax > STARTSWITH(str,prefix) Arguments Arguments Description str Required. CHAR and VARCHAR both are supported. prefix Required. CHAR and VARCHAR both are supported. Returned Values 1, if the string starts with the specified prefix. 0, if the string does not start with the specified prefix. Examples > drop table if exists t1 ; > create table t1 ( a int , b varchar ( 100 ), c char ( 20 )); > insert into t1 values ( 1 , 'Ananya Majumdar' , 'IX' ), ( 2 , 'Anushka Samanta' , 'X' ), ( 3 , 'Aniket Sharma' , 'XI' ), ( 4 , 'Anik Das' , 'X' ), ( 5 , 'Riya Jain' , 'IX' ), ( 6 , 'Tapan Samanta' , 'X' ); > select a , startswith ( b , 'An' ) from t1 ; + ------+-------------------+ | a | startswith ( b , An ) | + ------+-------------------+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 1 | | 5 | 0 | | 6 | 0 | + ------+-------------------+ > select a , b , c from t1 where startswith ( b , 'An' ) = 1 and startswith ( c , 'I' ) = 1 ; + ------+-----------------+------+ | a | b | c | + ------+-----------------+------+ | 1 | Ananya Majumdar | IX | + ------+-----------------+------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"STARTSWITH()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/startswith/#startswith","text":"","title":"STARTSWITH()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/startswith/#description","text":"Returns 1 whether string starts with the specified prefix, otherwise it returns 0.This function is case sensitive.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/startswith/#syntax","text":"> STARTSWITH(str,prefix)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/startswith/#arguments","text":"Arguments Description str Required. CHAR and VARCHAR both are supported. prefix Required. CHAR and VARCHAR both are supported.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/startswith/#returned-values","text":"1, if the string starts with the specified prefix. 0, if the string does not start with the specified prefix.","title":"Returned Values"},{"location":"MatrixOne/Reference/Builtin-Functions/String/startswith/#examples","text":"> drop table if exists t1 ; > create table t1 ( a int , b varchar ( 100 ), c char ( 20 )); > insert into t1 values ( 1 , 'Ananya Majumdar' , 'IX' ), ( 2 , 'Anushka Samanta' , 'X' ), ( 3 , 'Aniket Sharma' , 'XI' ), ( 4 , 'Anik Das' , 'X' ), ( 5 , 'Riya Jain' , 'IX' ), ( 6 , 'Tapan Samanta' , 'X' ); > select a , startswith ( b , 'An' ) from t1 ; + ------+-------------------+ | a | startswith ( b , An ) | + ------+-------------------+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 1 | | 5 | 0 | | 6 | 0 | + ------+-------------------+ > select a , b , c from t1 where startswith ( b , 'An' ) = 1 and startswith ( c , 'I' ) = 1 ; + ------+-----------------+------+ | a | b | c | + ------+-----------------+------+ | 1 | Ananya Majumdar | IX | + ------+-----------------+------+","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/startswith/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/Builtin-Functions/String/substring/","text":"SUBSTRING() Description SUBSTR() is a synonym of SUBSTRING(). The forms without a len argument return a substring from string str starting at position pos. The forms with a len argument return a substring len characters long from string str, starting at position pos. Syntax > SUBSTRING(str,pos) > SUBSTR(str,pos,len) Arguments Arguments Description str Required. CHAR and VARCHAR are both supported pos Required. len Optional. Examples > CREATE TABLE IF NOT EXISTS t1 ( pub_id varchar ( 8 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , pub_name varchar ( 50 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , pub_city varchar ( 25 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , country varchar ( 25 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , country_office varchar ( 25 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , no_of_branch int NOT NULL DEFAULT 0 , estd date NOT NULL DEFAULT '2000-01-01' ); > INSERT INTO t3 ( pub_id , pub_name , pub_city , country , country_office , no_of_branch , estd ) VALUES ( 'P001' , 'Jex Max Publication' , 'New York' , 'USA' , 'New York' , 15 , '1969-12-25' ), ( 'P002' , 'BPP Publication' , 'Mumbai' , 'India' , 'New Delhi' , 10 , '1985-10-01' ), ( 'P003' , 'New Harrold Publication' , 'Adelaide' , 'Australia' , 'Sydney' , 6 , '1975-09-05' ), ( 'P004' , 'Ultra Press Inc.' , 'London' , 'UK' , 'London' , 8 , '1948-07-10' ), ( 'P005' , 'Mountain Publication' , 'Houstan' , 'USA' , 'Sun Diego' , 25 , '1975-01-01' ), ( 'P006' , 'Summer Night Publication' , 'New York' , 'USA' , 'Atlanta' , 10 , '1990-12-10' ), ( 'P007' , 'Pieterson Grp. of Publishers' , 'Cambridge' , 'UK' , 'London' , 6 , '1950-07-15' ), ( 'P008' , 'Novel Publisher Ltd.' , 'New Delhi' , 'India' , 'Bangalore' , 10 , '2000-01-01' ); > SELECT pub_name , SUBSTR ( pub_name , 4 , 5 ) FROM t1 WHERE country = 'USA' ; + --------------------------+------------------------+ | pub_name | substr ( pub_name , 4 , 5 ) | + --------------------------+------------------------+ | Jex Max Publication | Max | | Mountain Publication | ntain | | Summer Night Publication | mer N | + --------------------------+------------------------+ 3 rows in set ( 0 . 04 sec ) > SELECT pub_name , SUBSTR ( pub_name , 5 ) FROM t1 WHERE country = 'USA' ; + --------------------------+----------------------+ | pub_name | substr ( pub_name , 5 ) | + --------------------------+----------------------+ | Jex Max Publication | Max Publication | | Mountain Publication | tain Publication | | Summer Night Publication | er Night Publication | + --------------------------+----------------------+ 3 rows in set ( 0 . 03 sec ) Constraints Currently, MatrixOne doesn't support select function() without from tables. Currently, Substring() doesn't support FROM and FOR clauses.","title":"SUBSTRING()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/substring/#substring","text":"","title":"SUBSTRING()"},{"location":"MatrixOne/Reference/Builtin-Functions/String/substring/#description","text":"SUBSTR() is a synonym of SUBSTRING(). The forms without a len argument return a substring from string str starting at position pos. The forms with a len argument return a substring len characters long from string str, starting at position pos.","title":"Description"},{"location":"MatrixOne/Reference/Builtin-Functions/String/substring/#syntax","text":"> SUBSTRING(str,pos) > SUBSTR(str,pos,len)","title":"Syntax"},{"location":"MatrixOne/Reference/Builtin-Functions/String/substring/#arguments","text":"Arguments Description str Required. CHAR and VARCHAR are both supported pos Required. len Optional.","title":"Arguments"},{"location":"MatrixOne/Reference/Builtin-Functions/String/substring/#examples","text":"> CREATE TABLE IF NOT EXISTS t1 ( pub_id varchar ( 8 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , pub_name varchar ( 50 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , pub_city varchar ( 25 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , country varchar ( 25 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , country_office varchar ( 25 ) COLLATE latin1_general_ci NOT NULL DEFAULT '' , no_of_branch int NOT NULL DEFAULT 0 , estd date NOT NULL DEFAULT '2000-01-01' ); > INSERT INTO t3 ( pub_id , pub_name , pub_city , country , country_office , no_of_branch , estd ) VALUES ( 'P001' , 'Jex Max Publication' , 'New York' , 'USA' , 'New York' , 15 , '1969-12-25' ), ( 'P002' , 'BPP Publication' , 'Mumbai' , 'India' , 'New Delhi' , 10 , '1985-10-01' ), ( 'P003' , 'New Harrold Publication' , 'Adelaide' , 'Australia' , 'Sydney' , 6 , '1975-09-05' ), ( 'P004' , 'Ultra Press Inc.' , 'London' , 'UK' , 'London' , 8 , '1948-07-10' ), ( 'P005' , 'Mountain Publication' , 'Houstan' , 'USA' , 'Sun Diego' , 25 , '1975-01-01' ), ( 'P006' , 'Summer Night Publication' , 'New York' , 'USA' , 'Atlanta' , 10 , '1990-12-10' ), ( 'P007' , 'Pieterson Grp. of Publishers' , 'Cambridge' , 'UK' , 'London' , 6 , '1950-07-15' ), ( 'P008' , 'Novel Publisher Ltd.' , 'New Delhi' , 'India' , 'Bangalore' , 10 , '2000-01-01' ); > SELECT pub_name , SUBSTR ( pub_name , 4 , 5 ) FROM t1 WHERE country = 'USA' ; + --------------------------+------------------------+ | pub_name | substr ( pub_name , 4 , 5 ) | + --------------------------+------------------------+ | Jex Max Publication | Max | | Mountain Publication | ntain | | Summer Night Publication | mer N | + --------------------------+------------------------+ 3 rows in set ( 0 . 04 sec ) > SELECT pub_name , SUBSTR ( pub_name , 5 ) FROM t1 WHERE country = 'USA' ; + --------------------------+----------------------+ | pub_name | substr ( pub_name , 5 ) | + --------------------------+----------------------+ | Jex Max Publication | Max Publication | | Mountain Publication | tain Publication | | Summer Night Publication | er Night Publication | + --------------------------+----------------------+ 3 rows in set ( 0 . 03 sec )","title":"Examples"},{"location":"MatrixOne/Reference/Builtin-Functions/String/substring/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables. Currently, Substring() doesn't support FROM and FOR clauses.","title":"Constraints"},{"location":"MatrixOne/Reference/Data-Types/data-types/","text":"Data Types Overview MatrixOne Data types conforms with MySQL Data types definition. Reference: https://dev.mysql.com/doc/refman/8.0/en/data-types.html Integer Numbers Data Type Size Min Value Max Value TINYINT 1 byte -128 127 SMALLINT 2 byte -32768 32767 INT 4 byte -2147483648 2147483647 BIGINT 8 byte -9223372036854775808 9223372036854775807 TINYINT UNSIGNED 1 byte 0 255 SMALLINT UNSIGNED 2 byte 0 65535 INT UNSIGNED 4 byte 0 4294967295 BIGINT UNSIGNED 8 byte 0 18446744073709551615 Real Numbers Data Type Size Precision Syntax FLOAT32 4 byte 23 bits FLOAT FLOAT64 8 byte 53 bits DOUBLE String Types Data Type Size Syntax String 24 byte CHAR, VARCHAR Time and Date Types Data Type Size Resolution Min Value Max Value Precision Date 4 byte day 1000-01-01 9999-12-31 YYYY-MM-DD/YYYYMMDD DateTime 4 byte second 1970-01-01 00:00:00 2105-12-31 23:59:59 YYYY-MM-DD hh:mm:ss Decimal Types(Beta) Data Type Size Precision Syntax Decimal64 8 byte 19 digits Decimal(N,S), N range(1,18), S range(0,N) Decimal128 16 byte 38 digits Decimal(N,S), N range(19,38), S range(0,N) Examples // Create a table named \"numtable\" with 3 attributes of an \"int\" , a \"float\" and a \"double\" > create table numtable ( id int , fl float , dl double ); // Insert a dataset of int , float and double into table \"numtable\" > insert into numtable values ( 3 , 1 . 234567 , 1 . 2345678912345678912 ); // Create a table named \"numtable\" with 2 attributes of an \"int\" and a \"float\" up to 5 digits in total , of which 3 digits may be after the decimal point . > create table numtable ( id int , fl float ( 5 , 3 )); // Insert a dataset of int , float into table \"numtable\" > insert into numtable values ( 3 , 99 . 123 ); // Create a table named \"numtable\" with 2 attributes of an \"int\" and a \"float\" up to 23 digits in total . > create table numtable ( id int , fl float ( 23 )); // Insert a dataset of int , float into table \"numtable\" > insert into numtable values ( 1 , 1 . 2345678901234567890123456789 ); // Create a table named \"numtable\" with 4 attributes of an \"unsigned tinyint\" , an \"unsigned smallint\" , an \"unsigned int\" and an \"unsigned bigint\" > create table numtable ( a tinyint unsigned , b smallint unsigned , c int unsigned , d bigint unsigned ); // Insert a dataset of unsigned ( tinyint , smallint , int and bigint ) into table \"numtable\" > insert into numtable values ( 255 , 65535 , 4294967295 , 18446744073709551615 ); // Create a table named \"names\" with 2 attributes of a \"varchar\" and a \"char\" > create table names ( name varchar ( 255 ), age char ( 255 )); // Insert a data of \"varchar\" and \"char\" into table \"names\" > insert into names ( name , age ) values ( 'Abby' , '24' ); // Create a table named \"calendar\" with 2 attributes of a \"date\" and a \"datetime\" > create table calendar ( a date , b datetime ); // Insert a data of \"date\" and \"datetime\" into table \"calendar\" > insert into calendar ( a , b ) values ( '20220202, ' 2022 - 02 - 02 00 : 10 : 30 '); > insert into calendar(a, b) values(' 2022 - 02 - 02 , '2022-02-02 00:10:30' ); // Create a table named \"decimalTest\" with 2 attribute of a \"decimal\" and b \"decimal\" > create table decimalTest ( a decimal ( 6 , 3 ), b decimal ( 24 , 18 )); > insert into decimalTest values ( 123 . 4567 , 123456 . 1234567891411241355 ); > select * from decimalTest ; + ---------+---------------------------+ | a | b | + ---------+---------------------------+ | 123 . 456 | 123456 . 123456789141124135 | + ---------+---------------------------+","title":"Date Types Overview"},{"location":"MatrixOne/Reference/Data-Types/data-types/#data-types-overview","text":"MatrixOne Data types conforms with MySQL Data types definition. Reference: https://dev.mysql.com/doc/refman/8.0/en/data-types.html","title":"Data Types Overview"},{"location":"MatrixOne/Reference/Data-Types/data-types/#integer-numbers","text":"Data Type Size Min Value Max Value TINYINT 1 byte -128 127 SMALLINT 2 byte -32768 32767 INT 4 byte -2147483648 2147483647 BIGINT 8 byte -9223372036854775808 9223372036854775807 TINYINT UNSIGNED 1 byte 0 255 SMALLINT UNSIGNED 2 byte 0 65535 INT UNSIGNED 4 byte 0 4294967295 BIGINT UNSIGNED 8 byte 0 18446744073709551615","title":"Integer Numbers"},{"location":"MatrixOne/Reference/Data-Types/data-types/#real-numbers","text":"Data Type Size Precision Syntax FLOAT32 4 byte 23 bits FLOAT FLOAT64 8 byte 53 bits DOUBLE","title":"Real Numbers"},{"location":"MatrixOne/Reference/Data-Types/data-types/#string-types","text":"Data Type Size Syntax String 24 byte CHAR, VARCHAR","title":"String Types"},{"location":"MatrixOne/Reference/Data-Types/data-types/#time-and-date-types","text":"Data Type Size Resolution Min Value Max Value Precision Date 4 byte day 1000-01-01 9999-12-31 YYYY-MM-DD/YYYYMMDD DateTime 4 byte second 1970-01-01 00:00:00 2105-12-31 23:59:59 YYYY-MM-DD hh:mm:ss","title":"Time and Date Types"},{"location":"MatrixOne/Reference/Data-Types/data-types/#decimal-typesbeta","text":"Data Type Size Precision Syntax Decimal64 8 byte 19 digits Decimal(N,S), N range(1,18), S range(0,N) Decimal128 16 byte 38 digits Decimal(N,S), N range(19,38), S range(0,N)","title":"Decimal Types(Beta)"},{"location":"MatrixOne/Reference/Data-Types/data-types/#examples","text":"// Create a table named \"numtable\" with 3 attributes of an \"int\" , a \"float\" and a \"double\" > create table numtable ( id int , fl float , dl double ); // Insert a dataset of int , float and double into table \"numtable\" > insert into numtable values ( 3 , 1 . 234567 , 1 . 2345678912345678912 ); // Create a table named \"numtable\" with 2 attributes of an \"int\" and a \"float\" up to 5 digits in total , of which 3 digits may be after the decimal point . > create table numtable ( id int , fl float ( 5 , 3 )); // Insert a dataset of int , float into table \"numtable\" > insert into numtable values ( 3 , 99 . 123 ); // Create a table named \"numtable\" with 2 attributes of an \"int\" and a \"float\" up to 23 digits in total . > create table numtable ( id int , fl float ( 23 )); // Insert a dataset of int , float into table \"numtable\" > insert into numtable values ( 1 , 1 . 2345678901234567890123456789 ); // Create a table named \"numtable\" with 4 attributes of an \"unsigned tinyint\" , an \"unsigned smallint\" , an \"unsigned int\" and an \"unsigned bigint\" > create table numtable ( a tinyint unsigned , b smallint unsigned , c int unsigned , d bigint unsigned ); // Insert a dataset of unsigned ( tinyint , smallint , int and bigint ) into table \"numtable\" > insert into numtable values ( 255 , 65535 , 4294967295 , 18446744073709551615 ); // Create a table named \"names\" with 2 attributes of a \"varchar\" and a \"char\" > create table names ( name varchar ( 255 ), age char ( 255 )); // Insert a data of \"varchar\" and \"char\" into table \"names\" > insert into names ( name , age ) values ( 'Abby' , '24' ); // Create a table named \"calendar\" with 2 attributes of a \"date\" and a \"datetime\" > create table calendar ( a date , b datetime ); // Insert a data of \"date\" and \"datetime\" into table \"calendar\" > insert into calendar ( a , b ) values ( '20220202, ' 2022 - 02 - 02 00 : 10 : 30 '); > insert into calendar(a, b) values(' 2022 - 02 - 02 , '2022-02-02 00:10:30' ); // Create a table named \"decimalTest\" with 2 attribute of a \"decimal\" and b \"decimal\" > create table decimalTest ( a decimal ( 6 , 3 ), b decimal ( 24 , 18 )); > insert into decimalTest values ( 123 . 4567 , 123456 . 1234567891411241355 ); > select * from decimalTest ; + ---------+---------------------------+ | a | b | + ---------+---------------------------+ | 123 . 456 | 123456 . 123456789141124135 | + ---------+---------------------------+","title":"Examples"},{"location":"MatrixOne/Reference/Data-Types/fixed-point-types/","text":"Fixed-Point Types (Exact Value) - DECIMAL The DECIMAL type store exact numeric data values. These types are used when it is important to preserve exact precision, for example with monetary data, or with scientific calculations. In a DECIMAL column declaration, the precision and scale can be (and usually is) specified. For example: salary DECIMAL ( 5 , 2 ) In this example, 5 is the precision and 2 is the scale. The precision represents the number of significant digits that are stored for values, and the scale represents the number of digits that can be stored following the decimal point. Standard SQL requires that DECIMAL(5,2) be able to store any value with five digits and two decimals, so values that can be stored in the salary column range from -999.99 to 999.99. In MatrixOne, the syntax DECIMAL(M) is equivalent to DECIMAL(M,0). Similarly, the syntax DECIMAL is equivalent to DECIMAL(M,0), where the implementation is permitted to decide the value of M. MatrixOne supports both of these variant forms of DECIMAL syntax. The default value of M is 10. If the scale is 0, DECIMAL values contain no decimal point or fractional part. In MatrixOne, the maximum number of digits for DECIMAL is 38, but the actual range for a given DECIMAL column can be constrained by the precision or scale for a given column. When such a column is assigned a value with more digits following the decimal point than are permitted by the specified scale, the value is converted to that scale. DECIMAL Data Type Characteristics This section discusses the characteristics of the DECIMAL data type (and its synonyms), with particular regard to the following topics: Maximum number of digits Storage format The declaration syntax for a DECIMAL column is DECIMAL(M,D). The ranges of values for the arguments are as follows: M is the maximum number of digits (the precision). It has a range of 1 to 38. D is the number of digits to the right of the decimal point (the scale). It has a range of 1 to 38 and must be no larger than M. If D is omitted, the default is 0. If M is omitted, the default is 10. The maximum value of 38 for M means that calculations on DECIMAL values are accurate up to 38 digits. Values for DECIMAL columns are stored using a binary format that packs decimal digits into 8 bytes or 16 bytes. The storage required for remaining digits is given by the following table. Digits Number of Bytes 0-18 8 bytes 19-38 16 bytes For a full explanation of the internal implementation of DECIMAL values, see the Feature Design .","title":"Fixed-Point Types (Exact Value) - DECIMAL"},{"location":"MatrixOne/Reference/Data-Types/fixed-point-types/#fixed-point-types-exact-value-decimal","text":"The DECIMAL type store exact numeric data values. These types are used when it is important to preserve exact precision, for example with monetary data, or with scientific calculations. In a DECIMAL column declaration, the precision and scale can be (and usually is) specified. For example: salary DECIMAL ( 5 , 2 ) In this example, 5 is the precision and 2 is the scale. The precision represents the number of significant digits that are stored for values, and the scale represents the number of digits that can be stored following the decimal point. Standard SQL requires that DECIMAL(5,2) be able to store any value with five digits and two decimals, so values that can be stored in the salary column range from -999.99 to 999.99. In MatrixOne, the syntax DECIMAL(M) is equivalent to DECIMAL(M,0). Similarly, the syntax DECIMAL is equivalent to DECIMAL(M,0), where the implementation is permitted to decide the value of M. MatrixOne supports both of these variant forms of DECIMAL syntax. The default value of M is 10. If the scale is 0, DECIMAL values contain no decimal point or fractional part. In MatrixOne, the maximum number of digits for DECIMAL is 38, but the actual range for a given DECIMAL column can be constrained by the precision or scale for a given column. When such a column is assigned a value with more digits following the decimal point than are permitted by the specified scale, the value is converted to that scale.","title":"Fixed-Point Types (Exact Value) - DECIMAL"},{"location":"MatrixOne/Reference/Data-Types/fixed-point-types/#decimal-data-type-characteristics","text":"This section discusses the characteristics of the DECIMAL data type (and its synonyms), with particular regard to the following topics: Maximum number of digits Storage format The declaration syntax for a DECIMAL column is DECIMAL(M,D). The ranges of values for the arguments are as follows: M is the maximum number of digits (the precision). It has a range of 1 to 38. D is the number of digits to the right of the decimal point (the scale). It has a range of 1 to 38 and must be no larger than M. If D is omitted, the default is 0. If M is omitted, the default is 10. The maximum value of 38 for M means that calculations on DECIMAL values are accurate up to 38 digits. Values for DECIMAL columns are stored using a binary format that packs decimal digits into 8 bytes or 16 bytes. The storage required for remaining digits is given by the following table. Digits Number of Bytes 0-18 8 bytes 19-38 16 bytes For a full explanation of the internal implementation of DECIMAL values, see the Feature Design .","title":"DECIMAL Data Type Characteristics"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/any-value/","text":"ANY_VALUE Description The ANY_VALUE function is useful for GROUP BY queries when the ONLY_FULL_GROUP_BY mode is enabled. Syntax > ANY_VALUE(arg) \u53c2\u6570\u91ca\u4e49 Arguments Description arg CAny type. When arg is NULL, the line does not participate in the calculation. Returned Value The function return value and type are the same as the return value and type of its argument, but the function result is not checked for the ONLY_FULL_GROUP_BY SQL mode. note The execution result of ANY_VALUE is uncertain. The same input may produce different execution results. Examples > create table t1 ( -> a int , -> b int , -> c int -> ); > create table t2 ( -> a int , -> b int , -> c int -> ); > insert into t1 values ( 1 , 10 , 34 ),( 2 , 20 , 14 ); > insert into t2 values ( 1 , - 10 , - 45 ); > select ANY_VALUE ( t1 . b ) from t1 left join t2 on t1 . c = t1 . b and t1 . a = t1 . c group by t1 . a ; + -----------------+ | any_value ( t1 . b ) | + -----------------+ | 10 | | 20 | + -----------------+ 2 rows in set ( 0 . 01 sec ) > select 3 + ( 5 * ANY_VALUE ( t1 . b )) from t1 left join t2 on t1 . c = t1 . b and t1 . a = t1 . c group by t1 . a ; + ---------------------------+ | 3 + ( 5 * any_value ( t1 . b )) | + ---------------------------+ | 53 | | 103 | + ---------------------------+ 2 rows in set ( 0 . 00 sec )","title":"ANY_VALUE"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/any-value/#any_value","text":"","title":"ANY_VALUE"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/any-value/#description","text":"The ANY_VALUE function is useful for GROUP BY queries when the ONLY_FULL_GROUP_BY mode is enabled.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/any-value/#syntax","text":"> ANY_VALUE(arg)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/any-value/#_1","text":"Arguments Description arg CAny type. When arg is NULL, the line does not participate in the calculation.","title":"\u53c2\u6570\u91ca\u4e49"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/any-value/#returned-value","text":"The function return value and type are the same as the return value and type of its argument, but the function result is not checked for the ONLY_FULL_GROUP_BY SQL mode. note The execution result of ANY_VALUE is uncertain. The same input may produce different execution results.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/any-value/#examples","text":"> create table t1 ( -> a int , -> b int , -> c int -> ); > create table t2 ( -> a int , -> b int , -> c int -> ); > insert into t1 values ( 1 , 10 , 34 ),( 2 , 20 , 14 ); > insert into t2 values ( 1 , - 10 , - 45 ); > select ANY_VALUE ( t1 . b ) from t1 left join t2 on t1 . c = t1 . b and t1 . a = t1 . c group by t1 . a ; + -----------------+ | any_value ( t1 . b ) | + -----------------+ | 10 | | 20 | + -----------------+ 2 rows in set ( 0 . 01 sec ) > select 3 + ( 5 * ANY_VALUE ( t1 . b )) from t1 left join t2 on t1 . c = t1 . b and t1 . a = t1 . c group by t1 . a ; + ---------------------------+ | 3 + ( 5 * any_value ( t1 . b )) | + ---------------------------+ | 53 | | 103 | + ---------------------------+ 2 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/","text":"AVG Description Aggregate function. The AVG() function calculates the average value of the argument. Syntax > AVG(expr) Arguments Arguments Description expr Any numerical expression Returned Value The arithmetic mean, always as Double. NaN if the input parameter is empty. Examples > drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select avg ( col_1c ) from tbl1 ; + -------------+ | avg ( col_1c ) | + -------------+ | 3 . 5000 | + -------------+ > select sum ( col_1d ) as s1 , avg ( col_1d ) as a3 from tbl1 group by col_1e order by s1 desc ; + ------+---------+ | s1 | a3 | + ------+---------+ | 21 | 10 . 5000 | | 18 | 9 . 0000 | | 10 | 10 . 0000 | | 8 | 8 . 0000 | + ------+---------+ > select avg ( col_1d ) as a1 from tbl1 where col_1d < 13 group by col_1e order by a1 ; + ---------+ | a1 | + ---------+ | 8 . 0000 | | 9 . 0000 | | 10 . 0000 | | 10 . 5000 | + ---------+ Constraints Currently, MatrixOne doesn't support select function() without from tables. AVG(DISTINCT) is not supported for the 0.5.0 version.","title":"AVG"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#avg","text":"","title":"AVG"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#description","text":"Aggregate function. The AVG() function calculates the average value of the argument.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#syntax","text":"> AVG(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#arguments","text":"Arguments Description expr Any numerical expression","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#returned-value","text":"The arithmetic mean, always as Double. NaN if the input parameter is empty.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#examples","text":"> drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select avg ( col_1c ) from tbl1 ; + -------------+ | avg ( col_1c ) | + -------------+ | 3 . 5000 | + -------------+ > select sum ( col_1d ) as s1 , avg ( col_1d ) as a3 from tbl1 group by col_1e order by s1 desc ; + ------+---------+ | s1 | a3 | + ------+---------+ | 21 | 10 . 5000 | | 18 | 9 . 0000 | | 10 | 10 . 0000 | | 8 | 8 . 0000 | + ------+---------+ > select avg ( col_1d ) as a1 from tbl1 where col_1d < 13 group by col_1e order by a1 ; + ---------+ | a1 | + ---------+ | 8 . 0000 | | 9 . 0000 | | 10 . 0000 | | 10 . 5000 | + ---------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables. AVG(DISTINCT) is not supported for the 0.5.0 version.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_and/","text":"BIT_AND Description Aggregate function. The BIT_AND(expr) function returns the bitwise AND of all bits in expr. Syntax > BIT_AND(expr) Arguments Arguments Description expr UINT data types Examples > drop table if exists t1 ; > CREATE TABLE t1 ( id CHAR ( 1 ), number INT ); > INSERT INTO t1 VALUES ( 'a' , 111 ),( 'a' , 110 ),( 'a' , 100 ), ( 'a' , 000 ),( 'b' , 001 ),( 'b' , 011 ); > select id , BIT_AND ( number ) FROM t1 GROUP BY id ; + ------+-----------------+ | id | bit_and ( number ) | + ------+-----------------+ | a | 0 | | b | 1 | + ------+-----------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"BIT_AND"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_and/#bit_and","text":"","title":"BIT_AND"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_and/#description","text":"Aggregate function. The BIT_AND(expr) function returns the bitwise AND of all bits in expr.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_and/#syntax","text":"> BIT_AND(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_and/#arguments","text":"Arguments Description expr UINT data types","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_and/#examples","text":"> drop table if exists t1 ; > CREATE TABLE t1 ( id CHAR ( 1 ), number INT ); > INSERT INTO t1 VALUES ( 'a' , 111 ),( 'a' , 110 ),( 'a' , 100 ), ( 'a' , 000 ),( 'b' , 001 ),( 'b' , 011 ); > select id , BIT_AND ( number ) FROM t1 GROUP BY id ; + ------+-----------------+ | id | bit_and ( number ) | + ------+-----------------+ | a | 0 | | b | 1 | + ------+-----------------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_and/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_or/","text":"BIT_OR Description Aggregate function. The BIT_OR(expr) function returns the bitwise OR of all bits in expr. Syntax > BIT_OR(expr) Arguments Arguments Description expr UINT data types Examples > drop table if exists t1 ; > CREATE TABLE t1 ( id CHAR ( 1 ), number INT ); > INSERT INTO t1 VALUES ( 'a' , 111 ),( 'a' , 110 ),( 'a' , 100 ), ( 'a' , 000 ),( 'b' , 001 ),( 'b' , 011 ); > select id , BIT_OR ( number ) FROM t1 GROUP BY id ; + ------+----------------+ | id | bit_or ( number ) | + ------+----------------+ | a | 111 | | b | 11 | + ------+----------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"BIT_OR"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_or/#bit_or","text":"","title":"BIT_OR"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_or/#description","text":"Aggregate function. The BIT_OR(expr) function returns the bitwise OR of all bits in expr.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_or/#syntax","text":"> BIT_OR(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_or/#arguments","text":"Arguments Description expr UINT data types","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_or/#examples","text":"> drop table if exists t1 ; > CREATE TABLE t1 ( id CHAR ( 1 ), number INT ); > INSERT INTO t1 VALUES ( 'a' , 111 ),( 'a' , 110 ),( 'a' , 100 ), ( 'a' , 000 ),( 'b' , 001 ),( 'b' , 011 ); > select id , BIT_OR ( number ) FROM t1 GROUP BY id ; + ------+----------------+ | id | bit_or ( number ) | + ------+----------------+ | a | 111 | | b | 11 | + ------+----------------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_or/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_xor/","text":"BIT_XOR Description Aggregate function. The BIT_XOR(expr) function returns the bitwise XOR of all bits in expr. Syntax > BIT_XOR(expr) Arguments Arguments Description expr UINT data types Examples > drop table if exists t1 ; > CREATE TABLE t1 ( id CHAR ( 1 ), number INT ); > INSERT INTO t1 VALUES ( 'a' , 111 ),( 'a' , 110 ),( 'a' , 100 ), ( 'a' , 000 ),( 'b' , 001 ),( 'b' , 011 ); > select id , BIT_XOR ( number ) FROM t1 GROUP BY id ; + ------+-----------------+ | id | bit_xor ( number ) | + ------+-----------------+ | a | 101 | | b | 10 | + ------+-----------------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"BIT_XOR"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_xor/#bit_xor","text":"","title":"BIT_XOR"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_xor/#description","text":"Aggregate function. The BIT_XOR(expr) function returns the bitwise XOR of all bits in expr.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_xor/#syntax","text":"> BIT_XOR(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_xor/#arguments","text":"Arguments Description expr UINT data types","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_xor/#examples","text":"> drop table if exists t1 ; > CREATE TABLE t1 ( id CHAR ( 1 ), number INT ); > INSERT INTO t1 VALUES ( 'a' , 111 ),( 'a' , 110 ),( 'a' , 100 ), ( 'a' , 000 ),( 'b' , 001 ),( 'b' , 011 ); > select id , BIT_XOR ( number ) FROM t1 GROUP BY id ; + ------+-----------------+ | id | bit_xor ( number ) | + ------+-----------------+ | a | 101 | | b | 10 | + ------+-----------------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/bit_xor/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/","text":"COUNT Description Aggregate function. The COUNT() function calculates the number of records returned by a select query. note NULL values are not counted. Syntax > COUNT(expr) Arguments Arguments Description expr Any expression.This may be a column name, the result of another function, or a math operation. * is also allowed, to indicate pure row counting. Returned Value Returns a count of the number of non-NULL values of expr in the rows retrieved by a SELECT statement. The result is a BIGINT value. If there are no matching rows, COUNT() returns 0. Examples > drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select count ( col_1b ) from tbl1 ; + ---------------+ | count ( col_1b ) | + ---------------+ | 6 | + ---------------+ > select count ( * ) from tbl1 where col_1d < 10 ; + ----------+ | count ( * ) | + ----------+ | 3 | + ----------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"COUNT"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#count","text":"","title":"COUNT"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#description","text":"Aggregate function. The COUNT() function calculates the number of records returned by a select query. note NULL values are not counted.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#syntax","text":"> COUNT(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#arguments","text":"Arguments Description expr Any expression.This may be a column name, the result of another function, or a math operation. * is also allowed, to indicate pure row counting.","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#returned-value","text":"Returns a count of the number of non-NULL values of expr in the rows retrieved by a SELECT statement. The result is a BIGINT value. If there are no matching rows, COUNT() returns 0.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#examples","text":"> drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select count ( col_1b ) from tbl1 ; + ---------------+ | count ( col_1b ) | + ---------------+ | 6 | + ---------------+ > select count ( * ) from tbl1 where col_1d < 10 ; + ----------+ | count ( * ) | + ----------+ | 3 | + ----------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/","text":"MAX Description Aggregate function. The MAX() function calculates the maximum value across a group of values. Syntax > MAX(expr) Arguments Arguments Description expr Any expression Returned Value Returns the maximum value of expr. MAX() may take a string argument, in such cases, it returns the maximum string value. Examples > drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select max ( col_1d ) from tbl1 ; + -------------+ | max ( col_1d ) | + -------------+ | 12 | + -------------+ > select max ( col_1c ) as m1 from tbl1 where col_1d < 12 group by col_1e ; + ------+ | m1 | + ------+ | 5 | | 2 | | 3 | | 4 | + ------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"MAX"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#max","text":"","title":"MAX"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#description","text":"Aggregate function. The MAX() function calculates the maximum value across a group of values.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#syntax","text":"> MAX(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#arguments","text":"Arguments Description expr Any expression","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#returned-value","text":"Returns the maximum value of expr. MAX() may take a string argument, in such cases, it returns the maximum string value.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#examples","text":"> drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select max ( col_1d ) from tbl1 ; + -------------+ | max ( col_1d ) | + -------------+ | 12 | + -------------+ > select max ( col_1c ) as m1 from tbl1 where col_1d < 12 group by col_1e ; + ------+ | m1 | + ------+ | 5 | | 2 | | 3 | | 4 | + ------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/","text":"MIN Description Aggregate function. The MAX() function calculates the maximum value across a group of values. Syntax > MIN(expr) Arguments Arguments Description expr Any expression Returned Value Returns the minimum value of expr. MIN() may take a string argument, in such cases, it returns the minimum string value. Examples > drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select min ( col_1d ) from tbl1 ; + -------------+ | min ( col_1d ) | + -------------+ | 7 | + -------------+ > select min ( col_1c ) as m1 from tbl1 where col_1d < 12 group by col_1e ; + ------+ | m1 | + ------+ | 1 | | 2 | | 3 | | 4 | + ------+ Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"MIN"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#min","text":"","title":"MIN"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#description","text":"Aggregate function. The MAX() function calculates the maximum value across a group of values.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#syntax","text":"> MIN(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#arguments","text":"Arguments Description expr Any expression","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#returned-value","text":"Returns the minimum value of expr. MIN() may take a string argument, in such cases, it returns the minimum string value.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#examples","text":"> drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select min ( col_1d ) from tbl1 ; + -------------+ | min ( col_1d ) | + -------------+ | 7 | + -------------+ > select min ( col_1c ) as m1 from tbl1 where col_1d < 12 group by col_1e ; + ------+ | m1 | + ------+ | 1 | | 2 | | 3 | | 4 | + ------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/stddev_pop/","text":"STDDEV_POP Description Aggregate function. The STDDEV_POP(expr) function returns the population standard deviation of expr. Syntax > STDDEV_POP(expr) Arguments Arguments Description expr Any numerical expressions Examples > CREATE TABLE t1 ( PlayerName VARCHAR ( 100 ) NOT NULL , RunScored INT NOT NULL , WicketsTaken INT NOT NULL ); > INSERT INTO t1 VALUES ( 'KL Rahul' , 52 , 0 ),( 'Hardik Pandya' , 30 , 1 ),( 'Ravindra Jadeja' , 18 , 2 ),( 'Washington Sundar' , 10 , 1 ),( 'D Chahar' , 11 , 2 ), ( 'Mitchell Starc' , 0 , 3 ); > SELECT STDDEV_POP ( RunScored ) as Pop_Standard_Deviation FROM t1 ; > SELECT STDDEV_POP ( WicketsTaken ) as Pop_Std_Dev_Wickets FROM t1 ; > SELECT STDDEV_POP ( RunScored ) as Pop_Standard_Deviation FROM t1 ; + ------------------------+ | Pop_Standard_Deviation | + ------------------------+ | 16 . 8762 | + ------------------------+ 1 row in set ( 0 . 02 sec ) > SELECT STDDEV_POP ( WicketsTaken ) as Pop_Std_Dev_Wickets FROM t1 ; + ---------------------+ | Pop_Std_Dev_Wickets | + ---------------------+ | 0 . 9574 | + ---------------------+ 1 row in set ( 0 . 01 sec ) Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"STDDEV_POP"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/stddev_pop/#stddev_pop","text":"","title":"STDDEV_POP"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/stddev_pop/#description","text":"Aggregate function. The STDDEV_POP(expr) function returns the population standard deviation of expr.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/stddev_pop/#syntax","text":"> STDDEV_POP(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/stddev_pop/#arguments","text":"Arguments Description expr Any numerical expressions","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/stddev_pop/#examples","text":"> CREATE TABLE t1 ( PlayerName VARCHAR ( 100 ) NOT NULL , RunScored INT NOT NULL , WicketsTaken INT NOT NULL ); > INSERT INTO t1 VALUES ( 'KL Rahul' , 52 , 0 ),( 'Hardik Pandya' , 30 , 1 ),( 'Ravindra Jadeja' , 18 , 2 ),( 'Washington Sundar' , 10 , 1 ),( 'D Chahar' , 11 , 2 ), ( 'Mitchell Starc' , 0 , 3 ); > SELECT STDDEV_POP ( RunScored ) as Pop_Standard_Deviation FROM t1 ; > SELECT STDDEV_POP ( WicketsTaken ) as Pop_Std_Dev_Wickets FROM t1 ; > SELECT STDDEV_POP ( RunScored ) as Pop_Standard_Deviation FROM t1 ; + ------------------------+ | Pop_Standard_Deviation | + ------------------------+ | 16 . 8762 | + ------------------------+ 1 row in set ( 0 . 02 sec ) > SELECT STDDEV_POP ( WicketsTaken ) as Pop_Std_Dev_Wickets FROM t1 ; + ---------------------+ | Pop_Std_Dev_Wickets | + ---------------------+ | 0 . 9574 | + ---------------------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/stddev_pop/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/","text":"SUM Description Aggregate function. The SUM() function calculates the sum of a set of values. note NULL values are not counted. Syntax > SUM(expr) Arguments Arguments Description expr Any expression Returned Value Returns the sum of expr. A double if the input type is double, otherwise integer. If there are no matching rows, SUM() returns NULL. Examples > drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select sum ( col_1c ) from tbl1 ; + -------------+ | sum ( col_1c ) | + -------------+ | 21 | + -------------+ > select sum ( col_1d ) as c1 from tbl1 where col_1d < 13 group by col_1e order by c1 ; + ------+ | c1 | + ------+ | 8 | | 10 | | 18 | | 21 | + ------+ Constraints Currently, MatrixOne doesn't support select function() without from tables. SUM(DISTINCT) is not supported for the 0.5.0 version.","title":"SUM"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#sum","text":"","title":"SUM"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#description","text":"Aggregate function. The SUM() function calculates the sum of a set of values. note NULL values are not counted.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#syntax","text":"> SUM(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#arguments","text":"Arguments Description expr Any expression","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#returned-value","text":"Returns the sum of expr. A double if the input type is double, otherwise integer. If there are no matching rows, SUM() returns NULL.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#examples","text":"> drop table if exists tbl1 , tbl2 ; > create table tbl1 ( col_1a tinyint , col_1b smallint , col_1c int , col_1d bigint , col_1e char ( 10 ) not null ); > insert into tbl1 values ( 0 , 1 , 1 , 7 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 2 , 8 , \"b\" ); > insert into tbl1 values ( 0 , 1 , 3 , 9 , \"c\" ); > insert into tbl1 values ( 0 , 1 , 4 , 10 , \"D\" ); > insert into tbl1 values ( 0 , 1 , 5 , 11 , \"a\" ); > insert into tbl1 values ( 0 , 1 , 6 , 12 , \"c\" ); > select sum ( col_1c ) from tbl1 ; + -------------+ | sum ( col_1c ) | + -------------+ | 21 | + -------------+ > select sum ( col_1d ) as c1 from tbl1 where col_1d < 13 group by col_1e order by c1 ; + ------+ | c1 | + ------+ | 8 | | 10 | | 18 | | 21 | + ------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables. SUM(DISTINCT) is not supported for the 0.5.0 version.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/var/","text":"VARIANCE Description Aggregate function. The VAR(expr) function returns the population standard variance of expr. Syntax > VAR(expr) Arguments Arguments Description expr Any numerical expressions Examples > CREATE TABLE t1 ( PlayerName VARCHAR ( 100 ) NOT NULL , RunScored INT NOT NULL , WicketsTaken INT NOT NULL ); > INSERT INTO t1 VALUES ( 'KL Rahul' , 52 , 0 ),( 'Hardik Pandya' , 30 , 1 ),( 'Ravindra Jadeja' , 18 , 2 ),( 'Washington Sundar' , 10 , 1 ),( 'D Chahar' , 11 , 2 ), ( 'Mitchell Starc' , 0 , 3 ); > SELECT VAR ( RunScored ) as Pop_Standard_Variance FROM t1 ; > SELECT VAR ( WicketsTaken ) as Pop_Std_Var_Wickets FROM t1 ; > SELECT VAR ( RunScored ) as Pop_Standard_Deviation FROM t1 ; + ------------------------+ | Pop_Standard_Deviation | + ------------------------+ | 284 . 8056 | + ------------------------+ 1 row in set ( 0 . 04 sec ) > SELECT VAR ( WicketsTaken ) as Pop_Std_Var_Wickets FROM t1 ; + ---------------------+ | Pop_Std_Var_Wickets | + ---------------------+ | 0 . 9167 | + ---------------------+ 1 row in set ( 0 . 04 sec ) Constraints Currently, MatrixOne doesn't support select function() without from tables.","title":"VAR"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/var/#variance","text":"","title":"VARIANCE"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/var/#description","text":"Aggregate function. The VAR(expr) function returns the population standard variance of expr.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/var/#syntax","text":"> VAR(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/var/#arguments","text":"Arguments Description expr Any numerical expressions","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/var/#examples","text":"> CREATE TABLE t1 ( PlayerName VARCHAR ( 100 ) NOT NULL , RunScored INT NOT NULL , WicketsTaken INT NOT NULL ); > INSERT INTO t1 VALUES ( 'KL Rahul' , 52 , 0 ),( 'Hardik Pandya' , 30 , 1 ),( 'Ravindra Jadeja' , 18 , 2 ),( 'Washington Sundar' , 10 , 1 ),( 'D Chahar' , 11 , 2 ), ( 'Mitchell Starc' , 0 , 3 ); > SELECT VAR ( RunScored ) as Pop_Standard_Variance FROM t1 ; > SELECT VAR ( WicketsTaken ) as Pop_Std_Var_Wickets FROM t1 ; > SELECT VAR ( RunScored ) as Pop_Standard_Deviation FROM t1 ; + ------------------------+ | Pop_Standard_Deviation | + ------------------------+ | 284 . 8056 | + ------------------------+ 1 row in set ( 0 . 04 sec ) > SELECT VAR ( WicketsTaken ) as Pop_Std_Var_Wickets FROM t1 ; + ---------------------+ | Pop_Std_Var_Wickets | + ---------------------+ | 0 . 9167 | + ---------------------+ 1 row in set ( 0 . 04 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/var/#constraints","text":"Currently, MatrixOne doesn't support select function() without from tables.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/","text":"CREATE DATABASE Description Create a database. Syntax > CREATE DATABASE [IF NOT EXISTS] <database_name> [create_option] ... > create_option: [DEFAULT] { CHARACTER SET [=] charset_name | COLLATE [=] collation_name | ENCRYPTION [=] {'Y' | 'N'} } create_database_statement Examples > CREATE DATABASE test01; > CREATE DATABASE IF NOT EXISTS test01; > CREATE DATABASE test03 DEFAULT CHARACTER SET utf8 collate utf8_general_ci ENCRYPTION 'Y'; > CREATE DATABASE test04 CHARACTER SET=utf8 collate=utf8_general_ci ENCRYPTION='N'; Constraints Only UTF-8 CHARACTER SET is supported for now.","title":"CREATE DATABASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#create-database","text":"","title":"CREATE DATABASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#description","text":"Create a database.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#syntax","text":"> CREATE DATABASE [IF NOT EXISTS] <database_name> [create_option] ... > create_option: [DEFAULT] { CHARACTER SET [=] charset_name | COLLATE [=] collation_name | ENCRYPTION [=] {'Y' | 'N'} }","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#create_database_statement","text":"","title":"create_database_statement"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#examples","text":"> CREATE DATABASE test01; > CREATE DATABASE IF NOT EXISTS test01; > CREATE DATABASE test03 DEFAULT CHARACTER SET utf8 collate utf8_general_ci ENCRYPTION 'Y'; > CREATE DATABASE test04 CHARACTER SET=utf8 collate=utf8_general_ci ENCRYPTION='N';","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#constraints","text":"Only UTF-8 CHARACTER SET is supported for now.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/","text":"CREATE INDEX Description Create an index on a table column. Syntax > CREATE INDEX index_name ON table_name (column_name) Examples > CREATE INDEX PIndex ON Persons (LastName); Constraints The index can only be applied for a single column. The index type, UNIQUE/FULLTEXT statements are not supported yet.","title":"CREATE INDEX"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#create-index","text":"","title":"CREATE INDEX"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#description","text":"Create an index on a table column.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#syntax","text":"> CREATE INDEX index_name ON table_name (column_name)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#examples","text":"> CREATE INDEX PIndex ON Persons (LastName);","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#constraints","text":"The index can only be applied for a single column. The index type, UNIQUE/FULLTEXT statements are not supported yet.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/","text":"CREATE TABLE Description Create a new table. Syntax > CREATE TABLE [IF NOT EXISTS] [db.]table_name ( name1 type1, name2 type2, ... ) create_table_statement Examples > CREATE TABLE test(a int, b varchar(10)); > INSERT INTO test values(123, 'abc'); > SELECT * FROM test; +------+---------+ | a | b | +------+---------+ | 123 | abc | +------+---------+","title":"CREATE TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#create-table","text":"","title":"CREATE TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#description","text":"Create a new table.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#syntax","text":"> CREATE TABLE [IF NOT EXISTS] [db.]table_name ( name1 type1, name2 type2, ... )","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#create_table_statement","text":"","title":"create_table_statement"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#examples","text":"> CREATE TABLE test(a int, b varchar(10)); > INSERT INTO test values(123, 'abc'); > SELECT * FROM test; +------+---------+ | a | b | +------+---------+ | 123 | abc | +------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/","text":"DROP DATABASE Description Drop a database. Syntax > DROP DATABASE [IF EXISTS] <database_name> drop_database_statement Examples > DROP DATABASE test01;","title":"DROP DATABASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#drop-database","text":"","title":"DROP DATABASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#description","text":"Drop a database.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#syntax","text":"> DROP DATABASE [IF EXISTS] <database_name>","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#drop_database_statement","text":"","title":"drop_database_statement"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#examples","text":"> DROP DATABASE test01;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/","text":"DROP INDEX Description DROP INDEX drops the index named index_name from the table table_name. Syntax > DROP INDEX index_name ON table_name; Examples > DROP INDEX PIndex ON Persons;","title":"DROP INDEX"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/#drop-index","text":"","title":"DROP INDEX"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/#description","text":"DROP INDEX drops the index named index_name from the table table_name.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/#syntax","text":"> DROP INDEX index_name ON table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/#examples","text":"> DROP INDEX PIndex ON Persons;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/","text":"DROP TABLE Description Deletes the table. Syntax > DROP TABLE [IF EXISTS] [db.]name drop_table_statement Examples > CREATE TABLE table01(a int); > DROP TABLE table01;","title":"DROP TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#drop-table","text":"","title":"DROP TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#description","text":"Deletes the table.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#syntax","text":"> DROP TABLE [IF EXISTS] [db.]name","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#drop_table_statement","text":"","title":"drop_table_statement"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#examples","text":"> CREATE TABLE table01(a int); > DROP TABLE table01;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/primary-key/","text":"PRIMARY KEY Description The PRIMARY KEY constraint uniquely identifies each record in a table. Primary keys must contain UNIQUE values, and cannot contain NULL values. A table can have only ONE primary key; and in the table, this primary key can consist of single or multiple columns (fields). SQL PRIMARY KEY on CREATE TABLE The following SQL creates a PRIMARY KEY on the \"ID\" column when the \"Persons\" table is created: > CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, PRIMARY KEY (ID) ); To allow naming of a PRIMARY KEY constraint, and for defining a PRIMARY KEY constraint on multiple columns, use the following SQL syntax: > CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, CONSTRAINT PK_Person PRIMARY KEY (ID,LastName) ); note In the example above there is only ONE PRIMARY KEY (PK_Person). However, the VALUE of the primary key is made up of TWO COLUMNS (ID + LastName). Constraints DROP PRIMARY KEY is not supported yet.","title":"PRIMARY KEY"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/primary-key/#primary-key","text":"","title":"PRIMARY KEY"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/primary-key/#description","text":"The PRIMARY KEY constraint uniquely identifies each record in a table. Primary keys must contain UNIQUE values, and cannot contain NULL values. A table can have only ONE primary key; and in the table, this primary key can consist of single or multiple columns (fields).","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/primary-key/#sql-primary-key-on-create-table","text":"The following SQL creates a PRIMARY KEY on the \"ID\" column when the \"Persons\" table is created: > CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, PRIMARY KEY (ID) ); To allow naming of a PRIMARY KEY constraint, and for defining a PRIMARY KEY constraint on multiple columns, use the following SQL syntax: > CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, CONSTRAINT PK_Person PRIMARY KEY (ID,LastName) ); note In the example above there is only ONE PRIMARY KEY (PK_Person). However, the VALUE of the primary key is made up of TWO COLUMNS (ID + LastName).","title":"SQL PRIMARY KEY on CREATE TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/primary-key/#constraints","text":"DROP PRIMARY KEY is not supported yet.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/case/","text":"CASE Description The CASE statement for stored programs implements a complex conditional construct. Note: There is also a CASE operator, which differs from the CASE statement described here. See Flow Control Functions . The CASE statement cannot have an ELSE NULL clause, and it is terminated with END CASE instead of END . If no when_value or search_condition matches the value tested and the CASE statement contains no ELSE clause, a Case not found for CASE statement error results. Each statement_list consists of one or more SQL statements; an empty statement_list is not permitted. Syntax Syntax 1 CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE For the first syntax, case_value is an expression. This value is compared to the when_value expression in each WHEN clause until one of them is equal. When an equal when_value is found, the corresponding THEN clause statement_list executes. If no when_value is equal, the ELSE clause statement_list executes, if there is one. This syntax cannot be used to test for equality with NULL because NULL = NULL is false. Syntax 2 CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE For the second syntax, each WHEN clause search_condition expression is evaluated until one is true, at which point its corresponding THEN clause statement_list executes. If no search_condition is equal, the ELSE clause statement_list executes, if there is one. Examples > CREATE TABLE t1 ( c0 INTEGER , c1 INTEGER , c2 INTEGER ); > INSERT INTO t1 VALUES ( 1 , 1 , 1 ), ( 1 , 1 , 1 ); > SELECT CASE AVG ( c0 ) WHEN any_value ( c1 ) * any_value ( c2 ) THEN 1 END FROM t1 ; + ------------------------------------------------------------+ | case avg ( c0 ) when any_value ( c1 ) * any_value ( c2 ) then 1 end | + ------------------------------------------------------------+ | 1 | + ------------------------------------------------------------+ 1 row in set ( 0 . 01 sec ) > SELECT CASE any_value ( c1 ) * any_value ( c2 ) WHEN SUM ( c0 ) THEN 1 WHEN AVG ( c0 ) THEN 2 END FROM t1 ; + --------------------------------------------------------------------------------+ | case any_value ( c1 ) * any_value ( c2 ) when sum ( c0 ) then 1 when avg ( c0 ) then 2 end | + --------------------------------------------------------------------------------+ | 2 | + --------------------------------------------------------------------------------+ 1 row in set ( 0 . 01 sec ) > SELECT CASE any_value ( c1 ) WHEN any_value ( c1 ) + 1 THEN 1 END , ABS ( AVG ( c0 )) FROM t1 ; + ------------------------------------------------------+--------------+ | case any_value ( c1 ) when any_value ( c1 ) + 1 then 1 end | abs ( avg ( c0 )) | + ------------------------------------------------------+--------------+ | NULL | 1 | + ------------------------------------------------------+--------------+ 1 row in set ( 0 . 00 sec )","title":"CASE...WHEN..."},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/case/#case","text":"","title":"CASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/case/#description","text":"The CASE statement for stored programs implements a complex conditional construct. Note: There is also a CASE operator, which differs from the CASE statement described here. See Flow Control Functions . The CASE statement cannot have an ELSE NULL clause, and it is terminated with END CASE instead of END . If no when_value or search_condition matches the value tested and the CASE statement contains no ELSE clause, a Case not found for CASE statement error results. Each statement_list consists of one or more SQL statements; an empty statement_list is not permitted.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/case/#syntax","text":"","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/case/#syntax-1","text":"CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE For the first syntax, case_value is an expression. This value is compared to the when_value expression in each WHEN clause until one of them is equal. When an equal when_value is found, the corresponding THEN clause statement_list executes. If no when_value is equal, the ELSE clause statement_list executes, if there is one. This syntax cannot be used to test for equality with NULL because NULL = NULL is false.","title":"Syntax 1"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/case/#syntax-2","text":"CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE For the second syntax, each WHEN clause search_condition expression is evaluated until one is true, at which point its corresponding THEN clause statement_list executes. If no search_condition is equal, the ELSE clause statement_list executes, if there is one.","title":"Syntax 2"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/case/#examples","text":"> CREATE TABLE t1 ( c0 INTEGER , c1 INTEGER , c2 INTEGER ); > INSERT INTO t1 VALUES ( 1 , 1 , 1 ), ( 1 , 1 , 1 ); > SELECT CASE AVG ( c0 ) WHEN any_value ( c1 ) * any_value ( c2 ) THEN 1 END FROM t1 ; + ------------------------------------------------------------+ | case avg ( c0 ) when any_value ( c1 ) * any_value ( c2 ) then 1 end | + ------------------------------------------------------------+ | 1 | + ------------------------------------------------------------+ 1 row in set ( 0 . 01 sec ) > SELECT CASE any_value ( c1 ) * any_value ( c2 ) WHEN SUM ( c0 ) THEN 1 WHEN AVG ( c0 ) THEN 2 END FROM t1 ; + --------------------------------------------------------------------------------+ | case any_value ( c1 ) * any_value ( c2 ) when sum ( c0 ) then 1 when avg ( c0 ) then 2 end | + --------------------------------------------------------------------------------+ | 2 | + --------------------------------------------------------------------------------+ 1 row in set ( 0 . 01 sec ) > SELECT CASE any_value ( c1 ) WHEN any_value ( c1 ) + 1 THEN 1 END , ABS ( AVG ( c0 )) FROM t1 ; + ------------------------------------------------------+--------------+ | case any_value ( c1 ) when any_value ( c1 ) + 1 then 1 end | abs ( avg ( c0 )) | + ------------------------------------------------------+--------------+ | NULL | 1 | + ------------------------------------------------------+--------------+ 1 row in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/","text":"DELETE Description DELETE statement removes rows from a table. Syntax Single-Table Syntax DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name [[AS] tbl_alias] [PARTITION (partition_name [, partition_name] ...)] [WHERE where_condition] [ORDER BY ...] [LIMIT row_count] The DELETE statement deletes rows from tbl_name and returns the number of deleted rows. Explanations The conditions in the optional WHERE clause identify which rows to delete. With no WHERE clause, all rows are deleted. If the ORDER BY clause is specified, the rows are deleted in the order that is specified. -The LIMIT clause places a limit on the number of rows that can be deleted. Multiple-Table Syntax DELETE [LOW_PRIORITY] [QUICK] [IGNORE] tbl_name[.*] [, tbl_name[.*]] ... FROM table_references [WHERE where_condition] Or: DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name[.*] [, tbl_name[.*]] ... USING table_references [WHERE where_condition] Explanations The conditions in the optional WHERE clause identify which rows to delete. With no WHERE clause, all rows are deleted. Examples Single-Table Examples > CREATE TABLE t1 ( a bigint ( 3 ), b bigint ( 5 ) primary key ); > insert INTO t1 VALUES ( 1 , 1 ),( 1 , 2 ); > delete from t1 where a = 1 limit 1 ; > select * from t1 ; + ------+------+ | a | b | + ------+------+ | 1 | 2 | + ------+------+ Multiple-Table Examples > create table t11 ( a bigint NOT NULL , b int , primary key ( a )); > create table t12 ( a bigint NOT NULL , b int , primary key ( a )); > create table t2 ( a bigint NOT NULL , b int , primary key ( a )); > insert into t11 values ( 0 , 10 ),( 1 , 11 ),( 2 , 12 ); > insert into t12 values ( 33 , 10 ),( 0 , 11 ),( 2 , 12 ); > insert into t2 values ( 0 , 21 ),( 1 , 12 ),( 3 , 23 ); > delete from t11 where t11 . b <> ( select b from t2 where t11 . a = t2 . a ); > select * from t11 ; + ------+------+ | a | b | + ------+------+ | 2 | 12 | + ------+------+","title":"DELETE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/#delete","text":"","title":"DELETE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/#description","text":"DELETE statement removes rows from a table.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/#syntax","text":"","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/#single-table-syntax","text":"DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name [[AS] tbl_alias] [PARTITION (partition_name [, partition_name] ...)] [WHERE where_condition] [ORDER BY ...] [LIMIT row_count] The DELETE statement deletes rows from tbl_name and returns the number of deleted rows.","title":"Single-Table Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/#explanations","text":"The conditions in the optional WHERE clause identify which rows to delete. With no WHERE clause, all rows are deleted. If the ORDER BY clause is specified, the rows are deleted in the order that is specified. -The LIMIT clause places a limit on the number of rows that can be deleted.","title":"Explanations"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/#multiple-table-syntax","text":"DELETE [LOW_PRIORITY] [QUICK] [IGNORE] tbl_name[.*] [, tbl_name[.*]] ... FROM table_references [WHERE where_condition] Or: DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name[.*] [, tbl_name[.*]] ... USING table_references [WHERE where_condition]","title":"Multiple-Table Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/#explanations_1","text":"The conditions in the optional WHERE clause identify which rows to delete. With no WHERE clause, all rows are deleted.","title":"Explanations"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/delete/#examples","text":"Single-Table Examples > CREATE TABLE t1 ( a bigint ( 3 ), b bigint ( 5 ) primary key ); > insert INTO t1 VALUES ( 1 , 1 ),( 1 , 2 ); > delete from t1 where a = 1 limit 1 ; > select * from t1 ; + ------+------+ | a | b | + ------+------+ | 1 | 2 | + ------+------+ Multiple-Table Examples > create table t11 ( a bigint NOT NULL , b int , primary key ( a )); > create table t12 ( a bigint NOT NULL , b int , primary key ( a )); > create table t2 ( a bigint NOT NULL , b int , primary key ( a )); > insert into t11 values ( 0 , 10 ),( 1 , 11 ),( 2 , 12 ); > insert into t12 values ( 33 , 10 ),( 0 , 11 ),( 2 , 12 ); > insert into t2 values ( 0 , 21 ),( 1 , 12 ),( 3 , 23 ); > delete from t11 where t11 . b <> ( select b from t2 where t11 . a = t2 . a ); > select * from t11 ; + ------+------+ | a | b | + ------+------+ | 2 | 12 | + ------+------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert-into-select/","text":"INSERT INTO SELECT Description The INSERT INTO SELECT statement copies data from one table and inserts it into another table. The existing records in the target table are unaffected. Syntax INSERT INTO table2 (column1, column2, column3, ...) SELECT column1, column2, column3, ... FROM table1 WHERE condition; Examples > create table t1 ( id int , name varchar ( 10 )); > insert into t1 values ( 1 , 'a' ); > insert into t1 values ( 2 , 'b' ); > insert into t1 values ( 3 , 'c' ); > create table t2 ( id int , appname varchar ( 10 ), country varchar ( 10 )); > insert into t2 values ( 1 , 'appone' , 'CN' ); > insert into t2 values ( 2 , 'apptwo' , 'CN' ); > INSERT INTO t1 ( name ) > SELECT appname FROM t2 ; > Query OK , 2 rows affected ( 0 . 01 sec ) > select * from t1 ; + ------+--------+ | id | name | + ------+--------+ | 1 | a | | 2 | b | | 3 | c | | NULL | appone | | NULL | apptwo | + ------+--------+","title":"INSERT INTO SELECT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert-into-select/#insert-into-select","text":"","title":"INSERT INTO SELECT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert-into-select/#description","text":"The INSERT INTO SELECT statement copies data from one table and inserts it into another table. The existing records in the target table are unaffected.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert-into-select/#syntax","text":"INSERT INTO table2 (column1, column2, column3, ...) SELECT column1, column2, column3, ... FROM table1 WHERE condition;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert-into-select/#examples","text":"> create table t1 ( id int , name varchar ( 10 )); > insert into t1 values ( 1 , 'a' ); > insert into t1 values ( 2 , 'b' ); > insert into t1 values ( 3 , 'c' ); > create table t2 ( id int , appname varchar ( 10 ), country varchar ( 10 )); > insert into t2 values ( 1 , 'appone' , 'CN' ); > insert into t2 values ( 2 , 'apptwo' , 'CN' ); > INSERT INTO t1 ( name ) > SELECT appname FROM t2 ; > Query OK , 2 rows affected ( 0 . 01 sec ) > select * from t1 ; + ------+--------+ | id | name | + ------+--------+ | 1 | a | | 2 | b | | 3 | c | | NULL | appone | | NULL | apptwo | + ------+--------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/","text":"INSERT Description Writing data. Syntax > INSERT INTO [db.]table [(c1, c2, c3)] VALUES (v11, v12, v13), (v21, v22, v23), ... Examples > CREATE TABLE test ( a int , b varchar ( 10 )); > INSERT INTO test values ( 123 , 'abc' ); > SELECT * FROM test ; + ------+---------+ | a | b | + ------+---------+ | 123 | abc | + ------+---------+","title":"INSERT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/#insert","text":"","title":"INSERT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/#description","text":"Writing data.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/#syntax","text":"> INSERT INTO [db.]table [(c1, c2, c3)] VALUES (v11, v12, v13), (v21, v22, v23), ...","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/#examples","text":"> CREATE TABLE test ( a int , b varchar ( 10 )); > INSERT INTO test values ( 123 , 'abc' ); > SELECT * FROM test ; + ------+---------+ | a | b | + ------+---------+ | 123 | abc | + ------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/interval/","text":"INTERVAL Description The INTERVAL values are used mainly for date and time calculations. Syntax > INTERVAL (expr,unit) Examples > select INTERVAL 1 DAY + \"1997-12-31\" ; + -------------------------------+ | interval ( 1 , day ) + 1997 - 12 - 31 | + -------------------------------+ | 1998 - 01 - 01 | + -------------------------------+ 1 row in set ( 0 . 01 sec )","title":"INTERVAL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/interval/#interval","text":"","title":"INTERVAL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/interval/#description","text":"The INTERVAL values are used mainly for date and time calculations.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/interval/#syntax","text":"> INTERVAL (expr,unit)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/interval/#examples","text":"> select INTERVAL 1 DAY + \"1997-12-31\" ; + -------------------------------+ | interval ( 1 , day ) + 1997 - 12 - 31 | + -------------------------------+ | 1998 - 01 - 01 | + -------------------------------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/","text":"JOIN Description The JOIN statement is used to combine rows from two or more tables. The following figure shows seven usages of LEFT JOIN , RIGHT JOIN , INNER JOIN , and OUTER JOIN . LEFT JOIN SELECT / FROM TableA A LEFT JOIN TableB B ON A.Key=B.Key SELECT / FROM TableA A LEFT JOIN TableB B ON A.Key=B.Key WHERE B.Key IS NULL RIGHT JOIN SELECT / FROM TableA A RIGHT JOIN TableB B ON A.Key=B.Key SELECT / FROM TableA A RIGHT JOIN TableB B ON A.Key=B.Key WHERE A.Key IS NULL INNER JOIN SELECT / FROM TableA A INNER JOIN TableB B ON A.Key=B.Key FULL JOIN SELECT / FROM TableA A FULL OUTER JOIN TableB B ON A.Key=B.Key SELECT / FROM TableA A FULL OUTER JOIN TableB B ON A.Key=B.Key WHERE A.Key IS NULL OR B.Key IS NULL For more information, see the reference below: LEFT JOIN RIGHT JOIN INNER JOIN FULL JOIN","title":"JOIN Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/#join","text":"","title":"JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/#description","text":"The JOIN statement is used to combine rows from two or more tables. The following figure shows seven usages of LEFT JOIN , RIGHT JOIN , INNER JOIN , and OUTER JOIN . LEFT JOIN SELECT / FROM TableA A LEFT JOIN TableB B ON A.Key=B.Key SELECT / FROM TableA A LEFT JOIN TableB B ON A.Key=B.Key WHERE B.Key IS NULL RIGHT JOIN SELECT / FROM TableA A RIGHT JOIN TableB B ON A.Key=B.Key SELECT / FROM TableA A RIGHT JOIN TableB B ON A.Key=B.Key WHERE A.Key IS NULL INNER JOIN SELECT / FROM TableA A INNER JOIN TableB B ON A.Key=B.Key FULL JOIN SELECT / FROM TableA A FULL OUTER JOIN TableB B ON A.Key=B.Key SELECT / FROM TableA A FULL OUTER JOIN TableB B ON A.Key=B.Key WHERE A.Key IS NULL OR B.Key IS NULL For more information, see the reference below: LEFT JOIN RIGHT JOIN INNER JOIN FULL JOIN","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/","text":"LOAD DATA Description The LOAD DATA statement reads rows from a text file into a table at a very high speed. Syntax > LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name' [REPLACE | IGNORE] INTO TABLE tbl_name [PARTITION (partition_name [, partition_name] ...)] [CHARACTER SET charset_name] [{FIELDS | COLUMNS} [TERMINATED BY 'string'] [[OPTIONALLY] ENCLOSED BY 'char'] [ESCAPED BY 'char'] ] [LINES [STARTING BY 'string'] [TERMINATED BY 'string'] ] [IGNORE number {LINES | ROWS}] [(col_name_or_user_var [, col_name_or_user_var] ...)] [SET col_name={expr | DEFAULT} [, col_name={expr | DEFAULT}] ...] Examples The SSB Test is an example of LOAD DATA syntax. Complete a SSB Test with MatrixOne > LOAD DATA INFILE '/ssb-dbgen-path/lineorder_flat.tbl ' INTO TABLE lineorder_flat;","title":"LOAD DATA"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/#load-data","text":"","title":"LOAD DATA"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/#description","text":"The LOAD DATA statement reads rows from a text file into a table at a very high speed.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/#syntax","text":"> LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name' [REPLACE | IGNORE] INTO TABLE tbl_name [PARTITION (partition_name [, partition_name] ...)] [CHARACTER SET charset_name] [{FIELDS | COLUMNS} [TERMINATED BY 'string'] [[OPTIONALLY] ENCLOSED BY 'char'] [ESCAPED BY 'char'] ] [LINES [STARTING BY 'string'] [TERMINATED BY 'string'] ] [IGNORE number {LINES | ROWS}] [(col_name_or_user_var [, col_name_or_user_var] ...)] [SET col_name={expr | DEFAULT} [, col_name={expr | DEFAULT}] ...]","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/#examples","text":"The SSB Test is an example of LOAD DATA syntax. Complete a SSB Test with MatrixOne > LOAD DATA INFILE '/ssb-dbgen-path/lineorder_flat.tbl ' INTO TABLE lineorder_flat;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/","text":"Operators Overview Arithmetic Operators Name Description %,MOD Modulo operator * Multiplication operator + Addition operator - Minus operator - Change the sign of the argument / Division operator DIV Integer division Assignment Operators Name Description = Equal operator Cast Functions and Operators Name Description CAST() Cast a value as a certain type CONVERT() Cast a value as a certain type Comparison Functions and Operators Name Description > Greater than operator >= Greater than or equal operator < Less than operator <>,!= Not equal operator <= Less than or equal operator = Equal operator BETWEEN ... AND ... Whether a value is within a range of values IN() Whether a value is within a set of values IS Test a value against a boolean IS NOT Test a value against a boolean IS NOT NULL NOT NULL value test IS NULL NULL value test LIKE Simple pattern matching NOT BETWEEN ... AND ... Whether a value is not within a range of values NOT LIKE Negation of simple pattern matching Flow Control Functions Name Description CASE Case operator IF() If/else construct Logical Operators Name Description AND,&& Logical AND NOT,! Negates value OR Logical OR XOR Logical XOR","title":"OPERATORS Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/#operators-overview","text":"","title":"Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/#arithmetic-operators","text":"Name Description %,MOD Modulo operator * Multiplication operator + Addition operator - Minus operator - Change the sign of the argument / Division operator DIV Integer division","title":"Arithmetic Operators"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/#assignment-operators","text":"Name Description = Equal operator","title":"Assignment Operators"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/#cast-functions-and-operators","text":"Name Description CAST() Cast a value as a certain type CONVERT() Cast a value as a certain type","title":"Cast Functions and Operators"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/#comparison-functions-and-operators","text":"Name Description > Greater than operator >= Greater than or equal operator < Less than operator <>,!= Not equal operator <= Less than or equal operator = Equal operator BETWEEN ... AND ... Whether a value is within a range of values IN() Whether a value is within a set of values IS Test a value against a boolean IS NOT Test a value against a boolean IS NOT NULL NOT NULL value test IS NULL NULL value test LIKE Simple pattern matching NOT BETWEEN ... AND ... Whether a value is not within a range of values NOT LIKE Negation of simple pattern matching","title":"Comparison Functions and Operators"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/#flow-control-functions","text":"Name Description CASE Case operator IF() If/else construct","title":"Flow Control Functions"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/#logical-operators","text":"Name Description AND,&& Logical AND NOT,! Negates value OR Logical OR XOR Logical XOR","title":"Logical Operators"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/","text":"SELECT Description Retrieves data from a table. Syntax > SELECT [ ALL | DISTINCT ] select_expr [[ AS ] alias ], ... [ INTO variable [, ...]] [ FROM table_references [ WHERE expr ] [ GROUP BY {{ col_name | expr | position } , ... | extended_grouping_expr } ] [ HAVING expr ] [ ORDER BY { col_name | expr } [ ASC | DESC ], ...] [ LIMIT row_count ] [ OFFSET row_count ] ] SELECT INTO SELECT INTO statement enables a query result to be stored in variables or written to a file SELECT ... INTO var_list selects column values and stores them into variables. SELECT ... INTO OUTFILE writes the selected rows to a file. Column and line terminators can be specified to produce a specific output format. > SELECT < expr_list > INTO OUTFILE 'file_name' [ { FIELDS } [ TERMINATED BY 'char' ] [ ENCLOSED BY 'char' ] ] [ LINES [ TERMINATED BY 'string' ] ] [ HEADER 'bool' ] [ MAX_FILE_SIZE long ] [ FORCE_QUOTE { 'col1' , 'col2' ,... } ] Explanations <expr_list> is the query result you want to export. 'file_name' is the file name of the absolute path on the server. The query will fail if a file with the same filename already exists. And the front folder written in the absolute path must be created in advance, otherwise an error will occur. TERMINATED BY is an optional argument as the field separator. The default value is comma , . ENCLOSED BY is an optional argument as the inclusion character of column fields. The default value is double quotations \" . LINES TERMINATED BY is an optional argument as the end of a line. The default value is \\n . When HEADER is TRUE , the table's title will also be exported, vice versa. You can limit the maximum size of the file using MAX_FILE_SIZE in KB. For example, with MAX_FILE_SIZE =5242880(5GB), tables with size of 10GB are exported as two files distinguished by the ordinal number in their name. When this value is not set, one file will be exported by default. FORCE_QUOTE is used to add double quotes for every NOT NULL value in the specified column. NULL values will be exported as \\N . HAVING specifies conditions on groups, typically formed by the GROUP BY clause. The query result includes only groups satisfying the HAVING conditions. (If no GROUP BY is present, all rows implicitly form a single aggregate group.) The HAVING clause, like the WHERE clause, specifies selection conditions. The WHERE clause specifies conditions on columns in the select list, but cannot refer to aggregate functions. The SQL standard requires that HAVING must reference only columns in the GROUP BY clause or columns used in aggregate functions. If the HAVING clause refers to a column that is ambiguous, a warning occurs. Info If MAX_FILE_SIZE is not set, a large file may be exported and the operation may fail. Therefore, we recommend you to set this value case by case. Constraints The query will fail if a file with the same filename already exists. Only .csv types of files are supported currently. Currently, this command supports only the absolute path, and files can be exported only to the server host, not to the remote client. Examples > SELECT number FROM numbers ( 3 ); + --------+ | number | + --------+ | 0 | | 1 | | 2 | + --------+ > SELECT * FROM t1 WHERE spID > 2 AND userID < 2 || userID >= 2 OR userID < 2 LIMIT 3 ; > SELECT userID , MAX ( score ) max_score FROM t1 WHERE userID < 2 || userID > 3 GROUP BY userID ORDER BY max_score ; select * from t1 into outfile '/Users/tmp/test.csv' FIELDS TERMINATED BY ',' ENCLOSED BY '\"' LINES TERMINATED BY '\\n' header 'TRUE' MAX_FILE_SIZE 9223372036854775807 FORCE_QUOTE ( a , b ) > create table t1 ( spID int , userID int , score smallint ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , count ( score ) from t1 group by userID having count ( score ) > 1 order by userID ; + --------+--------------+ | userid | count ( score ) | + --------+--------------+ | 1 | 3 | + --------+--------------+ > select userID , count ( score ) from t1 where userID > 2 group by userID having count ( score ) > 1 order by userID ; Empty set ( 0 . 01 sec ) s","title":"SELECT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#select","text":"","title":"SELECT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#description","text":"Retrieves data from a table.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#syntax","text":"> SELECT [ ALL | DISTINCT ] select_expr [[ AS ] alias ], ... [ INTO variable [, ...]] [ FROM table_references [ WHERE expr ] [ GROUP BY {{ col_name | expr | position } , ... | extended_grouping_expr } ] [ HAVING expr ] [ ORDER BY { col_name | expr } [ ASC | DESC ], ...] [ LIMIT row_count ] [ OFFSET row_count ] ]","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#select-into","text":"SELECT INTO statement enables a query result to be stored in variables or written to a file SELECT ... INTO var_list selects column values and stores them into variables. SELECT ... INTO OUTFILE writes the selected rows to a file. Column and line terminators can be specified to produce a specific output format. > SELECT < expr_list > INTO OUTFILE 'file_name' [ { FIELDS } [ TERMINATED BY 'char' ] [ ENCLOSED BY 'char' ] ] [ LINES [ TERMINATED BY 'string' ] ] [ HEADER 'bool' ] [ MAX_FILE_SIZE long ] [ FORCE_QUOTE { 'col1' , 'col2' ,... } ]","title":"SELECT INTO"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#explanations","text":"<expr_list> is the query result you want to export. 'file_name' is the file name of the absolute path on the server. The query will fail if a file with the same filename already exists. And the front folder written in the absolute path must be created in advance, otherwise an error will occur. TERMINATED BY is an optional argument as the field separator. The default value is comma , . ENCLOSED BY is an optional argument as the inclusion character of column fields. The default value is double quotations \" . LINES TERMINATED BY is an optional argument as the end of a line. The default value is \\n . When HEADER is TRUE , the table's title will also be exported, vice versa. You can limit the maximum size of the file using MAX_FILE_SIZE in KB. For example, with MAX_FILE_SIZE =5242880(5GB), tables with size of 10GB are exported as two files distinguished by the ordinal number in their name. When this value is not set, one file will be exported by default. FORCE_QUOTE is used to add double quotes for every NOT NULL value in the specified column. NULL values will be exported as \\N . HAVING specifies conditions on groups, typically formed by the GROUP BY clause. The query result includes only groups satisfying the HAVING conditions. (If no GROUP BY is present, all rows implicitly form a single aggregate group.) The HAVING clause, like the WHERE clause, specifies selection conditions. The WHERE clause specifies conditions on columns in the select list, but cannot refer to aggregate functions. The SQL standard requires that HAVING must reference only columns in the GROUP BY clause or columns used in aggregate functions. If the HAVING clause refers to a column that is ambiguous, a warning occurs. Info If MAX_FILE_SIZE is not set, a large file may be exported and the operation may fail. Therefore, we recommend you to set this value case by case.","title":"Explanations"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#constraints","text":"The query will fail if a file with the same filename already exists. Only .csv types of files are supported currently. Currently, this command supports only the absolute path, and files can be exported only to the server host, not to the remote client.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#examples","text":"> SELECT number FROM numbers ( 3 ); + --------+ | number | + --------+ | 0 | | 1 | | 2 | + --------+ > SELECT * FROM t1 WHERE spID > 2 AND userID < 2 || userID >= 2 OR userID < 2 LIMIT 3 ; > SELECT userID , MAX ( score ) max_score FROM t1 WHERE userID < 2 || userID > 3 GROUP BY userID ORDER BY max_score ; select * from t1 into outfile '/Users/tmp/test.csv' FIELDS TERMINATED BY ',' ENCLOSED BY '\"' LINES TERMINATED BY '\\n' header 'TRUE' MAX_FILE_SIZE 9223372036854775807 FORCE_QUOTE ( a , b ) > create table t1 ( spID int , userID int , score smallint ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , count ( score ) from t1 group by userID having count ( score ) > 1 order by userID ; + --------+--------------+ | userid | count ( score ) | + --------+--------------+ | 1 | 3 | + --------+--------------+ > select userID , count ( score ) from t1 where userID > 2 group by userID having count ( score ) > 1 order by userID ; Empty set ( 0 . 01 sec ) s","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/","text":"SHOW DATABASES Description Shows the list of databases that exist on the instance. Syntax > SHOW DATABASES [LIKE expr | WHERE expr] Examples > SHOW DATABASES ; + ----------+ | Database | + ----------+ | default | | for_test | | local | | ss | | ss1 | | ss2 | | ss3 | | system | | test | + ----------+ 9 rows in set ( 0 . 00 sec )","title":"SHOW DATABASES"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/#show-databases","text":"","title":"SHOW DATABASES"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/#description","text":"Shows the list of databases that exist on the instance.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/#syntax","text":"> SHOW DATABASES [LIKE expr | WHERE expr]","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/#examples","text":"> SHOW DATABASES ; + ----------+ | Database | + ----------+ | default | | for_test | | local | | ss | | ss1 | | ss2 | | ss3 | | system | | test | + ----------+ 9 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/","text":"SHOW TABLES Description Shows the list of tables in the currently selected database. Syntax > SHOW TABLES [LIKE 'pattern' | WHERE expr | FROM 'pattern' | IN 'pattern'] Examples > SHOW TABLES ; + ---------------+ | name | + ---------------+ | clusters | | contributors | | databases | | functions | | numbers | | numbers_local | | numbers_mt | | one | | processes | | settings | | tables | | tracing | + ---------------+","title":"SHOW TABLES"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/#show-tables","text":"","title":"SHOW TABLES"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/#description","text":"Shows the list of tables in the currently selected database.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/#syntax","text":"> SHOW TABLES [LIKE 'pattern' | WHERE expr | FROM 'pattern' | IN 'pattern']","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/#examples","text":"> SHOW TABLES ; + ---------------+ | name | + ---------------+ | clusters | | contributors | | databases | | functions | | numbers | | numbers_local | | numbers_mt | | one | | processes | | settings | | tables | | tracing | + ---------------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subquery/","text":"SUBQUERY A subquery is a SELECT statement within another statement. is a SQL query nested inside a larger query. Here is an example of a subquery: SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2); In this example, SELECT * FROM t1 ... is the outer query (or outer statement), and (SELECT column1 FROM t2) is the subquery. We say that the subquery is nested within the outer query, and in fact it is possible to nest subqueries within other subqueries, to a considerable depth. A subquery must always appear within parentheses. The main advantages of subqueries are: They allow queries that are structured so that it is possible to isolate each part of a statement. They provide alternative ways to perform operations that would otherwise require complex joins and unions. Many people find subqueries more readable than complex joins or unions. A subquery may occur in: A SELECT clause A FROM clause A WHERE clause For more information, see the reference below: FROM SUBQUERY SUBQUERY WITH ANY SUBQUERY WITH EXISTS SUBQUERY WITH IN","title":"SUBQUERY Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subquery/#subquery","text":"A subquery is a SELECT statement within another statement. is a SQL query nested inside a larger query. Here is an example of a subquery: SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2); In this example, SELECT * FROM t1 ... is the outer query (or outer statement), and (SELECT column1 FROM t2) is the subquery. We say that the subquery is nested within the outer query, and in fact it is possible to nest subqueries within other subqueries, to a considerable depth. A subquery must always appear within parentheses. The main advantages of subqueries are: They allow queries that are structured so that it is possible to isolate each part of a statement. They provide alternative ways to perform operations that would otherwise require complex joins and unions. Many people find subqueries more readable than complex joins or unions. A subquery may occur in: A SELECT clause A FROM clause A WHERE clause For more information, see the reference below: FROM SUBQUERY SUBQUERY WITH ANY SUBQUERY WITH EXISTS SUBQUERY WITH IN","title":"SUBQUERY"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/update/","text":"UPDATE Description The UPDATE statement is used to modify the existing records in a table. Syntax Single-table Syntax UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET assignment_list [WHERE where_condition] [ORDER BY ...] [LIMIT row_count] value: {expr | DEFAULT} assignment: col_name = value assignment_list: assignment [, assignment] ... Explanations The UPDATE statement updates columns of existing rows in the named table with new values. The SET clause indicates which columns to modify and the values they should be given. Each value can be given as an expression, or the keyword DEFAULT to set a column explicitly to its default value. The WHERE clause, if given, specifies the conditions that identify which rows to update. With no WHERE clause, all rows are updated. If the ORDER BY clause is specified, the rows are updated in the order that is specified. The LIMIT clause places a limit on the number of rows that can be updated. Examples Single-table Examples > CREATE TABLE t1 ( a bigint ( 3 ), b bigint ( 5 ) primary key ); > insert INTO t1 VALUES ( 1 , 1 ),( 1 , 2 ); > update t1 set a = 2 where a = 1 limit 1 ; > select * from t1 ; + ------+------+ | a | b | + ------+------+ | 2 | 1 | | 1 | 2 | + ------+------+ Constraints Multiple-table Syntax is not supported for now.","title":"UPDATE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/update/#update","text":"","title":"UPDATE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/update/#description","text":"The UPDATE statement is used to modify the existing records in a table.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/update/#syntax","text":"","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/update/#single-table-syntax","text":"UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET assignment_list [WHERE where_condition] [ORDER BY ...] [LIMIT row_count] value: {expr | DEFAULT} assignment: col_name = value assignment_list: assignment [, assignment] ...","title":"Single-table Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/update/#explanations","text":"The UPDATE statement updates columns of existing rows in the named table with new values. The SET clause indicates which columns to modify and the values they should be given. Each value can be given as an expression, or the keyword DEFAULT to set a column explicitly to its default value. The WHERE clause, if given, specifies the conditions that identify which rows to update. With no WHERE clause, all rows are updated. If the ORDER BY clause is specified, the rows are updated in the order that is specified. The LIMIT clause places a limit on the number of rows that can be updated.","title":"Explanations"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/update/#examples","text":"Single-table Examples > CREATE TABLE t1 ( a bigint ( 3 ), b bigint ( 5 ) primary key ); > insert INTO t1 VALUES ( 1 , 1 ),( 1 , 2 ); > update t1 set a = 2 where a = 1 limit 1 ; > select * from t1 ; + ------+------+ | a | b | + ------+------+ | 2 | 1 | | 1 | 2 | + ------+------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/update/#constraints","text":"Multiple-table Syntax is not supported for now.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/","text":"USE Description The USE statement tells MatrixOne to use the named database as the default (current) database for subsequent statements. Syntax > USE db_name Examples > USE db1 ; > SELECT COUNT ( * ) FROM mytable ;","title":"USE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/#use","text":"","title":"USE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/#description","text":"The USE statement tells MatrixOne to use the named database as the default (current) database for subsequent statements.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/#syntax","text":"> USE db_name","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/#examples","text":"> USE db1 ; > SELECT COUNT ( * ) FROM mytable ;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/with-cte/","text":"WITH (Common Table Expressions) Description A common table expression (CTE) is a named temporary result set that exists within the scope of a single statement and that can be referred to later within that statement, possibly multiple times. To specify common table expressions, use a WITH clause that has one or more comma-separated subclauses. Each sub-clause provides a subquery that produces a result set, and associates a name with the subquery. Syntax WITH cte_name ( column_name [,...n] ) AS ( CTE_query_definition \u2013- Anchor member is defined. ) Explanations In the statement containing the WITH clause, each CTE name can be referenced to access the corresponding CTE result set. Examples > CREATE TABLE t1 -> ( a INTEGER , -> b INTEGER , -> c INTEGER -> ); > INSERT INTO t1 VALUES -> ( 1 , 1 , 10 ), ( 1 , 2 , 20 ), ( 1 , 3 , 30 ), ( 2 , 1 , 40 ), ( 2 , 2 , 50 ), ( 2 , 3 , 60 ); > CREATE TABLE t2 -> ( a INTEGER , -> d INTEGER , -> e INTEGER -> ); > INSERT INTO t2 VALUES -> ( 1 , 6 , 60 ), ( 2 , 6 , 60 ), ( 3 , 6 , 60 ); > WITH -> cte AS -> ( SELECT SUM ( c ) AS c , SUM ( b ) AS b , a -> FROM t1 -> GROUP BY a ) -> SELECT t2 . a , ( SELECT MIN ( c ) FROM cte AS cte2 WHERE t2 . d = cte2 . b ) -> FROM t2 LEFT JOIN cte AS cte1 ON t2 . a = cte1 . a -> LEFT JOIN t2 AS tx ON tx . e = cte1 . c ; + ------+------------------------------------------------------+ | a | ( select min ( c ) from cte as cte2 where t2 . d = cte2 . b ) | + ------+------------------------------------------------------+ | 1 | 60 | | 1 | 60 | | 1 | 60 | | 2 | 60 | | 3 | 60 | + ------+------------------------------------------------------+ 5 rows in set ( 0 . 01 sec )","title":"With CTE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/with-cte/#with-common-table-expressions","text":"","title":"WITH (Common Table Expressions)"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/with-cte/#description","text":"A common table expression (CTE) is a named temporary result set that exists within the scope of a single statement and that can be referred to later within that statement, possibly multiple times. To specify common table expressions, use a WITH clause that has one or more comma-separated subclauses. Each sub-clause provides a subquery that produces a result set, and associates a name with the subquery.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/with-cte/#syntax","text":"WITH cte_name ( column_name [,...n] ) AS ( CTE_query_definition \u2013- Anchor member is defined. )","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/with-cte/#explanations","text":"In the statement containing the WITH clause, each CTE name can be referenced to access the corresponding CTE result set.","title":"Explanations"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/with-cte/#examples","text":"> CREATE TABLE t1 -> ( a INTEGER , -> b INTEGER , -> c INTEGER -> ); > INSERT INTO t1 VALUES -> ( 1 , 1 , 10 ), ( 1 , 2 , 20 ), ( 1 , 3 , 30 ), ( 2 , 1 , 40 ), ( 2 , 2 , 50 ), ( 2 , 3 , 60 ); > CREATE TABLE t2 -> ( a INTEGER , -> d INTEGER , -> e INTEGER -> ); > INSERT INTO t2 VALUES -> ( 1 , 6 , 60 ), ( 2 , 6 , 60 ), ( 3 , 6 , 60 ); > WITH -> cte AS -> ( SELECT SUM ( c ) AS c , SUM ( b ) AS b , a -> FROM t1 -> GROUP BY a ) -> SELECT t2 . a , ( SELECT MIN ( c ) FROM cte AS cte2 WHERE t2 . d = cte2 . b ) -> FROM t2 LEFT JOIN cte AS cte1 ON t2 . a = cte1 . a -> LEFT JOIN t2 AS tx ON tx . e = cte1 . c ; + ------+------------------------------------------------------+ | a | ( select min ( c ) from cte as cte2 where t2 . d = cte2 . b ) | + ------+------------------------------------------------------+ | 1 | 60 | | 1 | 60 | | 1 | 60 | | 2 | 60 | | 3 | 60 | + ------+------------------------------------------------------+ 5 rows in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/full-join/","text":"FULL JOIN Description The FULL JOIN keyword returns all records when there is a match in left (table1) or right (table2) table records. note FULL OUTER JOIN and FULL JOIN are the same. Syntax > SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name; Examples > drop table if exists t1 , t2 , t3 ; > create table t1 ( libname1 varchar ( 21 ) not null primary key , city varchar ( 20 )); > create table t2 ( isbn2 varchar ( 21 ) not null primary key , author varchar ( 20 ), title varchar ( 60 )); > create table t3 ( isbn3 varchar ( 21 ) not null , libname3 varchar ( 21 ) not null , quantity int ); > insert into t2 values ( '001' , 'Daffy' , 'Aducklife' ); > insert into t2 values ( '002' , 'Bugs' , 'Arabbitlife' ); > insert into t2 values ( '003' , 'Cowboy' , 'Lifeontherange' ); > insert into t2 values ( '000' , 'Anonymous' , 'Wannabuythisbook?' ); > insert into t2 values ( '004' , 'BestSeller' , 'OneHeckuvabook' ); > insert into t2 values ( '005' , 'EveryoneBuys' , 'Thisverybook' ); > insert into t2 values ( '006' , 'SanFran' , 'Itisasanfranlifestyle' ); > insert into t2 values ( '007' , 'BerkAuthor' , 'Cool.Berkley.the.book' ); > insert into t3 values ( '000' , 'NewYorkPublicLibra' , 1 ); > insert into t3 values ( '001' , 'NewYorkPublicLibra' , 2 ); > insert into t3 values ( '002' , 'NewYorkPublicLibra' , 3 ); > insert into t3 values ( '003' , 'NewYorkPublicLibra' , 4 ); > insert into t3 values ( '004' , 'NewYorkPublicLibra' , 5 ); > insert into t3 values ( '005' , 'NewYorkPublicLibra' , 6 ); > insert into t3 values ( '006' , 'SanFransiscoPublic' , 5 ); > insert into t3 values ( '007' , 'BerkeleyPublic1' , 3 ); > insert into t3 values ( '007' , 'BerkeleyPublic2' , 3 ); > insert into t3 values ( '001' , 'NYC Lib' , 8 ); > insert into t1 values ( 'NewYorkPublicLibra' , 'NewYork' ); > insert into t1 values ( 'SanFransiscoPublic' , 'SanFran' ); > insert into t1 values ( 'BerkeleyPublic1' , 'Berkeley' ); > insert into t1 values ( 'BerkeleyPublic2' , 'Berkeley' ); > insert into t1 values ( 'NYCLib' , 'NewYork' ); > select city , libname1 , count ( libname1 ) as a from t3 full join t1 on libname1 = libname3 join t2 on isbn3 = isbn2 group by city , libname1 ; + ----------+--------------------+------+ | city | libname1 | a | + ----------+--------------------+------+ | NewYork | NewYorkPublicLibra | 6 | | SanFran | SanFransiscoPublic | 1 | | Berkeley | BerkeleyPublic1 | 1 | | Berkeley | BerkeleyPublic2 | 1 | + ----------+--------------------+------+","title":"FULL JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/full-join/#full-join","text":"","title":"FULL JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/full-join/#description","text":"The FULL JOIN keyword returns all records when there is a match in left (table1) or right (table2) table records. note FULL OUTER JOIN and FULL JOIN are the same.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/full-join/#syntax","text":"> SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/full-join/#examples","text":"> drop table if exists t1 , t2 , t3 ; > create table t1 ( libname1 varchar ( 21 ) not null primary key , city varchar ( 20 )); > create table t2 ( isbn2 varchar ( 21 ) not null primary key , author varchar ( 20 ), title varchar ( 60 )); > create table t3 ( isbn3 varchar ( 21 ) not null , libname3 varchar ( 21 ) not null , quantity int ); > insert into t2 values ( '001' , 'Daffy' , 'Aducklife' ); > insert into t2 values ( '002' , 'Bugs' , 'Arabbitlife' ); > insert into t2 values ( '003' , 'Cowboy' , 'Lifeontherange' ); > insert into t2 values ( '000' , 'Anonymous' , 'Wannabuythisbook?' ); > insert into t2 values ( '004' , 'BestSeller' , 'OneHeckuvabook' ); > insert into t2 values ( '005' , 'EveryoneBuys' , 'Thisverybook' ); > insert into t2 values ( '006' , 'SanFran' , 'Itisasanfranlifestyle' ); > insert into t2 values ( '007' , 'BerkAuthor' , 'Cool.Berkley.the.book' ); > insert into t3 values ( '000' , 'NewYorkPublicLibra' , 1 ); > insert into t3 values ( '001' , 'NewYorkPublicLibra' , 2 ); > insert into t3 values ( '002' , 'NewYorkPublicLibra' , 3 ); > insert into t3 values ( '003' , 'NewYorkPublicLibra' , 4 ); > insert into t3 values ( '004' , 'NewYorkPublicLibra' , 5 ); > insert into t3 values ( '005' , 'NewYorkPublicLibra' , 6 ); > insert into t3 values ( '006' , 'SanFransiscoPublic' , 5 ); > insert into t3 values ( '007' , 'BerkeleyPublic1' , 3 ); > insert into t3 values ( '007' , 'BerkeleyPublic2' , 3 ); > insert into t3 values ( '001' , 'NYC Lib' , 8 ); > insert into t1 values ( 'NewYorkPublicLibra' , 'NewYork' ); > insert into t1 values ( 'SanFransiscoPublic' , 'SanFran' ); > insert into t1 values ( 'BerkeleyPublic1' , 'Berkeley' ); > insert into t1 values ( 'BerkeleyPublic2' , 'Berkeley' ); > insert into t1 values ( 'NYCLib' , 'NewYork' ); > select city , libname1 , count ( libname1 ) as a from t3 full join t1 on libname1 = libname3 join t2 on isbn3 = isbn2 group by city , libname1 ; + ----------+--------------------+------+ | city | libname1 | a | + ----------+--------------------+------+ | NewYork | NewYorkPublicLibra | 6 | | SanFran | SanFransiscoPublic | 1 | | Berkeley | BerkeleyPublic1 | 1 | | Berkeley | BerkeleyPublic2 | 1 | + ----------+--------------------+------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/inner-join/","text":"INNER JOIN Description The INNER JOIN keyword selects records that have matching values in both tables.(Same as JOIN ) Syntax > SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; Examples > drop table if exists t1 , t2 , t3 ; > create table t1 ( libname1 varchar ( 21 ) not null primary key , city varchar ( 20 )); > create table t2 ( isbn2 varchar ( 21 ) not null primary key , author varchar ( 20 ), title varchar ( 60 )); > create table t3 ( isbn3 varchar ( 21 ) not null , libname3 varchar ( 21 ) not null , quantity int ); > insert into t2 values ( '001' , 'Daffy' , 'Aducklife' ); > insert into t2 values ( '002' , 'Bugs' , 'Arabbitlife' ); > insert into t2 values ( '003' , 'Cowboy' , 'Lifeontherange' ); > insert into t2 values ( '000' , 'Anonymous' , 'Wannabuythisbook?' ); > insert into t2 values ( '004' , 'BestSeller' , 'OneHeckuvabook' ); > insert into t2 values ( '005' , 'EveryoneBuys' , 'Thisverybook' ); > insert into t2 values ( '006' , 'SanFran' , 'Itisasanfranlifestyle' ); > insert into t2 values ( '007' , 'BerkAuthor' , 'Cool.Berkley.the.book' ); > insert into t3 values ( '000' , 'NewYorkPublicLibra' , 1 ); > insert into t3 values ( '001' , 'NewYorkPublicLibra' , 2 ); > insert into t3 values ( '002' , 'NewYorkPublicLibra' , 3 ); > insert into t3 values ( '003' , 'NewYorkPublicLibra' , 4 ); > insert into t3 values ( '004' , 'NewYorkPublicLibra' , 5 ); > insert into t3 values ( '005' , 'NewYorkPublicLibra' , 6 ); > insert into t3 values ( '006' , 'SanFransiscoPublic' , 5 ); > insert into t3 values ( '007' , 'BerkeleyPublic1' , 3 ); > insert into t3 values ( '007' , 'BerkeleyPublic2' , 3 ); > insert into t3 values ( '001' , 'NYC Lib' , 8 ); > insert into t1 values ( 'NewYorkPublicLibra' , 'NewYork' ); > insert into t1 values ( 'SanFransiscoPublic' , 'SanFran' ); > insert into t1 values ( 'BerkeleyPublic1' , 'Berkeley' ); > insert into t1 values ( 'BerkeleyPublic2' , 'Berkeley' ); > insert into t1 values ( 'NYCLib' , 'NewYork' ); > select city , libname1 , count ( libname1 ) as a from t3 join t1 on libname1 = libname3 join t2 on isbn3 = isbn2 group by city , libname1 ; + ----------+--------------------+------+ | city | libname1 | a | + ----------+--------------------+------+ | NewYork | NewYorkPublicLibra | 6 | | SanFran | SanFransiscoPublic | 1 | | Berkeley | BerkeleyPublic1 | 1 | | Berkeley | BerkeleyPublic2 | 1 | + ----------+--------------------+------+","title":"INNER JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/inner-join/#inner-join","text":"","title":"INNER JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/inner-join/#description","text":"The INNER JOIN keyword selects records that have matching values in both tables.(Same as JOIN )","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/inner-join/#syntax","text":"> SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/inner-join/#examples","text":"> drop table if exists t1 , t2 , t3 ; > create table t1 ( libname1 varchar ( 21 ) not null primary key , city varchar ( 20 )); > create table t2 ( isbn2 varchar ( 21 ) not null primary key , author varchar ( 20 ), title varchar ( 60 )); > create table t3 ( isbn3 varchar ( 21 ) not null , libname3 varchar ( 21 ) not null , quantity int ); > insert into t2 values ( '001' , 'Daffy' , 'Aducklife' ); > insert into t2 values ( '002' , 'Bugs' , 'Arabbitlife' ); > insert into t2 values ( '003' , 'Cowboy' , 'Lifeontherange' ); > insert into t2 values ( '000' , 'Anonymous' , 'Wannabuythisbook?' ); > insert into t2 values ( '004' , 'BestSeller' , 'OneHeckuvabook' ); > insert into t2 values ( '005' , 'EveryoneBuys' , 'Thisverybook' ); > insert into t2 values ( '006' , 'SanFran' , 'Itisasanfranlifestyle' ); > insert into t2 values ( '007' , 'BerkAuthor' , 'Cool.Berkley.the.book' ); > insert into t3 values ( '000' , 'NewYorkPublicLibra' , 1 ); > insert into t3 values ( '001' , 'NewYorkPublicLibra' , 2 ); > insert into t3 values ( '002' , 'NewYorkPublicLibra' , 3 ); > insert into t3 values ( '003' , 'NewYorkPublicLibra' , 4 ); > insert into t3 values ( '004' , 'NewYorkPublicLibra' , 5 ); > insert into t3 values ( '005' , 'NewYorkPublicLibra' , 6 ); > insert into t3 values ( '006' , 'SanFransiscoPublic' , 5 ); > insert into t3 values ( '007' , 'BerkeleyPublic1' , 3 ); > insert into t3 values ( '007' , 'BerkeleyPublic2' , 3 ); > insert into t3 values ( '001' , 'NYC Lib' , 8 ); > insert into t1 values ( 'NewYorkPublicLibra' , 'NewYork' ); > insert into t1 values ( 'SanFransiscoPublic' , 'SanFran' ); > insert into t1 values ( 'BerkeleyPublic1' , 'Berkeley' ); > insert into t1 values ( 'BerkeleyPublic2' , 'Berkeley' ); > insert into t1 values ( 'NYCLib' , 'NewYork' ); > select city , libname1 , count ( libname1 ) as a from t3 join t1 on libname1 = libname3 join t2 on isbn3 = isbn2 group by city , libname1 ; + ----------+--------------------+------+ | city | libname1 | a | + ----------+--------------------+------+ | NewYork | NewYorkPublicLibra | 6 | | SanFran | SanFransiscoPublic | 1 | | Berkeley | BerkeleyPublic1 | 1 | | Berkeley | BerkeleyPublic2 | 1 | + ----------+--------------------+------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/left-join/","text":"LEFT JOIN Description The LEFT JOIN keyword returns all records from the left table (table1), and the matching records from the right table (table2). The result is 0 records from the right side, if there is no match. note In some databases LEFT JOIN is called LEFT OUTER JOIN . Syntax > SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; Examples > drop table if exists t1 , t2 , t3 ; > create table t1 ( libname1 varchar ( 21 ) not null primary key , city varchar ( 20 )); > create table t2 ( isbn2 varchar ( 21 ) not null primary key , author varchar ( 20 ), title varchar ( 60 )); > create table t3 ( isbn3 varchar ( 21 ) not null , libname3 varchar ( 21 ) not null , quantity int ); > insert into t2 values ( '001' , 'Daffy' , 'Aducklife' ); > insert into t2 values ( '002' , 'Bugs' , 'Arabbitlife' ); > insert into t2 values ( '003' , 'Cowboy' , 'Lifeontherange' ); > insert into t2 values ( '000' , 'Anonymous' , 'Wannabuythisbook?' ); > insert into t2 values ( '004' , 'BestSeller' , 'OneHeckuvabook' ); > insert into t2 values ( '005' , 'EveryoneBuys' , 'Thisverybook' ); > insert into t2 values ( '006' , 'SanFran' , 'Itisasanfranlifestyle' ); > insert into t2 values ( '007' , 'BerkAuthor' , 'Cool.Berkley.the.book' ); > insert into t3 values ( '000' , 'NewYorkPublicLibra' , 1 ); > insert into t3 values ( '001' , 'NewYorkPublicLibra' , 2 ); > insert into t3 values ( '002' , 'NewYorkPublicLibra' , 3 ); > insert into t3 values ( '003' , 'NewYorkPublicLibra' , 4 ); > insert into t3 values ( '004' , 'NewYorkPublicLibra' , 5 ); > insert into t3 values ( '005' , 'NewYorkPublicLibra' , 6 ); > insert into t3 values ( '006' , 'SanFransiscoPublic' , 5 ); > insert into t3 values ( '007' , 'BerkeleyPublic1' , 3 ); > insert into t3 values ( '007' , 'BerkeleyPublic2' , 3 ); > insert into t3 values ( '001' , 'NYC Lib' , 8 ); > insert into t1 values ( 'NewYorkPublicLibra' , 'NewYork' ); > insert into t1 values ( 'SanFransiscoPublic' , 'SanFran' ); > insert into t1 values ( 'BerkeleyPublic1' , 'Berkeley' ); > insert into t1 values ( 'BerkeleyPublic2' , 'Berkeley' ); > insert into t1 values ( 'NYCLib' , 'NewYork' ); > select city , libname1 , count ( libname1 ) as a from t3 left join t1 on libname1 = libname3 join t2 on isbn3 = isbn2 group by city , libname1 ; + ----------+--------------------+------+ | city | libname1 | a | + ----------+--------------------+------+ | NewYork | NewYorkPublicLibra | 6 | | SanFran | SanFransiscoPublic | 1 | | Berkeley | BerkeleyPublic1 | 1 | | Berkeley | BerkeleyPublic2 | 1 | | NULL | NULL | 0 | + ----------+--------------------+------+","title":"LEFT JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/left-join/#left-join","text":"","title":"LEFT JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/left-join/#description","text":"The LEFT JOIN keyword returns all records from the left table (table1), and the matching records from the right table (table2). The result is 0 records from the right side, if there is no match. note In some databases LEFT JOIN is called LEFT OUTER JOIN .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/left-join/#syntax","text":"> SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/left-join/#examples","text":"> drop table if exists t1 , t2 , t3 ; > create table t1 ( libname1 varchar ( 21 ) not null primary key , city varchar ( 20 )); > create table t2 ( isbn2 varchar ( 21 ) not null primary key , author varchar ( 20 ), title varchar ( 60 )); > create table t3 ( isbn3 varchar ( 21 ) not null , libname3 varchar ( 21 ) not null , quantity int ); > insert into t2 values ( '001' , 'Daffy' , 'Aducklife' ); > insert into t2 values ( '002' , 'Bugs' , 'Arabbitlife' ); > insert into t2 values ( '003' , 'Cowboy' , 'Lifeontherange' ); > insert into t2 values ( '000' , 'Anonymous' , 'Wannabuythisbook?' ); > insert into t2 values ( '004' , 'BestSeller' , 'OneHeckuvabook' ); > insert into t2 values ( '005' , 'EveryoneBuys' , 'Thisverybook' ); > insert into t2 values ( '006' , 'SanFran' , 'Itisasanfranlifestyle' ); > insert into t2 values ( '007' , 'BerkAuthor' , 'Cool.Berkley.the.book' ); > insert into t3 values ( '000' , 'NewYorkPublicLibra' , 1 ); > insert into t3 values ( '001' , 'NewYorkPublicLibra' , 2 ); > insert into t3 values ( '002' , 'NewYorkPublicLibra' , 3 ); > insert into t3 values ( '003' , 'NewYorkPublicLibra' , 4 ); > insert into t3 values ( '004' , 'NewYorkPublicLibra' , 5 ); > insert into t3 values ( '005' , 'NewYorkPublicLibra' , 6 ); > insert into t3 values ( '006' , 'SanFransiscoPublic' , 5 ); > insert into t3 values ( '007' , 'BerkeleyPublic1' , 3 ); > insert into t3 values ( '007' , 'BerkeleyPublic2' , 3 ); > insert into t3 values ( '001' , 'NYC Lib' , 8 ); > insert into t1 values ( 'NewYorkPublicLibra' , 'NewYork' ); > insert into t1 values ( 'SanFransiscoPublic' , 'SanFran' ); > insert into t1 values ( 'BerkeleyPublic1' , 'Berkeley' ); > insert into t1 values ( 'BerkeleyPublic2' , 'Berkeley' ); > insert into t1 values ( 'NYCLib' , 'NewYork' ); > select city , libname1 , count ( libname1 ) as a from t3 left join t1 on libname1 = libname3 join t2 on isbn3 = isbn2 group by city , libname1 ; + ----------+--------------------+------+ | city | libname1 | a | + ----------+--------------------+------+ | NewYork | NewYorkPublicLibra | 6 | | SanFran | SanFransiscoPublic | 1 | | Berkeley | BerkeleyPublic1 | 1 | | Berkeley | BerkeleyPublic2 | 1 | | NULL | NULL | 0 | + ----------+--------------------+------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/natural-join/","text":"NATURAL JOIN Description The NATURAL JOIN of two tables is defined to be semantically equivalent to an INNER JOIN or a LEFT JOIN with a USING clause that names all columns that exist in both tables. Syntax > SELECT table_column1, table_column2... FROM table_name1 NATURAL JOIN table_name2; Examples > create table t1 ( id int , desc1 varchar ( 50 ), desc2 varchar ( 50 )); > create table t2 ( id int , desc3 varchar ( 50 ), desc4 varchar ( 50 )); > INSERT INTO t1 ( id , desc1 , desc2 ) VALUES ( 100 , 'desc11' , 'desc12' ),( 101 , 'desc21' , 'desc22' ),( 102 , 'desc31' , 'desc32' ); > INSERT INTO t2 ( id , desc3 , desc4 ) VALUES ( 101 , 'desc41' , 'desc42' ),( 103 , 'desc51' , 'desc52' ),( 105 , 'desc61' , 'desc62' ); > SELECT t1 . id , t2 . id , desc1 , desc2 , desc3 , desc4 FROM t1 NATURAL JOIN t2 ; + ------+------+--------+--------+--------+--------+ | id | id | desc1 | desc2 | desc3 | desc4 | + ------+------+--------+--------+--------+--------+ | 101 | 101 | desc21 | desc22 | desc41 | desc42 | + ------+------+--------+--------+--------+--------+ 1 row in set ( 0 . 00 sec )","title":"NATURAL JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/natural-join/#natural-join","text":"","title":"NATURAL JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/natural-join/#description","text":"The NATURAL JOIN of two tables is defined to be semantically equivalent to an INNER JOIN or a LEFT JOIN with a USING clause that names all columns that exist in both tables.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/natural-join/#syntax","text":"> SELECT table_column1, table_column2... FROM table_name1 NATURAL JOIN table_name2;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/natural-join/#examples","text":"> create table t1 ( id int , desc1 varchar ( 50 ), desc2 varchar ( 50 )); > create table t2 ( id int , desc3 varchar ( 50 ), desc4 varchar ( 50 )); > INSERT INTO t1 ( id , desc1 , desc2 ) VALUES ( 100 , 'desc11' , 'desc12' ),( 101 , 'desc21' , 'desc22' ),( 102 , 'desc31' , 'desc32' ); > INSERT INTO t2 ( id , desc3 , desc4 ) VALUES ( 101 , 'desc41' , 'desc42' ),( 103 , 'desc51' , 'desc52' ),( 105 , 'desc61' , 'desc62' ); > SELECT t1 . id , t2 . id , desc1 , desc2 , desc3 , desc4 FROM t1 NATURAL JOIN t2 ; + ------+------+--------+--------+--------+--------+ | id | id | desc1 | desc2 | desc3 | desc4 | + ------+------+--------+--------+--------+--------+ | 101 | 101 | desc21 | desc22 | desc41 | desc42 | + ------+------+--------+--------+--------+--------+ 1 row in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/outer-join/","text":"OUTER JOIN Description When performing an INNER JOIN , rows from either table that are unmatched in the other table are not returned. In an OUTER JOIN , unmatched rows in one or both tables can be returned. There are a few types of outer joins: LEFT JOIN returns only unmatched rows from the left table. For more information, see LEFT JOIN . RIGHT JOIN returns only unmatched rows from the right table.For more information, see LEFT JOIN . FULL OUTER JOIN returns unmatched rows from both tables.For more information, see LEFT JOIN . Examples create table t1 ( a1 int , a2 char ( 3 )); insert into t1 values ( 10 , 'aaa' ), ( 10 , null ), ( 10 , 'bbb' ), ( 20 , 'zzz' ); create table t2 ( a1 char ( 3 ), a2 int , a3 real ); insert into t2 values ( 'AAA' , 10 , 0 . 5 ); insert into t2 values ( 'BBB' , 20 , 1 . 0 ); select t1 . a1 , t1 . a2 , t2 . a1 , t2 . a2 from t1 left outer join t2 on t1 . a1 = 10 ; + ------+------+------+------+ | a1 | a2 | a1 | a2 | + ------+------+------+------+ | 10 | aaa | AAA | 10 | | 10 | aaa | BBB | 20 | | 10 | NULL | AAA | 10 | | 10 | NULL | BBB | 20 | | 10 | bbb | AAA | 10 | | 10 | bbb | BBB | 20 | | 20 | zzz | NULL | NULL | + ------+------+------+------+","title":"OUTER JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/outer-join/#outer-join","text":"","title":"OUTER JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/outer-join/#description","text":"When performing an INNER JOIN , rows from either table that are unmatched in the other table are not returned. In an OUTER JOIN , unmatched rows in one or both tables can be returned. There are a few types of outer joins: LEFT JOIN returns only unmatched rows from the left table. For more information, see LEFT JOIN . RIGHT JOIN returns only unmatched rows from the right table.For more information, see LEFT JOIN . FULL OUTER JOIN returns unmatched rows from both tables.For more information, see LEFT JOIN .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/outer-join/#examples","text":"create table t1 ( a1 int , a2 char ( 3 )); insert into t1 values ( 10 , 'aaa' ), ( 10 , null ), ( 10 , 'bbb' ), ( 20 , 'zzz' ); create table t2 ( a1 char ( 3 ), a2 int , a3 real ); insert into t2 values ( 'AAA' , 10 , 0 . 5 ); insert into t2 values ( 'BBB' , 20 , 1 . 0 ); select t1 . a1 , t1 . a2 , t2 . a1 , t2 . a2 from t1 left outer join t2 on t1 . a1 = 10 ; + ------+------+------+------+ | a1 | a2 | a1 | a2 | + ------+------+------+------+ | 10 | aaa | AAA | 10 | | 10 | aaa | BBB | 20 | | 10 | NULL | AAA | 10 | | 10 | NULL | BBB | 20 | | 10 | bbb | AAA | 10 | | 10 | bbb | BBB | 20 | | 20 | zzz | NULL | NULL | + ------+------+------+------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/right-join/","text":"RIGHT JOIN Description The RIGHT JOIN keyword returns all records from the right table (table2), and the matching records from the left table (table1). The result is NULL records from the left side, if there is no match. note In some databases RIGHT JOIN is called RIGHT OUTER JOIN . Syntax > SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name=table2.column_name; Examples > drop table if exists t1 , t2 , t3 ; > create table t1 ( libname1 varchar ( 21 ) not null primary key , city varchar ( 20 )); > create table t2 ( isbn2 varchar ( 21 ) not null primary key , author varchar ( 20 ), title varchar ( 60 )); > create table t3 ( isbn3 varchar ( 21 ) not null , libname3 varchar ( 21 ) not null , quantity int ); > insert into t2 values ( '001' , 'Daffy' , 'Aducklife' ); > insert into t2 values ( '002' , 'Bugs' , 'Arabbitlife' ); > insert into t2 values ( '003' , 'Cowboy' , 'Lifeontherange' ); > insert into t2 values ( '000' , 'Anonymous' , 'Wannabuythisbook?' ); > insert into t2 values ( '004' , 'BestSeller' , 'OneHeckuvabook' ); > insert into t2 values ( '005' , 'EveryoneBuys' , 'Thisverybook' ); > insert into t2 values ( '006' , 'SanFran' , 'Itisasanfranlifestyle' ); > insert into t2 values ( '007' , 'BerkAuthor' , 'Cool.Berkley.the.book' ); > insert into t3 values ( '000' , 'NewYorkPublicLibra' , 1 ); > insert into t3 values ( '001' , 'NewYorkPublicLibra' , 2 ); > insert into t3 values ( '002' , 'NewYorkPublicLibra' , 3 ); > insert into t3 values ( '003' , 'NewYorkPublicLibra' , 4 ); > insert into t3 values ( '004' , 'NewYorkPublicLibra' , 5 ); > insert into t3 values ( '005' , 'NewYorkPublicLibra' , 6 ); > insert into t3 values ( '006' , 'SanFransiscoPublic' , 5 ); > insert into t3 values ( '007' , 'BerkeleyPublic1' , 3 ); > insert into t3 values ( '007' , 'BerkeleyPublic2' , 3 ); > insert into t3 values ( '001' , 'NYC Lib' , 8 ); > insert into t1 values ( 'NewYorkPublicLibra' , 'NewYork' ); > insert into t1 values ( 'SanFransiscoPublic' , 'SanFran' ); > insert into t1 values ( 'BerkeleyPublic1' , 'Berkeley' ); > insert into t1 values ( 'BerkeleyPublic2' , 'Berkeley' ); > insert into t1 values ( 'NYCLib' , 'NewYork' ); > select city , libname1 , count ( libname1 ) as a from t3 right join t1 on libname1 = libname3 join t2 on isbn3 = isbn2 group by city , libname1 ; + ----------+--------------------+------+ | city | libname1 | a | + ----------+--------------------+------+ | NewYork | NewYorkPublicLibra | 6 | | SanFran | SanFransiscoPublic | 1 | | Berkeley | BerkeleyPublic1 | 1 | | Berkeley | BerkeleyPublic2 | 1 | + ----------+--------------------+------+","title":"RIGHT JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/right-join/#right-join","text":"","title":"RIGHT JOIN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/right-join/#description","text":"The RIGHT JOIN keyword returns all records from the right table (table2), and the matching records from the left table (table1). The result is NULL records from the left side, if there is no match. note In some databases RIGHT JOIN is called RIGHT OUTER JOIN .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/right-join/#syntax","text":"> SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name=table2.column_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/join/right-join/#examples","text":"> drop table if exists t1 , t2 , t3 ; > create table t1 ( libname1 varchar ( 21 ) not null primary key , city varchar ( 20 )); > create table t2 ( isbn2 varchar ( 21 ) not null primary key , author varchar ( 20 ), title varchar ( 60 )); > create table t3 ( isbn3 varchar ( 21 ) not null , libname3 varchar ( 21 ) not null , quantity int ); > insert into t2 values ( '001' , 'Daffy' , 'Aducklife' ); > insert into t2 values ( '002' , 'Bugs' , 'Arabbitlife' ); > insert into t2 values ( '003' , 'Cowboy' , 'Lifeontherange' ); > insert into t2 values ( '000' , 'Anonymous' , 'Wannabuythisbook?' ); > insert into t2 values ( '004' , 'BestSeller' , 'OneHeckuvabook' ); > insert into t2 values ( '005' , 'EveryoneBuys' , 'Thisverybook' ); > insert into t2 values ( '006' , 'SanFran' , 'Itisasanfranlifestyle' ); > insert into t2 values ( '007' , 'BerkAuthor' , 'Cool.Berkley.the.book' ); > insert into t3 values ( '000' , 'NewYorkPublicLibra' , 1 ); > insert into t3 values ( '001' , 'NewYorkPublicLibra' , 2 ); > insert into t3 values ( '002' , 'NewYorkPublicLibra' , 3 ); > insert into t3 values ( '003' , 'NewYorkPublicLibra' , 4 ); > insert into t3 values ( '004' , 'NewYorkPublicLibra' , 5 ); > insert into t3 values ( '005' , 'NewYorkPublicLibra' , 6 ); > insert into t3 values ( '006' , 'SanFransiscoPublic' , 5 ); > insert into t3 values ( '007' , 'BerkeleyPublic1' , 3 ); > insert into t3 values ( '007' , 'BerkeleyPublic2' , 3 ); > insert into t3 values ( '001' , 'NYC Lib' , 8 ); > insert into t1 values ( 'NewYorkPublicLibra' , 'NewYork' ); > insert into t1 values ( 'SanFransiscoPublic' , 'SanFran' ); > insert into t1 values ( 'BerkeleyPublic1' , 'Berkeley' ); > insert into t1 values ( 'BerkeleyPublic2' , 'Berkeley' ); > insert into t1 values ( 'NYCLib' , 'NewYork' ); > select city , libname1 , count ( libname1 ) as a from t3 right join t1 on libname1 = libname3 join t2 on isbn3 = isbn2 group by city , libname1 ; + ----------+--------------------+------+ | city | libname1 | a | + ----------+--------------------+------+ | NewYork | NewYorkPublicLibra | 6 | | SanFran | SanFransiscoPublic | 1 | | Berkeley | BerkeleyPublic1 | 1 | | Berkeley | BerkeleyPublic2 | 1 | + ----------+--------------------+------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/operator-precedence/","text":"Operator Precedence Operator precedences are shown in the following list, from highest precedence to the lowest. Operators that are shown together on a line have the same precedence. From highest precedence to the lowest Operators 1 INTERVAL 2 BINARY, COLLATE 3 ! 4 - (unary minus), ~ (unary bit inversion) 5 ^ 6 *, /, DIV, %, MOD 7 -, + 8 <<, >> 9 & 10 | 11 = (comparison), <=>, >=, >, <=, <, <>, !=, IS, LIKE, , IN, MEMBER OF 12 BETWEEN, CASE, WHEN, THEN, ELSE 13 NOT 14 AND, && 15 XOR 16 OR, || 17 = (assignment) The precedence of = depends on whether it is used as a comparison operator (=) or as an assignment operator (=). When used as a comparison operator, it has the same precedence as , >=, >, <=, <, <>, !=, IS, LIKE, and IN(). For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left.","title":"**Operator Precedence**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/operator-precedence/#operator-precedence","text":"Operator precedences are shown in the following list, from highest precedence to the lowest. Operators that are shown together on a line have the same precedence. From highest precedence to the lowest Operators 1 INTERVAL 2 BINARY, COLLATE 3 ! 4 - (unary minus), ~ (unary bit inversion) 5 ^ 6 *, /, DIV, %, MOD 7 -, + 8 <<, >> 9 & 10 | 11 = (comparison), <=>, >=, >, <=, <, <>, !=, IS, LIKE, , IN, MEMBER OF 12 BETWEEN, CASE, WHEN, THEN, ELSE 13 NOT 14 AND, && 15 XOR 16 OR, || 17 = (assignment) The precedence of = depends on whether it is used as a comparison operator (=) or as an assignment operator (=). When used as a comparison operator, it has the same precedence as , >=, >, <=, <, <>, !=, IS, LIKE, and IN(). For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left.","title":"Operator Precedence"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/addition/","text":"+ Description The + operator is used for addition. Syntax > SELECT value1+value2; > SELECT column1+column2... FROM table_name; Examples > select 1123 . 2333 + 1233 . 3331 ; + -----------------------+ | 1123 . 2333 + 1233 . 3331 | + -----------------------+ | 2356 . 5664 | + -----------------------+ 1 row in set ( 0 . 01 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 + 5 from t2 ; + --------+ | c1 + 5 | + --------+ | 2 | | 6 | + --------+ 2 rows in set ( 0 . 00 sec ) > select c1 + c2 from t2 ; + ---------+ | c1 + c2 | + ---------+ | - 1 | | 3 | + ---------+ 2 rows in set ( 0 . 00 sec )","title":"+"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/addition/#_1","text":"","title":"+"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/addition/#description","text":"The + operator is used for addition.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/addition/#syntax","text":"> SELECT value1+value2; > SELECT column1+column2... FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/addition/#examples","text":"> select 1123 . 2333 + 1233 . 3331 ; + -----------------------+ | 1123 . 2333 + 1233 . 3331 | + -----------------------+ | 2356 . 5664 | + -----------------------+ 1 row in set ( 0 . 01 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 + 5 from t2 ; + --------+ | c1 + 5 | + --------+ | 2 | | 6 | + --------+ 2 rows in set ( 0 . 00 sec ) > select c1 + c2 from t2 ; + ---------+ | c1 + c2 | + ---------+ | - 1 | | 3 | + ---------+ 2 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/arithmetic-operators-overview/","text":"Arithmetic Operators Overview Name Description %,MOD Modulo operator * Multiplication operator + Addition operator - Minus operator - Change the sign of the argument / Division operator DIV Integer division The usual arithmetic operators are available. The result is determined according to the following rules: In the case of - , + , and * , the result is calculated with BIGINT (64-bit) precision if both operands are integers. If both operands are integers and any of them are unsigned, the result is an unsigned integer. If any of the operands of a + , - , / , * , % is a real or string value, the precision of the result is the precision of the operand with the maximum precision. In division performed with / , the scale of the result when using two exact-value operands is the scale of the first operand plus the value of the div_precision_increment system variable. For example, the result of the expression 5.05 / 0.014 has a scale of 13 decimal places (360.7142857142857). These rules are applied for each operation, such that nested calculations imply the precision of each component. Hence, (14620 / 9432456) / (24250 / 9432456), resolves first to (0.0014) / (0.0026), with the final result having 16 decimal places (0.6028865979381443). Constraints Arithmetic operators only apply to numbers. To ensure that components and subcomponents of a calculation use the appropriate level of precision. See Cast Functions and Operators .","title":"Arithmetic Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/arithmetic-operators-overview/#arithmetic-operators-overview","text":"Name Description %,MOD Modulo operator * Multiplication operator + Addition operator - Minus operator - Change the sign of the argument / Division operator DIV Integer division The usual arithmetic operators are available. The result is determined according to the following rules: In the case of - , + , and * , the result is calculated with BIGINT (64-bit) precision if both operands are integers. If both operands are integers and any of them are unsigned, the result is an unsigned integer. If any of the operands of a + , - , / , * , % is a real or string value, the precision of the result is the precision of the operand with the maximum precision. In division performed with / , the scale of the result when using two exact-value operands is the scale of the first operand plus the value of the div_precision_increment system variable. For example, the result of the expression 5.05 / 0.014 has a scale of 13 decimal places (360.7142857142857). These rules are applied for each operation, such that nested calculations imply the precision of each component. Hence, (14620 / 9432456) / (24250 / 9432456), resolves first to (0.0014) / (0.0026), with the final result having 16 decimal places (0.6028865979381443).","title":"Arithmetic Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/arithmetic-operators-overview/#constraints","text":"Arithmetic operators only apply to numbers. To ensure that components and subcomponents of a calculation use the appropriate level of precision. See Cast Functions and Operators .","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/div/","text":"DIV Description The DIV operator is used for integer division. Discards from the division result any fractional part to the right of the decimal point. If either operand has a non-integer type, the operands are converted to DECIMAL and divided using DECIMAL arithmetic before converting the result to BIGINT . If the result exceeds BIGINT range, an error occurs. Syntax > SELECT value1 DIV value2; > SELECT column1 DIV column2... FROM table_name; Examples > SELECT 5 DIV 2 , - 5 DIV 2 , 5 DIV - 2 , - 5 DIV - 2 ; + ---------+----------+----------+-----------+ | 5 div 2 | - 5 div 2 | 5 div - 2 | - 5 div - 2 | + ---------+----------+----------+-----------+ | 2 | - 2 | - 2 | 2 | + ---------+----------+----------+-----------+ 1 row in set ( 0 . 00 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 DIV 3 from t2 ; + ----------+ | c1 div 3 | + ----------+ | - 1 | | 0 | + ----------+ 2 rows in set ( 0 . 00 sec ) > select c1 DIV c2 from t2 ; + -----------+ | c1 div c2 | + -----------+ | - 1 | | 0 | + -----------+ 2 rows in set ( 0 . 00 sec )","title":"DIV"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/div/#div","text":"","title":"DIV"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/div/#description","text":"The DIV operator is used for integer division. Discards from the division result any fractional part to the right of the decimal point. If either operand has a non-integer type, the operands are converted to DECIMAL and divided using DECIMAL arithmetic before converting the result to BIGINT . If the result exceeds BIGINT range, an error occurs.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/div/#syntax","text":"> SELECT value1 DIV value2; > SELECT column1 DIV column2... FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/div/#examples","text":"> SELECT 5 DIV 2 , - 5 DIV 2 , 5 DIV - 2 , - 5 DIV - 2 ; + ---------+----------+----------+-----------+ | 5 div 2 | - 5 div 2 | 5 div - 2 | - 5 div - 2 | + ---------+----------+----------+-----------+ | 2 | - 2 | - 2 | 2 | + ---------+----------+----------+-----------+ 1 row in set ( 0 . 00 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 DIV 3 from t2 ; + ----------+ | c1 div 3 | + ----------+ | - 1 | | 0 | + ----------+ 2 rows in set ( 0 . 00 sec ) > select c1 DIV c2 from t2 ; + -----------+ | c1 div c2 | + -----------+ | - 1 | | 0 | + -----------+ 2 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/division/","text":"/ Description The / operator is used for division. Syntax > SELECT value1/value2; > SELECT column1/column2... FROM table_name; Division by zero produces a error result. Examples > select 1123 . 2333 / 1233 . 3331 ; + -----------------------+ | 1123 . 2333 / 1233 . 3331 | + -----------------------+ | 0 . 9107298750029493 | + -----------------------+ 1 row in set ( 0 . 00 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 / 2 from t2 ; + --------+ | c1 / 2 | + --------+ | - 1 . 5 | | 0 . 5 | + --------+ 2 rows in set ( 0 . 00 sec ) > select c1 / c2 from t2 ; + ---------+ | c1 / c2 | + ---------+ | - 1 . 5 | | 0 . 5 | + ---------+ 2 rows in set ( 0 . 01 sec )","title":"/"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/division/#_1","text":"","title":"/"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/division/#description","text":"The / operator is used for division.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/division/#syntax","text":"> SELECT value1/value2; > SELECT column1/column2... FROM table_name; Division by zero produces a error result.","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/division/#examples","text":"> select 1123 . 2333 / 1233 . 3331 ; + -----------------------+ | 1123 . 2333 / 1233 . 3331 | + -----------------------+ | 0 . 9107298750029493 | + -----------------------+ 1 row in set ( 0 . 00 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 / 2 from t2 ; + --------+ | c1 / 2 | + --------+ | - 1 . 5 | | 0 . 5 | + --------+ 2 rows in set ( 0 . 00 sec ) > select c1 / c2 from t2 ; + ---------+ | c1 / c2 | + ---------+ | - 1 . 5 | | 0 . 5 | + ---------+ 2 rows in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/minus/","text":"- Description The - operator is used for subtraction. Syntax > SELECT value1-value2; > SELECT column1-column2... FROM table_name; Examples > select 1123 . 2333 - 1233 . 3331 ; + -----------------------+ | 1123 . 2333 - 1233 . 3331 | + -----------------------+ | - 110 . 09979999999996 | + -----------------------+ 1 row in set ( 0 . 00 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 - 5 from t2 ; + --------+ | c1 - 5 | + --------+ | - 8 | | - 4 | + --------+ 2 rows in set ( 0 . 00 sec ) > select c1 - c2 from t2 ; + ---------+ | c1 - c2 | + ---------+ | - 5 | | - 1 | + ---------+ 2 rows in set ( 0 . 01 sec )","title":"-"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/minus/#-","text":"","title":"-"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/minus/#description","text":"The - operator is used for subtraction.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/minus/#syntax","text":"> SELECT value1-value2; > SELECT column1-column2... FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/minus/#examples","text":"> select 1123 . 2333 - 1233 . 3331 ; + -----------------------+ | 1123 . 2333 - 1233 . 3331 | + -----------------------+ | - 110 . 09979999999996 | + -----------------------+ 1 row in set ( 0 . 00 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 - 5 from t2 ; + --------+ | c1 - 5 | + --------+ | - 8 | | - 4 | + --------+ 2 rows in set ( 0 . 00 sec ) > select c1 - c2 from t2 ; + ---------+ | c1 - c2 | + ---------+ | - 5 | | - 1 | + ---------+ 2 rows in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/mod/","text":"%,MOD Description The %,MOD operator is used for modulo operation. Returns the remainder of N divided by M. For more information. Syntax > SELECT N % M, N MOD M; Examples > select 12 mod 5 ; + --------+ | 12 % 5 | + --------+ | 2 | + --------+ 1 row in set ( 0 . 00 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 mod 2 from t2 ; + --------+ | c1 % 2 | + --------+ | - 1 | | 1 | + --------+ 2 rows in set ( 0 . 01 sec ) > select c1 mod c2 from t2 ; + ---------+ | c1 % c2 | + ---------+ | - 1 | | 1 | + ---------+ 2 rows in set ( 0 . 01 sec )","title":"\\%,MOD"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/mod/#mod","text":"","title":"%,MOD"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/mod/#description","text":"The %,MOD operator is used for modulo operation. Returns the remainder of N divided by M. For more information.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/mod/#syntax","text":"> SELECT N % M, N MOD M;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/mod/#examples","text":"> select 12 mod 5 ; + --------+ | 12 % 5 | + --------+ | 2 | + --------+ 1 row in set ( 0 . 00 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 mod 2 from t2 ; + --------+ | c1 % 2 | + --------+ | - 1 | | 1 | + --------+ 2 rows in set ( 0 . 01 sec ) > select c1 mod c2 from t2 ; + ---------+ | c1 % c2 | + ---------+ | - 1 | | 1 | + ---------+ 2 rows in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/multiplication/","text":"* Description The * operator is used for multiplication. Syntax > SELECT value1*value2; > SELECT column1*column2... FROM table_name; Examples > select 1123 . 2333 * 1233 . 3331 ; + -----------------------+ | 1123 . 2333 * 1233 . 3331 | + -----------------------+ | 1385320 . 8079122303 | + -----------------------+ 1 row in set ( 0 . 01 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 * 2 from t2 ; + --------+ | c1 * 2 | + --------+ | - 6 | | 2 | + --------+ 2 rows in set ( 0 . 00 sec ) > select c1 * c2 from t2 ; + ---------+ | c1 * c2 | + ---------+ | - 6 | | 2 | + ---------+ 2 rows in set ( 0 . 01 sec )","title":"\\*"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/multiplication/#_1","text":"","title":"*"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/multiplication/#description","text":"The * operator is used for multiplication.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/multiplication/#syntax","text":"> SELECT value1*value2; > SELECT column1*column2... FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/multiplication/#examples","text":"> select 1123 . 2333 * 1233 . 3331 ; + -----------------------+ | 1123 . 2333 * 1233 . 3331 | + -----------------------+ | 1385320 . 8079122303 | + -----------------------+ 1 row in set ( 0 . 01 sec ) > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select c1 * 2 from t2 ; + --------+ | c1 * 2 | + --------+ | - 6 | | 2 | + --------+ 2 rows in set ( 0 . 00 sec ) > select c1 * c2 from t2 ; + ---------+ | c1 * c2 | + ---------+ | - 6 | | 2 | + ---------+ 2 rows in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/unary-minus/","text":"- Description Unary minus. This operator changes the sign of the operand. Syntax > SELECT -column1, -column2, ... FROM table_name; Examples select - 2 ; + ------+ | - 2 | + ------+ | - 2 | + ------+ > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select - c1 from t2 ; + ------+ | - c1 | + ------+ | 3 | | - 1 | + ------+ 2 rows in set ( 0 . 00 sec )","title":"-"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/unary-minus/#-","text":"","title":"-"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/unary-minus/#description","text":"Unary minus. This operator changes the sign of the operand.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/unary-minus/#syntax","text":"> SELECT -column1, -column2, ... FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/arithmetic-operators/unary-minus/#examples","text":"select - 2 ; + ------+ | - 2 | + ------+ | - 2 | + ------+ > create table t2 ( c1 int , c2 int ); > insert into t2 values ( - 3 , 2 ); > insert into t2 values ( 1 , 2 ); > select - c1 from t2 ; + ------+ | - c1 | + ------+ | 3 | | - 1 | + ------+ 2 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/assignment-operators/assignment-operators-overview/","text":"Assignment Operators Overview Name Description = Equal operator","title":"Assignment Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/assignment-operators/assignment-operators-overview/#assignment-operators-overview","text":"Name Description = Equal operator","title":"Assignment Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/assignment-operators/equal/","text":"= Description This = operator is used to perform value assignments in the below cases: Within a SET statement, = is treated as an assignment operator that causes the user variable on the left hand side of the operator to take on the value to its right. The value on the right hand side may be a literal value, another variable storing a value, or any legal expression that yields a scalar value, including the result of a query (provided that this value is a scalar value). You can perform multiple assignments in the same SET statement. In the SET clause of an UPDATE statement, = also acts as an assignment operator. You can make multiple assignments in the same SET clause of an UPDATE statement. In any other context, = is treated as a comparison operator. Syntax > SELECT column1, column2, ... FROM table_name WHERE columnN = value1; Examples > create table t1 ( a bigint ( 3 ), b bigint ( 5 ) primary key ); > insert INTO t1 VALUES ( 1 , 1 ),( 1 , 2 ); > update t1 set a = 2 where a = 1 limit 1 ; > select * from t1 ; + ------+------+ | a | b | + ------+------+ | 2 | 1 | | 1 | 2 | + ------+------+ 2 rows in set ( 0 . 00 sec )","title":"="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/assignment-operators/equal/#_1","text":"","title":"="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/assignment-operators/equal/#description","text":"This = operator is used to perform value assignments in the below cases: Within a SET statement, = is treated as an assignment operator that causes the user variable on the left hand side of the operator to take on the value to its right. The value on the right hand side may be a literal value, another variable storing a value, or any legal expression that yields a scalar value, including the result of a query (provided that this value is a scalar value). You can perform multiple assignments in the same SET statement. In the SET clause of an UPDATE statement, = also acts as an assignment operator. You can make multiple assignments in the same SET clause of an UPDATE statement. In any other context, = is treated as a comparison operator.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/assignment-operators/equal/#syntax","text":"> SELECT column1, column2, ... FROM table_name WHERE columnN = value1;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/assignment-operators/equal/#examples","text":"> create table t1 ( a bigint ( 3 ), b bigint ( 5 ) primary key ); > insert INTO t1 VALUES ( 1 , 1 ),( 1 , 2 ); > update t1 set a = 2 where a = 1 limit 1 ; > select * from t1 ; + ------+------+ | a | b | + ------+------+ | 2 | 1 | | 1 | 2 | + ------+------+ 2 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/bit-functions-and-operators/bit-functions-and-perators-overview/","text":"Bit Functions and Operators Overview Name Description & Bitwise AND << Left shift ^ Bitwise XOR [ ](bitwise-or.md) Bitwise AND, OR, and XOR Operations For & , | , and ^ bit operations, the result type depends on whether the arguments are evaluated as binary strings or numbers: Binary-string evaluation occurs when the arguments have a binary string type, and at least one of them is not a hexadecimal literal, bit literal, or NULL literal. Numeric evaluation occurs otherwise, with argument conversion to unsigned 64-bit integers as necessary. Binary-string evaluation produces a binary string of the same length as the arguments. If the arguments have unequal lengths, an ER_INVALID_BITWISE_OPERANDS_SIZE error occurs. Numeric evaluation produces an unsigned 64-bit integer. Bitwise Complement and Shift Operations For << bit operation, the result type depends on whether the bit argument is evaluated as a binary string or number: Binary-string evaluation occurs when the bit argument has a binary string type, and is not a hexadecimal literal, bit literal, or NULL literal. Numeric evaluation occurs otherwise, with argument conversion to an unsigned 64-bit integer as necessary. Binary-string evaluation produces a binary string of the same length as the bit argument. Numeric evaluation produces an unsigned 64-bit integer. For shift operations, bits shifted off the end of the value are lost without warning, regardless of the argument type. In particular, if the shift count is greater or equal to the number of bits in the bit argument, all bits in the result are 0.","title":"**Bit Functions and Operators Overview**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/bit-functions-and-operators/bit-functions-and-perators-overview/#bit-functions-and-operators-overview","text":"Name Description & Bitwise AND << Left shift ^ Bitwise XOR [ ](bitwise-or.md)","title":"Bit Functions and Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/bit-functions-and-operators/bit-functions-and-perators-overview/#bitwise-and-or-and-xor-operations","text":"For & , | , and ^ bit operations, the result type depends on whether the arguments are evaluated as binary strings or numbers: Binary-string evaluation occurs when the arguments have a binary string type, and at least one of them is not a hexadecimal literal, bit literal, or NULL literal. Numeric evaluation occurs otherwise, with argument conversion to unsigned 64-bit integers as necessary. Binary-string evaluation produces a binary string of the same length as the arguments. If the arguments have unequal lengths, an ER_INVALID_BITWISE_OPERANDS_SIZE error occurs. Numeric evaluation produces an unsigned 64-bit integer.","title":"Bitwise AND, OR, and XOR Operations"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/bit-functions-and-operators/bit-functions-and-perators-overview/#bitwise-complement-and-shift-operations","text":"For << bit operation, the result type depends on whether the bit argument is evaluated as a binary string or number: Binary-string evaluation occurs when the bit argument has a binary string type, and is not a hexadecimal literal, bit literal, or NULL literal. Numeric evaluation occurs otherwise, with argument conversion to an unsigned 64-bit integer as necessary. Binary-string evaluation produces a binary string of the same length as the bit argument. Numeric evaluation produces an unsigned 64-bit integer. For shift operations, bits shifted off the end of the value are lost without warning, regardless of the argument type. In particular, if the shift count is greater or equal to the number of bits in the bit argument, all bits in the result are 0.","title":"Bitwise Complement and Shift Operations"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/bit-functions-and-operators/bitwise-and/","text":"","title":"Bitwise and"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/bit-functions-and-operators/bitwise-or/","text":"","title":"Bitwise or"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/bit-functions-and-operators/bitwise-xor/","text":"","title":"Bitwise xor"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/bit-functions-and-operators/left-shift/","text":"","title":"Left shift"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/binary/","text":"BINARY Description The BINARY() function converts a value to a binary string. Syntax > BINARY value Parameter Values Parameter Description value Required. The value to convert Examples >","title":"**BINARY**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/binary/#binary","text":"","title":"BINARY"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/binary/#description","text":"The BINARY() function converts a value to a binary string.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/binary/#syntax","text":"> BINARY value","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/binary/#parameter-values","text":"Parameter Description value Required. The value to convert","title":"Parameter Values"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/binary/#examples","text":">","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast-functions-and-operators-overview/","text":"Cast Functions and Operators Name Description CAST() Cast a value as a certain type CONVERT() Cast a value as a certain type","title":"Cast Functions and Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast-functions-and-operators-overview/#cast-functions-and-operators","text":"Name Description CAST() Cast a value as a certain type CONVERT() Cast a value as a certain type","title":"Cast Functions and Operators"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast/","text":"CAST Description The CAST() function converts a value (of any type) into the specified datatype. Syntax > CAST(value AS datatype) Parameter Values Parameter Description value Required. The value to convert datatype Required. The datatype to convert to Currently, cast can support following conversion: Conversion between numeric types, mainly including SIGNED, UNSIGNED, FLOAT, and DOUBLE type. Numeric types to character CHAR type. Numeric character types to numerical types(negative into SIGNED). Examples > drop table if exists t1 ; > CREATE TABLE t1 ( a int , b float , c char ( 1 ), d varchar ( 15 )); > INSERT INTO t1 VALUES ( 1 , 1 . 5 , '1' , '-2' ); > SELECT CAST ( a AS FLOAT ) a_cast , CAST ( b AS UNSIGNED ) b_cast , CAST ( c AS SIGNED ) c_cast , CAST ( d AS SIGNED ) d_cast from t1 ; + --------+--------+--------+--------+ | a_cast | b_cast | c_cast | d_cast | + --------+--------+--------+--------+ | 1 . 0000 | 1 | 1 | - 2 | + --------+--------+--------+--------+ > SELECT CAST ( a AS CHAR ) a_cast , CAST ( b AS CHAR ) b_cast , CAST ( c AS DOUBLE ) c_cast , CAST ( d AS FLOAT ) d_cast from t1 ; + --------+--------+--------+---------+ | a_cast | b_cast | c_cast | d_cast | + --------+--------+--------+---------+ | 1 | 1 . 5 | 1 . 0000 | - 2 . 0000 | + --------+--------+--------+---------+ Constraints Non-numeric character types cannot be converted to numeric types. Numeric and character types with formats of Data cannot be converted to Date. Date and Datetime types cannot be converted to character types. Date and Datetime cannot be converted to each other.","title":"CAST"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast/#cast","text":"","title":"CAST"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast/#description","text":"The CAST() function converts a value (of any type) into the specified datatype.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast/#syntax","text":"> CAST(value AS datatype)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast/#parameter-values","text":"Parameter Description value Required. The value to convert datatype Required. The datatype to convert to Currently, cast can support following conversion: Conversion between numeric types, mainly including SIGNED, UNSIGNED, FLOAT, and DOUBLE type. Numeric types to character CHAR type. Numeric character types to numerical types(negative into SIGNED).","title":"Parameter Values"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast/#examples","text":"> drop table if exists t1 ; > CREATE TABLE t1 ( a int , b float , c char ( 1 ), d varchar ( 15 )); > INSERT INTO t1 VALUES ( 1 , 1 . 5 , '1' , '-2' ); > SELECT CAST ( a AS FLOAT ) a_cast , CAST ( b AS UNSIGNED ) b_cast , CAST ( c AS SIGNED ) c_cast , CAST ( d AS SIGNED ) d_cast from t1 ; + --------+--------+--------+--------+ | a_cast | b_cast | c_cast | d_cast | + --------+--------+--------+--------+ | 1 . 0000 | 1 | 1 | - 2 | + --------+--------+--------+--------+ > SELECT CAST ( a AS CHAR ) a_cast , CAST ( b AS CHAR ) b_cast , CAST ( c AS DOUBLE ) c_cast , CAST ( d AS FLOAT ) d_cast from t1 ; + --------+--------+--------+---------+ | a_cast | b_cast | c_cast | d_cast | + --------+--------+--------+---------+ | 1 | 1 . 5 | 1 . 0000 | - 2 . 0000 | + --------+--------+--------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/cast/#constraints","text":"Non-numeric character types cannot be converted to numeric types. Numeric and character types with formats of Data cannot be converted to Date. Date and Datetime types cannot be converted to character types. Date and Datetime cannot be converted to each other.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/convert/","text":"CONVERT Description The CONVERT() function converts a value into the specified datatype or character set. Syntax > CONVERT(value, type) Or: > CONVERT(value USING charset) Parameter Values Parameter Description value Required. The value to convert. datatype Required. The datatype to convert to. charset Required. The character set to convert to. Currently, convert can support following conversion: Conversion between numeric types, mainly including SIGNED, UNSIGNED, FLOAT, and DOUBLE type. Numeric types to character CHAR type. Numeric character types to numerical types(negative into SIGNED). Examples > select convert ( 150 , char ); + -------------------+ | cast ( 150 as char ) | + -------------------+ | 150 | + -------------------+ 1 row in set ( 0 . 01 sec ) > CREATE TABLE t1 ( a tinyint ); > INSERT INTO t1 VALUES ( 127 ); > SELECT 1 FROM -> ( SELECT CONVERT ( t2 . a USING UTF8 ) FROM t1 , t1 t2 LIMIT 1 ) AS s LIMIT 1 ; + ------+ | 1 | + ------+ | 1 | + ------+ 1 row in set ( 0 . 00 sec ) Constraints Non-numeric character types cannot be converted to numeric types. Numeric and character types with formats of Data cannot be converted to Date. Date and Datetime types cannot be converted to character types. Date and Datetime cannot be converted to each other.","title":"CONVERT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/convert/#convert","text":"","title":"CONVERT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/convert/#description","text":"The CONVERT() function converts a value into the specified datatype or character set.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/convert/#syntax","text":"> CONVERT(value, type) Or: > CONVERT(value USING charset)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/convert/#parameter-values","text":"Parameter Description value Required. The value to convert. datatype Required. The datatype to convert to. charset Required. The character set to convert to. Currently, convert can support following conversion: Conversion between numeric types, mainly including SIGNED, UNSIGNED, FLOAT, and DOUBLE type. Numeric types to character CHAR type. Numeric character types to numerical types(negative into SIGNED).","title":"Parameter Values"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/convert/#examples","text":"> select convert ( 150 , char ); + -------------------+ | cast ( 150 as char ) | + -------------------+ | 150 | + -------------------+ 1 row in set ( 0 . 01 sec ) > CREATE TABLE t1 ( a tinyint ); > INSERT INTO t1 VALUES ( 127 ); > SELECT 1 FROM -> ( SELECT CONVERT ( t2 . a USING UTF8 ) FROM t1 , t1 t2 LIMIT 1 ) AS s LIMIT 1 ; + ------+ | 1 | + ------+ | 1 | + ------+ 1 row in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/cast-functions-and-operators/convert/#constraints","text":"Non-numeric character types cannot be converted to numeric types. Numeric and character types with formats of Data cannot be converted to Date. Date and Datetime types cannot be converted to character types. Date and Datetime cannot be converted to each other.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/assign-equal/","text":"= Description The = operator returns true only if the left-hand operand is equal to the right-hand operand. Syntax > SELECT x = y; Examples > SELECT 2 = 2 ; + -------+ | 2 = 2 | + -------+ | true | + -------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , spID , score from t1 where userID = spID and userID = score ; + --------+------+-------+ | userid | spid | score | + --------+------+-------+ | 1 | 1 | 1 | | 2 | 2 | 2 | | 3 | 3 | 3 | + --------+------+-------+ 3 rows in set ( 0 . 00 sec )","title":"="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/assign-equal/#_1","text":"","title":"="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/assign-equal/#description","text":"The = operator returns true only if the left-hand operand is equal to the right-hand operand.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/assign-equal/#syntax","text":"> SELECT x = y;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/assign-equal/#examples","text":"> SELECT 2 = 2 ; + -------+ | 2 = 2 | + -------+ | true | + -------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , spID , score from t1 where userID = spID and userID = score ; + --------+------+-------+ | userid | spid | score | + --------+------+-------+ | 1 | 1 | 1 | | 2 | 2 | 2 | | 3 | 3 | 3 | + --------+------+-------+ 3 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/between/","text":"BETWEEN ... AND ... Description If expr is greater than or equal to min and expr is less than or equal to max, BETWEEN returns true , otherwise it returns false . Syntax > expr BETWEEN min AND max Examples > SELECT 2 BETWEEN 1 AND 3 , 2 BETWEEN 3 and 1 ; + -------------------+-------------------+ | 2 between 1 and 3 | 2 between 3 and 1 | + -------------------+-------------------+ | true | false | + -------------------+-------------------+ 1 row in set ( 0 . 01 sec ) > create table t ( id bigint unsigned , b int ); > insert into t values ( 8894754949779693574 , 1 ); > insert into t values ( 8894754949779693579 , 2 ); > insert into t values ( 17790886498483827171 , 3 ); > select count ( * ) from t where id >= 8894754949779693574 and id = 17790886498483827171 order by 1 asc ; + ----------+ | count ( * ) | + ----------+ | 0 | + ----------+ > select count ( * ) from t where id between 8894754949779693574 and 17790886498483827171 ; + ----------+ | count ( * ) | + ----------+ | 0 | + ----------+ 1 row in set ( 0 . 01 sec )","title":"BETWEEN ... AND ..."},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/between/#between-and","text":"","title":"BETWEEN ... AND ..."},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/between/#description","text":"If expr is greater than or equal to min and expr is less than or equal to max, BETWEEN returns true , otherwise it returns false .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/between/#syntax","text":"> expr BETWEEN min AND max","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/between/#examples","text":"> SELECT 2 BETWEEN 1 AND 3 , 2 BETWEEN 3 and 1 ; + -------------------+-------------------+ | 2 between 1 and 3 | 2 between 3 and 1 | + -------------------+-------------------+ | true | false | + -------------------+-------------------+ 1 row in set ( 0 . 01 sec ) > create table t ( id bigint unsigned , b int ); > insert into t values ( 8894754949779693574 , 1 ); > insert into t values ( 8894754949779693579 , 2 ); > insert into t values ( 17790886498483827171 , 3 ); > select count ( * ) from t where id >= 8894754949779693574 and id = 17790886498483827171 order by 1 asc ; + ----------+ | count ( * ) | + ----------+ | 0 | + ----------+ > select count ( * ) from t where id between 8894754949779693574 and 17790886498483827171 ; + ----------+ | count ( * ) | + ----------+ | 0 | + ----------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/comparison-functions-and-operators-overview/","text":"Comparison Functions and Operators Overview Name Description > Greater than operator >= Greater than or equal operator < Less than operator <>,!= Not equal operator <= Less than or equal operator = Equal operator BETWEEN ... AND ... Whether a value is within a range of values IN() Whether a value is within a set of values IS Test a value against a boolean IS NOT Test a value against a boolean IS NOT NULL NOT NULL value test IS NULL NULL value test LIKE Simple pattern matching NOT BETWEEN ... AND ... Whether a value is not within a range of values NOT LIKE Negation of simple pattern matching Comparison operations result in a value of TRUE , FALSE , or NULL . These operations work for both numbers and strings. Strings are automatically converted to numbers and numbers to strings as necessary. The following relational comparison operators can be used to compare not only scalar operands, but row operands: = > < >= <= <> !=","title":"Comparison Functions and Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/comparison-functions-and-operators-overview/#comparison-functions-and-operators-overview","text":"Name Description > Greater than operator >= Greater than or equal operator < Less than operator <>,!= Not equal operator <= Less than or equal operator = Equal operator BETWEEN ... AND ... Whether a value is within a range of values IN() Whether a value is within a set of values IS Test a value against a boolean IS NOT Test a value against a boolean IS NOT NULL NOT NULL value test IS NULL NULL value test LIKE Simple pattern matching NOT BETWEEN ... AND ... Whether a value is not within a range of values NOT LIKE Negation of simple pattern matching Comparison operations result in a value of TRUE , FALSE , or NULL . These operations work for both numbers and strings. Strings are automatically converted to numbers and numbers to strings as necessary. The following relational comparison operators can be used to compare not only scalar operands, but row operands: = > < >= <= <> !=","title":"Comparison Functions and Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_coalesce/","text":"COALESCE Description The COALESCE() function returns the first non-NULL value in the list, or NULL if there are no non-NULL values. The return type of COALESCE() is the aggregated type of the argument types. Syntax > COALESCE(value,...) Examples ```sql SELECT COALESCE(NULL,1); -> 1 mysql> SELECT COALESCE(NULL,NULL,NULL); -> NULL","title":"**COALESCE**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_coalesce/#coalesce","text":"","title":"COALESCE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_coalesce/#description","text":"The COALESCE() function returns the first non-NULL value in the list, or NULL if there are no non-NULL values. The return type of COALESCE() is the aggregated type of the argument types.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_coalesce/#syntax","text":"> COALESCE(value,...)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_coalesce/#examples","text":"```sql SELECT COALESCE(NULL,1); -> 1 mysql> SELECT COALESCE(NULL,NULL,NULL); -> NULL","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_interval/","text":"INTERVAL Description The INTERVAL operator returns 0 if N < N1, 1 if N < N2 and so on or -1 if N is NULL. All arguments are treated as integers. It is required that N1 < N2 < N3 < ... < Nn for this function to work correctly. This is because a binary search is used (very fast). Syntax > INTERVAL(N,N1,N2,N3,...) Examples >","title":"**INTERVAL**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_interval/#interval","text":"","title":"INTERVAL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_interval/#description","text":"The INTERVAL operator returns 0 if N < N1, 1 if N < N2 and so on or -1 if N is NULL. All arguments are treated as integers. It is required that N1 < N2 < N3 < ... < Nn for this function to work correctly. This is because a binary search is used (very fast).","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_interval/#syntax","text":"> INTERVAL(N,N1,N2,N3,...)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_interval/#examples","text":">","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_isnull/","text":"ISNULL Description The ISNULL() function can be used instead of = to test whether a value is NULL. (Comparing a value to NULL using = always yields NULL .) If expression is NULL , this function returns true . Otherwise, it returns false . The ISNULL() function shares some special behaviors with the IS NULL comparison operator. See the description of IS NULL . Syntax > ISNULL(expr) Examples > SELECT ISNULL ( 1 + 1 ); + ---------------+ | isnull ( 1 + 1 ) | + ---------------+ | false | + ---------------+ 1 row in set ( 0 . 02 sec )","title":"**ISNULL**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_isnull/#isnull","text":"","title":"ISNULL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_isnull/#description","text":"The ISNULL() function can be used instead of = to test whether a value is NULL. (Comparing a value to NULL using = always yields NULL .) If expression is NULL , this function returns true . Otherwise, it returns false . The ISNULL() function shares some special behaviors with the IS NULL comparison operator. See the description of IS NULL .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_isnull/#syntax","text":"> ISNULL(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_isnull/#examples","text":"> SELECT ISNULL ( 1 + 1 ); + ---------------+ | isnull ( 1 + 1 ) | + ---------------+ | false | + ---------------+ 1 row in set ( 0 . 02 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_least/","text":"","title":"Function least"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_strcmp/","text":"STRCMP Description The STRCMP() returns 0 if the strings are the same, -1 if the first argument is smaller than the second according to the current sort order, and NULL if either argument is NULL. It returns 1 otherwise. Syntax > STRCMP(expr1,expr2) Examples","title":"**STRCMP**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_strcmp/#strcmp","text":"","title":"STRCMP"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_strcmp/#description","text":"The STRCMP() returns 0 if the strings are the same, -1 if the first argument is smaller than the second according to the current sort order, and NULL if either argument is NULL. It returns 1 otherwise.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_strcmp/#syntax","text":"> STRCMP(expr1,expr2)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/function_strcmp/#examples","text":"","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than-or-equal/","text":">= Description The >= operator returns true only if the left-hand operand is greater than or equal to the right-hand operand. Syntax > SELECT x >= y; Examples > SELECT 2 >= 2 ; + --------+ | 2 >= 2 | + --------+ | true | + --------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , spID , score from t1 where spID >= userID * score ; + --------+------+-------+ | userid | spid | score | + --------+------+-------+ | 1 | 1 | 1 | + --------+------+-------+ 1 row in set ( 0 . 01 sec )","title":"\\>="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than-or-equal/#_1","text":"","title":"&gt;="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than-or-equal/#description","text":"The >= operator returns true only if the left-hand operand is greater than or equal to the right-hand operand.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than-or-equal/#syntax","text":"> SELECT x >= y;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than-or-equal/#examples","text":"> SELECT 2 >= 2 ; + --------+ | 2 >= 2 | + --------+ | true | + --------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , spID , score from t1 where spID >= userID * score ; + --------+------+-------+ | userid | spid | score | + --------+------+-------+ | 1 | 1 | 1 | + --------+------+-------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than/","text":"> Description The > operator returns true only if the left-hand operand is greater than the right-hand operand. Syntax > SELECT x > y; Examples > SELECT 2 > 2 ; + -------+ | 2 > 2 | + -------+ | false | + -------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select spID , userID , score from t1 where spID > ( userID - 1 ); + ------+--------+-------+ | spid | userid | score | + ------+--------+-------+ | 1 | 1 | 1 | | 2 | 2 | 2 | | 2 | 1 | 4 | | 3 | 3 | 3 | | 1 | 1 | 5 | + ------+--------+-------+ 5 rows in set ( 0 . 01 sec )","title":"\\>"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than/#_1","text":"","title":"&gt;"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than/#description","text":"The > operator returns true only if the left-hand operand is greater than the right-hand operand.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than/#syntax","text":"> SELECT x > y;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/greater-than/#examples","text":"> SELECT 2 > 2 ; + -------+ | 2 > 2 | + -------+ | false | + -------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select spID , userID , score from t1 where spID > ( userID - 1 ); + ------+--------+-------+ | spid | userid | score | + ------+--------+-------+ | 1 | 1 | 1 | | 2 | 2 | 2 | | 2 | 1 | 4 | | 3 | 3 | 3 | | 1 | 1 | 5 | + ------+--------+-------+ 5 rows in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/in/","text":"IN Description The IN operator allows you to specify multiple values in a WHERE clause. And it's a shorthand for multiple OR conditions. Syntax > SELECT column1, column2, ... FROM table_name WHERE column_name IN (value1, value2, ...); Examples > create table t2 ( a int , b varchar ( 5 ), c float , d date , e datetime ); > insert into t2 values ( 1 , 'a' , 1 . 001 , '2022-02-08' , '2022-02-08 12:00:00' ); > insert into t2 values ( 2 , 'b' , 2 . 001 , '2022-02-09' , '2022-02-09 12:00:00' ); > insert into t2 values ( 1 , 'c' , 3 . 001 , '2022-02-10' , '2022-02-10 12:00:00' ); > insert into t2 values ( 4 , 'd' , 4 . 001 , '2022-02-11' , '2022-02-11 12:00:00' ); > select * from t2 where a in ( 2 , 4 ); a b c d e 2 b 2 . 0010 2022 - 02 - 09 2022 - 02 - 09 12 : 00 : 00 4 d 4 . 0010 2022 - 02 - 11 2022 - 02 - 11 12 : 00 : 00 > select * from t2 where a not in ( 2 , 4 ); a b c d e 1 a 1 . 0010 2022 - 02 - 08 2022 - 02 - 08 12 : 00 : 00 1 c 3 . 0010 2022 - 02 - 10 2022 - 02 - 10 12 : 00 : 00 > select * from t2 where b not in ( 'e' , \"f\" ); a b c d e 1 a 1 . 0010 2022 - 02 - 08 2022 - 02 - 08 12 : 00 : 00 2 b 2 . 0010 2022 - 02 - 09 2022 - 02 - 09 12 : 00 : 00 1 c 3 . 0010 2022 - 02 - 10 2022 - 02 - 10 12 : 00 : 00 4 d 4 . 0010 2022 - 02 - 11 2022 - 02 - 11 12 : 00 : 00 > select * from t2 where e not in ( '2022-02-09 12:00:00' ) and a in ( 4 , 5 ); a b c d e 4 d 4 . 0010 2022 - 02 - 11 2022 - 02 - 11 12 : 00 : 00 Constraints Currently, only constant lists are supported on the left side of IN . There can only be a single column to the left of IN , not a tuple of multiple columns. NULL values couldn\u2019t appear in the list to the right of IN .","title":"IN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/in/#in","text":"","title":"IN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/in/#description","text":"The IN operator allows you to specify multiple values in a WHERE clause. And it's a shorthand for multiple OR conditions.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/in/#syntax","text":"> SELECT column1, column2, ... FROM table_name WHERE column_name IN (value1, value2, ...);","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/in/#examples","text":"> create table t2 ( a int , b varchar ( 5 ), c float , d date , e datetime ); > insert into t2 values ( 1 , 'a' , 1 . 001 , '2022-02-08' , '2022-02-08 12:00:00' ); > insert into t2 values ( 2 , 'b' , 2 . 001 , '2022-02-09' , '2022-02-09 12:00:00' ); > insert into t2 values ( 1 , 'c' , 3 . 001 , '2022-02-10' , '2022-02-10 12:00:00' ); > insert into t2 values ( 4 , 'd' , 4 . 001 , '2022-02-11' , '2022-02-11 12:00:00' ); > select * from t2 where a in ( 2 , 4 ); a b c d e 2 b 2 . 0010 2022 - 02 - 09 2022 - 02 - 09 12 : 00 : 00 4 d 4 . 0010 2022 - 02 - 11 2022 - 02 - 11 12 : 00 : 00 > select * from t2 where a not in ( 2 , 4 ); a b c d e 1 a 1 . 0010 2022 - 02 - 08 2022 - 02 - 08 12 : 00 : 00 1 c 3 . 0010 2022 - 02 - 10 2022 - 02 - 10 12 : 00 : 00 > select * from t2 where b not in ( 'e' , \"f\" ); a b c d e 1 a 1 . 0010 2022 - 02 - 08 2022 - 02 - 08 12 : 00 : 00 2 b 2 . 0010 2022 - 02 - 09 2022 - 02 - 09 12 : 00 : 00 1 c 3 . 0010 2022 - 02 - 10 2022 - 02 - 10 12 : 00 : 00 4 d 4 . 0010 2022 - 02 - 11 2022 - 02 - 11 12 : 00 : 00 > select * from t2 where e not in ( '2022-02-09 12:00:00' ) and a in ( 4 , 5 ); a b c d e 4 d 4 . 0010 2022 - 02 - 11 2022 - 02 - 11 12 : 00 : 00","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/in/#constraints","text":"Currently, only constant lists are supported on the left side of IN . There can only be a single column to the left of IN , not a tuple of multiple columns. NULL values couldn\u2019t appear in the list to the right of IN .","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not-null/","text":"IS NOT NULL Description The IS NOT NULL function tests whether a value is not NULL . If expression is NOT NULL , this function returns true . Otherwise, it returns false . Syntax > expression IS NOT NULL Examples > SELECT 1 IS NOT NULL , 0 IS NOT NULL , NULL IS NOT NULL ; + ---------------+---------------+------------------+ | 1 is not null | 0 is not null | null is not null | + ---------------+---------------+------------------+ | true | true | false | + ---------------+---------------+------------------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | false | | true | true | | false | false | | NULL | NULL | + -------+-------+ > select * from t1 where b is NOT NULL ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | false | | true | true | | false | false | + -------+-------+ 4 rows in set ( 0 . 01 sec )","title":"IS NOT NULL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not-null/#is-not-null","text":"","title":"IS NOT NULL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not-null/#description","text":"The IS NOT NULL function tests whether a value is not NULL . If expression is NOT NULL , this function returns true . Otherwise, it returns false .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not-null/#syntax","text":"> expression IS NOT NULL","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not-null/#examples","text":"> SELECT 1 IS NOT NULL , 0 IS NOT NULL , NULL IS NOT NULL ; + ---------------+---------------+------------------+ | 1 is not null | 0 is not null | null is not null | + ---------------+---------------+------------------+ | true | true | false | + ---------------+---------------+------------------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | false | | true | true | | false | false | | NULL | NULL | + -------+-------+ > select * from t1 where b is NOT NULL ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | false | | true | true | | false | false | + -------+-------+ 4 rows in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not/","text":"IS NOT Description The IS NOT tests a value against a boolean value, where boolean_value can be TRUE, FALSE, or UNKNOWN. Syntax > IS NOT boolean_value Examples > SELECT 1 IS NOT TRUE , 0 IS NOT FALSE , NULL IS NOT UNKNOWN ; + -----------+------------+----------+ | 1 != true | 0 != false | null != | + -----------+------------+----------+ | false | false | NULL | + -----------+------------+----------+ 1 row in set ( 0 . 01 sec )","title":"IS NOT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not/#is-not","text":"","title":"IS NOT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not/#description","text":"The IS NOT tests a value against a boolean value, where boolean_value can be TRUE, FALSE, or UNKNOWN.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not/#syntax","text":"> IS NOT boolean_value","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-not/#examples","text":"> SELECT 1 IS NOT TRUE , 0 IS NOT FALSE , NULL IS NOT UNKNOWN ; + -----------+------------+----------+ | 1 != true | 0 != false | null != | + -----------+------------+----------+ | false | false | NULL | + -----------+------------+----------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-null/","text":"IS NULL Description The IS NOT NULL function tests whether a value is NULL . It returns TRUE if a NULL value is found, otherwise it returns FALSE . It can be used in a SELECT , INSERT , UPDATE , or DELETE statement. Syntax > expression IS NULL Examples > SELECT 1 IS NULL , 0 IS NULL , NULL IS NULL ; + -----------+-----------+--------------+ | 1 is null | 0 is null | null is null | + -----------+-----------+--------------+ | false | false | true | + -----------+-----------+--------------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | false | | true | true | | false | false | | NULL | NULL | + -------+-------+ > select * from t1 where a IS NULL ; + ------+------+ | a | b | + ------+------+ | NULL | NULL | + ------+------+ 1 row in set ( 0 . 01 sec )","title":"IS NULL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-null/#is-null","text":"","title":"IS NULL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-null/#description","text":"The IS NOT NULL function tests whether a value is NULL . It returns TRUE if a NULL value is found, otherwise it returns FALSE . It can be used in a SELECT , INSERT , UPDATE , or DELETE statement.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-null/#syntax","text":"> expression IS NULL","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is-null/#examples","text":"> SELECT 1 IS NULL , 0 IS NULL , NULL IS NULL ; + -----------+-----------+--------------+ | 1 is null | 0 is null | null is null | + -----------+-----------+--------------+ | false | false | true | + -----------+-----------+--------------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | false | | true | true | | false | false | | NULL | NULL | + -------+-------+ > select * from t1 where a IS NULL ; + ------+------+ | a | b | + ------+------+ | NULL | NULL | + ------+------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is/","text":"IS Description The IS tests a value against a boolean value, where boolean_value can be TRUE, FALSE, or UNKNOWN. Syntax > IS boolean_value Examples > SELECT 1 IS TRUE , 0 IS FALSE , NULL IS UNKNOWN ; + ----------+-----------+---------+ | 1 = true | 0 = false | null = | + ----------+-----------+---------+ | true | true | NULL | + ----------+-----------+---------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | false | | true | true | | false | false | | NULL | NULL | + -------+-------+ > select * from t1 where a <= b and a is not NULL ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | true | | false | false | + -------+-------+ 3 rows in set ( 0 . 01 sec )","title":"IS"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is/#is","text":"","title":"IS"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is/#description","text":"The IS tests a value against a boolean value, where boolean_value can be TRUE, FALSE, or UNKNOWN.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is/#syntax","text":"> IS boolean_value","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/is/#examples","text":"> SELECT 1 IS TRUE , 0 IS FALSE , NULL IS UNKNOWN ; + ----------+-----------+---------+ | 1 = true | 0 = false | null = | + ----------+-----------+---------+ | true | true | NULL | + ----------+-----------+---------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | false | | true | true | | false | false | | NULL | NULL | + -------+-------+ > select * from t1 where a <= b and a is not NULL ; + -------+-------+ | a | b | + -------+-------+ | false | true | | true | true | | false | false | + -------+-------+ 3 rows in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than-or-equal/","text":"<= Description The <= operator returns true only if the left-hand operand is less than or equal to the right-hand operand. Syntax > SELECT x <= y; Examples > SELECT 2 <= 2 ; + --------+ | 2 <= 2 | + --------+ | true | + --------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , score , spID from t1 where userID <= score / spID ; + --------+-------+------+ | userid | score | spid | + --------+-------+------+ | 1 | 1 | 1 | | 1 | 4 | 2 | | 1 | 5 | 1 | | 11 | 99 | 5 | + --------+-------+------+ 4 rows in set ( 0 . 00 sec )","title":"<="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than-or-equal/#_1","text":"","title":"&lt;="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than-or-equal/#description","text":"The <= operator returns true only if the left-hand operand is less than or equal to the right-hand operand.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than-or-equal/#syntax","text":"> SELECT x <= y;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than-or-equal/#examples","text":"> SELECT 2 <= 2 ; + --------+ | 2 <= 2 | + --------+ | true | + --------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , score , spID from t1 where userID <= score / spID ; + --------+-------+------+ | userid | score | spid | + --------+-------+------+ | 1 | 1 | 1 | | 1 | 4 | 2 | | 1 | 5 | 1 | | 11 | 99 | 5 | + --------+-------+------+ 4 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than/","text":"< Description The < operator returns true only if the left-hand operand is less than the right-hand operand. Syntax > SELECT x < y; Examples > SELECT 2 < 2 ; + -------+ | 2 < 2 | + -------+ | false | + -------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select spID , userID , score from t1 where ( userID - 1 ) < spID ; + ------+--------+-------+ | spid | userid | score | + ------+--------+-------+ | 1 | 1 | 1 | | 2 | 2 | 2 | | 2 | 1 | 4 | | 3 | 3 | 3 | | 1 | 1 | 5 | + ------+--------+-------+ 5 rows in set ( 0 . 00 sec ) > select spID , userID , score from t1 where spID < ( userID - 1 ); + ------+--------+-------+ | spid | userid | score | + ------+--------+-------+ | 4 | 6 | 10 | | 5 | 11 | 99 | + ------+--------+-------+ 2 rows in set ( 0 . 00 sec )","title":"<"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than/#_1","text":"","title":"&lt;"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than/#description","text":"The < operator returns true only if the left-hand operand is less than the right-hand operand.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than/#syntax","text":"> SELECT x < y;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/less-than/#examples","text":"> SELECT 2 < 2 ; + -------+ | 2 < 2 | + -------+ | false | + -------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select spID , userID , score from t1 where ( userID - 1 ) < spID ; + ------+--------+-------+ | spid | userid | score | + ------+--------+-------+ | 1 | 1 | 1 | | 2 | 2 | 2 | | 2 | 1 | 4 | | 3 | 3 | 3 | | 1 | 1 | 5 | + ------+--------+-------+ 5 rows in set ( 0 . 00 sec ) > select spID , userID , score from t1 where spID < ( userID - 1 ); + ------+--------+-------+ | spid | userid | score | + ------+--------+-------+ | 4 | 6 | 10 | | 5 | 11 | 99 | + ------+--------+-------+ 2 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/like/","text":"LIKE Description The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. There are two wildcards often used in conjunction with the LIKE operator: The percent sign (%) represents zero, one, or multiple characters The underscore sign (_) represents one, single character Syntax > SELECT column1, column2, ... FROM table_name WHERE columnN LIKE pattern; Examples > SELECT * FROM Customers WHERE CustomerName LIKE 'a%' ; // The following SQL statement selects all customers with a CustomerName starting with \"a\" > SELECT * FROM Customers WHERE CustomerName LIKE '%a' ; // The following SQL statement selects all customers with a CustomerName ending with \"a\" > SELECT * FROM Customers WHERE CustomerName LIKE '%or%' ; // The following SQL statement selects all customers with a CustomerName that have \"or\" in any position > SELECT * FROM Customers WHERE CustomerName LIKE '_r%' ; // The following SQL statement selects all customers with a CustomerName that have \"r\" in the second position > SELECT * FROM Customers WHERE CustomerName LIKE 'a__%' ; // The following SQL statement selects all customers with a CustomerName that starts with \"a\" and are at least 3 characters in length > SELECT * FROM Customers WHERE ContactName LIKE 'a%o' ; // The following SQL statement selects all customers with a ContactName that starts with \"a\" and ends with \"o\" > SELECT * FROM Customers WHERE CustomerName NOT LIKE 'a%' ; // The following SQL statement selects all customers with a CustomerName that does NOT start with \"a\"","title":"LIKE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/like/#like","text":"","title":"LIKE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/like/#description","text":"The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. There are two wildcards often used in conjunction with the LIKE operator: The percent sign (%) represents zero, one, or multiple characters The underscore sign (_) represents one, single character","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/like/#syntax","text":"> SELECT column1, column2, ... FROM table_name WHERE columnN LIKE pattern;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/like/#examples","text":"> SELECT * FROM Customers WHERE CustomerName LIKE 'a%' ; // The following SQL statement selects all customers with a CustomerName starting with \"a\" > SELECT * FROM Customers WHERE CustomerName LIKE '%a' ; // The following SQL statement selects all customers with a CustomerName ending with \"a\" > SELECT * FROM Customers WHERE CustomerName LIKE '%or%' ; // The following SQL statement selects all customers with a CustomerName that have \"or\" in any position > SELECT * FROM Customers WHERE CustomerName LIKE '_r%' ; // The following SQL statement selects all customers with a CustomerName that have \"r\" in the second position > SELECT * FROM Customers WHERE CustomerName LIKE 'a__%' ; // The following SQL statement selects all customers with a CustomerName that starts with \"a\" and are at least 3 characters in length > SELECT * FROM Customers WHERE ContactName LIKE 'a%o' ; // The following SQL statement selects all customers with a ContactName that starts with \"a\" and ends with \"o\" > SELECT * FROM Customers WHERE CustomerName NOT LIKE 'a%' ; // The following SQL statement selects all customers with a CustomerName that does NOT start with \"a\"","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-between/","text":"NOT BETWEEN ... AND ... Description If expr is less than or equal to min and expr is greater than or equal to max, NOT BETWEEN returns true , otherwise it returns false . Syntax > expr NOT BETWEEN min AND max Examples > SELECT 2 NOT BETWEEN 1 AND 3 , 2 NOT BETWEEN 3 and 1 ; + -----------------------+-----------------------+ | 2 not between 1 and 3 | 2 not between 3 and 1 | + -----------------------+-----------------------+ | false | true | + -----------------------+-----------------------+ 1 row in set ( 0 . 00 sec ) > create table t ( id bigint unsigned , b int ); > insert into t values ( 8894754949779693574 , 1 ); > insert into t values ( 8894754949779693579 , 2 ); > insert into t values ( 17790886498483827171 , 3 ); > select count ( * ) from t where id >= 8894754949779693574 and id = 17790886498483827171 order by 1 asc ; + ----------+ | count ( * ) | + ----------+ | 0 | + ----------+ > select count ( * ) from t where id not between 8894754949779693574 and 17790886498483827171 ; + ----------+ | count ( * ) | + ----------+ | 3 | + ----------+ 1 row in set ( 0 . 00 sec )","title":"NOT BETWEEN ... AND ..."},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-between/#not-between-and","text":"","title":"NOT BETWEEN ... AND ..."},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-between/#description","text":"If expr is less than or equal to min and expr is greater than or equal to max, NOT BETWEEN returns true , otherwise it returns false .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-between/#syntax","text":"> expr NOT BETWEEN min AND max","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-between/#examples","text":"> SELECT 2 NOT BETWEEN 1 AND 3 , 2 NOT BETWEEN 3 and 1 ; + -----------------------+-----------------------+ | 2 not between 1 and 3 | 2 not between 3 and 1 | + -----------------------+-----------------------+ | false | true | + -----------------------+-----------------------+ 1 row in set ( 0 . 00 sec ) > create table t ( id bigint unsigned , b int ); > insert into t values ( 8894754949779693574 , 1 ); > insert into t values ( 8894754949779693579 , 2 ); > insert into t values ( 17790886498483827171 , 3 ); > select count ( * ) from t where id >= 8894754949779693574 and id = 17790886498483827171 order by 1 asc ; + ----------+ | count ( * ) | + ----------+ | 0 | + ----------+ > select count ( * ) from t where id not between 8894754949779693574 and 17790886498483827171 ; + ----------+ | count ( * ) | + ----------+ | 3 | + ----------+ 1 row in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-equal/","text":"<>,!= Description The <>,!= operator returns true only if the left-hand operand is not equal to the right-hand operand. Syntax > SELECT x <> y; Examples > SELECT 2 <> 2 ; + --------+ | 2 != 2 | + --------+ | false | + --------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , spID , score from t1 where userID = spID and userID <> score ; + --------+------+-------+ | userid | spid | score | + --------+------+-------+ | 1 | 1 | 5 | + --------+------+-------+ 1 row in set ( 0 . 00 sec )","title":"<>,!="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-equal/#_1","text":"","title":"&lt;&gt;,!="},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-equal/#description","text":"The <>,!= operator returns true only if the left-hand operand is not equal to the right-hand operand.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-equal/#syntax","text":"> SELECT x <> y;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-equal/#examples","text":"> SELECT 2 <> 2 ; + --------+ | 2 != 2 | + --------+ | false | + --------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( spID smallint , userID bigint , score int ); > insert into t1 values ( 1 , 1 , 1 ); > insert into t1 values ( 2 , 2 , 2 ); > insert into t1 values ( 2 , 1 , 4 ); > insert into t1 values ( 3 , 3 , 3 ); > insert into t1 values ( 1 , 1 , 5 ); > insert into t1 values ( 4 , 6 , 10 ); > insert into t1 values ( 5 , 11 , 99 ); > select userID , spID , score from t1 where userID = spID and userID <> score ; + --------+------+-------+ | userid | spid | score | + --------+------+-------+ | 1 | 1 | 5 | + --------+------+-------+ 1 row in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-in/","text":"NOT IN Description The NOT IN operator allows you to specify multiple values in a WHERE clause. And it's a shorthand for multiple XOR conditions. Syntax > SELECT column1, column2, ... FROM table_name WHERE column_name NOT IN (value1, value2, ...); Examples > create table t2 ( a int , b varchar ( 5 ), c float , d date , e datetime ); > insert into t2 values ( 1 , 'a' , 1 . 001 , '2022-02-08' , '2022-02-08 12:00:00' ); > insert into t2 values ( 2 , 'b' , 2 . 001 , '2022-02-09' , '2022-02-09 12:00:00' ); > insert into t2 values ( 1 , 'c' , 3 . 001 , '2022-02-10' , '2022-02-10 12:00:00' ); > insert into t2 values ( 4 , 'd' , 4 . 001 , '2022-02-11' , '2022-02-11 12:00:00' ); > select * from t2 where a not in ( 2 , 4 ); + ------+------+-------+------------+----------------------------+ | a | b | c | d | e | + ------+------+-------+------------+----------------------------+ | 1 | a | 1 . 001 | 2022 - 02 - 08 | 2022 - 02 - 08 12 : 00 : 00 . 000000 | | 1 | c | 3 . 001 | 2022 - 02 - 10 | 2022 - 02 - 10 12 : 00 : 00 . 000000 | + ------+------+-------+------------+----------------------------+ 2 rows in set ( 0 . 00 sec ) > select * from t2 where b not in ( 'e' , \"f\" ); + ------+------+-------+------------+----------------------------+ | a | b | c | d | e | + ------+------+-------+------------+----------------------------+ | 1 | a | 1 . 001 | 2022 - 02 - 08 | 2022 - 02 - 08 12 : 00 : 00 . 000000 | | 2 | b | 2 . 001 | 2022 - 02 - 09 | 2022 - 02 - 09 12 : 00 : 00 . 000000 | | 1 | c | 3 . 001 | 2022 - 02 - 10 | 2022 - 02 - 10 12 : 00 : 00 . 000000 | | 4 | d | 4 . 001 | 2022 - 02 - 11 | 2022 - 02 - 11 12 : 00 : 00 . 000000 | + ------+------+-------+------------+----------------------------+ 4 rows in set ( 0 . 01 sec ) > select * from t2 where e not in ( '2022-02-09 12:00:00' ) and a in ( 4 , 5 ); a b c d e 4 d 4 . 0010 2022 - 02 - 11 2022 - 02 - 11 12 : 00 : 00 Constraints Currently, only constant lists are supported on the left side of NOT IN . There can only be a single column to the left of NOT IN , not a tuple of multiple columns. NULL values couldn\u2019t appear in the list to the right of NOT IN .","title":"**NOT IN**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-in/#not-in","text":"","title":"NOT IN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-in/#description","text":"The NOT IN operator allows you to specify multiple values in a WHERE clause. And it's a shorthand for multiple XOR conditions.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-in/#syntax","text":"> SELECT column1, column2, ... FROM table_name WHERE column_name NOT IN (value1, value2, ...);","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-in/#examples","text":"> create table t2 ( a int , b varchar ( 5 ), c float , d date , e datetime ); > insert into t2 values ( 1 , 'a' , 1 . 001 , '2022-02-08' , '2022-02-08 12:00:00' ); > insert into t2 values ( 2 , 'b' , 2 . 001 , '2022-02-09' , '2022-02-09 12:00:00' ); > insert into t2 values ( 1 , 'c' , 3 . 001 , '2022-02-10' , '2022-02-10 12:00:00' ); > insert into t2 values ( 4 , 'd' , 4 . 001 , '2022-02-11' , '2022-02-11 12:00:00' ); > select * from t2 where a not in ( 2 , 4 ); + ------+------+-------+------------+----------------------------+ | a | b | c | d | e | + ------+------+-------+------------+----------------------------+ | 1 | a | 1 . 001 | 2022 - 02 - 08 | 2022 - 02 - 08 12 : 00 : 00 . 000000 | | 1 | c | 3 . 001 | 2022 - 02 - 10 | 2022 - 02 - 10 12 : 00 : 00 . 000000 | + ------+------+-------+------------+----------------------------+ 2 rows in set ( 0 . 00 sec ) > select * from t2 where b not in ( 'e' , \"f\" ); + ------+------+-------+------------+----------------------------+ | a | b | c | d | e | + ------+------+-------+------------+----------------------------+ | 1 | a | 1 . 001 | 2022 - 02 - 08 | 2022 - 02 - 08 12 : 00 : 00 . 000000 | | 2 | b | 2 . 001 | 2022 - 02 - 09 | 2022 - 02 - 09 12 : 00 : 00 . 000000 | | 1 | c | 3 . 001 | 2022 - 02 - 10 | 2022 - 02 - 10 12 : 00 : 00 . 000000 | | 4 | d | 4 . 001 | 2022 - 02 - 11 | 2022 - 02 - 11 12 : 00 : 00 . 000000 | + ------+------+-------+------------+----------------------------+ 4 rows in set ( 0 . 01 sec ) > select * from t2 where e not in ( '2022-02-09 12:00:00' ) and a in ( 4 , 5 ); a b c d e 4 d 4 . 0010 2022 - 02 - 11 2022 - 02 - 11 12 : 00 : 00","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-in/#constraints","text":"Currently, only constant lists are supported on the left side of NOT IN . There can only be a single column to the left of NOT IN , not a tuple of multiple columns. NULL values couldn\u2019t appear in the list to the right of NOT IN .","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-like/","text":"NOT LIKE Description The NOT LIKE operator is used in a WHERE clause to search for a specified pattern in a column. There are two wildcards often used in conjunction with the NOT LIKE operator: The percent sign (%) represents zero, one, or multiple characters. The underscore sign (_) represents one, single character. Syntax > SELECT column1, column2, ... FROM table_name WHERE columnN NOT LIKE pattern; Examples > create table t1 ( a char ( 10 )); > insert into t1 values ( 'abcdef' ); > insert into t1 values ( '_bcdef' ); > insert into t1 values ( 'a_cdef' ); > insert into t1 values ( 'ab_def' ); > insert into t1 values ( 'abc_ef' ); > insert into t1 values ( 'abcd_f' ); > insert into t1 values ( 'abcde_' ); > select * from t1 where a not like 'a%' ; + --------+ | a | + --------+ | _bcdef | + --------+ > select * from t1 where a not like \"%d_\\_\" ; + --------+ | a | + --------+ | abc_ef | + --------+ 1 row in set ( 0 . 01 sec )","title":"NOT LIKE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-like/#not-like","text":"","title":"NOT LIKE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-like/#description","text":"The NOT LIKE operator is used in a WHERE clause to search for a specified pattern in a column. There are two wildcards often used in conjunction with the NOT LIKE operator: The percent sign (%) represents zero, one, or multiple characters. The underscore sign (_) represents one, single character.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-like/#syntax","text":"> SELECT column1, column2, ... FROM table_name WHERE columnN NOT LIKE pattern;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/comparison-functions-and-operators/not-like/#examples","text":"> create table t1 ( a char ( 10 )); > insert into t1 values ( 'abcdef' ); > insert into t1 values ( '_bcdef' ); > insert into t1 values ( 'a_cdef' ); > insert into t1 values ( 'ab_def' ); > insert into t1 values ( 'abc_ef' ); > insert into t1 values ( 'abcd_f' ); > insert into t1 values ( 'abcde_' ); > select * from t1 where a not like 'a%' ; + --------+ | a | + --------+ | _bcdef | + --------+ > select * from t1 where a not like \"%d_\\_\" ; + --------+ | a | + --------+ | abc_ef | + --------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/case/","text":"CASE Description CASE WHEN statement is used in that evaluates a list of conditions and returns one of multiple possible result expressions. Cases come in two formats: a simple CASE function compares an expression to a set of simple expressions to determine the result. The CASE search function evaluates a set of Boolean expressions to determine the result. Both formats support the optional ELSE argument. Syntax Syntax 1 : CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] [ELSE result] END This CASE syntax returns the result for the first value=compare_value comparison that is true. Syntax 2 : CASE WHEN condition THEN result [WHEN condition THEN result ...] [ELSE result] END This CASE syntax returns the result for the first condition that is true. If no comparison or condition is true, the result after ELSE is returned, or NULL if there is no ELSE part. note The CASE statement cannot have an ELSE NULL clause, and it is terminated with END CASE instead of END . Examples > SELECT CASE WHEN 1 > 0 THEN 'true' ELSE 'false' END ; + ------------------------------------------+ | case when 1 > 0 then true else false end | + ------------------------------------------+ | true | + ------------------------------------------+ 1 row in set ( 0 . 00 sec ) > SELECT CASE 1 WHEN 1 THEN 'one' -> WHEN 2 THEN 'two' ELSE 'more' END ; + ------------------------------------------------------+ | case 1 when 1 then one when 2 then two else more end | + ------------------------------------------------------+ | one | + ------------------------------------------------------+ 1 row in set ( 0 . 00 sec )","title":"CASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/case/#case","text":"","title":"CASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/case/#description","text":"CASE WHEN statement is used in that evaluates a list of conditions and returns one of multiple possible result expressions. Cases come in two formats: a simple CASE function compares an expression to a set of simple expressions to determine the result. The CASE search function evaluates a set of Boolean expressions to determine the result. Both formats support the optional ELSE argument.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/case/#syntax","text":"Syntax 1 : CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] [ELSE result] END This CASE syntax returns the result for the first value=compare_value comparison that is true. Syntax 2 : CASE WHEN condition THEN result [WHEN condition THEN result ...] [ELSE result] END This CASE syntax returns the result for the first condition that is true. If no comparison or condition is true, the result after ELSE is returned, or NULL if there is no ELSE part. note The CASE statement cannot have an ELSE NULL clause, and it is terminated with END CASE instead of END .","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/case/#examples","text":"> SELECT CASE WHEN 1 > 0 THEN 'true' ELSE 'false' END ; + ------------------------------------------+ | case when 1 > 0 then true else false end | + ------------------------------------------+ | true | + ------------------------------------------+ 1 row in set ( 0 . 00 sec ) > SELECT CASE 1 WHEN 1 THEN 'one' -> WHEN 2 THEN 'two' ELSE 'more' END ; + ------------------------------------------------------+ | case 1 when 1 then one when 2 then two else more end | + ------------------------------------------------------+ | one | + ------------------------------------------------------+ 1 row in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/flow-control-functions-overview/","text":"Flow Control Functions Name Description CASE Case operator IF() If/else construct","title":"Flow Control Functions Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/flow-control-functions-overview/#flow-control-functions","text":"Name Description CASE Case operator IF() If/else construct","title":"Flow Control Functions"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_if/","text":"IF Description The IF() function returns a value if a condition is TRUE , or another value if a condition is FALSE . Syntax > IF(expr1,expr2,expr3) If expr1 is TRUE (expr1 <> 0 and expr1 IS NOT NULL), IF() returns expr2. Otherwise, it returns expr3. If only one of expr2 or expr3 is explicitly NULL, the result type of the IF() function is the type of the non-NULL expression. The default return type of IF() (which may matter when it is stored into a temporary table) is calculated as follows: If expr2 or expr3 produce a string, the result is a string. If expr2 and expr3 are both strings, the result is case-sensitive if either string is case-sensitive. If expr2 or expr3 produce a floating-point value, the result is a floating-point value. If expr2 or expr3 produce an integer, the result is an integer. Examples > SELECT IF ( 1 > 2 , 2 , 3 ); + -----------------+ | if ( 1 > 2 , 2 , 3 ) | + -----------------+ | 3 | + -----------------+ 1 row in set ( 0 . 01 sec ) > SELECT IF ( 1 < 2 , 'yes' , 'no' ); + --------------------+ | if ( 1 < 2 , yes , no ) | + --------------------+ | yes | + --------------------+ 1 row in set ( 0 . 00 sec ) > CREATE TABLE t1 ( st varchar ( 255 ) NOT NULL , u int ( 11 ) NOT NULL ); > INSERT INTO t1 VALUES ( 'a' , 1 ),( 'A' , 1 ),( 'aa' , 1 ),( 'AA' , 1 ),( 'a' , 1 ),( 'aaa' , 0 ),( 'BBB' , 0 ); > select if ( u = 1 , st , st ) s from t1 order by s ; + ------+ | s | + ------+ | A | | AA | | BBB | | a | | a | | aa | | aaa | + ------+ 7 rows in set ( 0 . 00 sec ) > select if ( u = 1 , st , st ) s from t1 where st like \"%a%\" order by s ; + ------+ | s | + ------+ | a | | a | | aa | | aaa | + ------+ 4 rows in set ( 0 . 00 sec ) Constraints Parameters BIGINT and VARCHAR are not supported with the function 'if'.","title":"IF"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_if/#if","text":"","title":"IF"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_if/#description","text":"The IF() function returns a value if a condition is TRUE , or another value if a condition is FALSE .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_if/#syntax","text":"> IF(expr1,expr2,expr3) If expr1 is TRUE (expr1 <> 0 and expr1 IS NOT NULL), IF() returns expr2. Otherwise, it returns expr3. If only one of expr2 or expr3 is explicitly NULL, the result type of the IF() function is the type of the non-NULL expression. The default return type of IF() (which may matter when it is stored into a temporary table) is calculated as follows: If expr2 or expr3 produce a string, the result is a string. If expr2 and expr3 are both strings, the result is case-sensitive if either string is case-sensitive. If expr2 or expr3 produce a floating-point value, the result is a floating-point value. If expr2 or expr3 produce an integer, the result is an integer.","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_if/#examples","text":"> SELECT IF ( 1 > 2 , 2 , 3 ); + -----------------+ | if ( 1 > 2 , 2 , 3 ) | + -----------------+ | 3 | + -----------------+ 1 row in set ( 0 . 01 sec ) > SELECT IF ( 1 < 2 , 'yes' , 'no' ); + --------------------+ | if ( 1 < 2 , yes , no ) | + --------------------+ | yes | + --------------------+ 1 row in set ( 0 . 00 sec ) > CREATE TABLE t1 ( st varchar ( 255 ) NOT NULL , u int ( 11 ) NOT NULL ); > INSERT INTO t1 VALUES ( 'a' , 1 ),( 'A' , 1 ),( 'aa' , 1 ),( 'AA' , 1 ),( 'a' , 1 ),( 'aaa' , 0 ),( 'BBB' , 0 ); > select if ( u = 1 , st , st ) s from t1 order by s ; + ------+ | s | + ------+ | A | | AA | | BBB | | a | | a | | aa | | aaa | + ------+ 7 rows in set ( 0 . 00 sec ) > select if ( u = 1 , st , st ) s from t1 where st like \"%a%\" order by s ; + ------+ | s | + ------+ | a | | a | | aa | | aaa | + ------+ 4 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_if/#constraints","text":"Parameters BIGINT and VARCHAR are not supported with the function 'if'.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_ifnull/","text":"IFNULL Description If expr1 is not NULL , IFNULL() returns expr1; otherwise it returns expr2. The default return type of IFNULL(expr1,expr2) is the more \u201cgeneral\u201d of the two expressions, in the order STRING , REAL , or INTEGER . Syntax > IFNULL(expr1,expr2) Examples > SELECT IFNULL ( NULL , 10 ); + ------------------+ | ifnull ( null , 10 ) | + ------------------+ | 10 | + ------------------+ 1 row in set ( 0 . 00 sec ) SELECT CAST ( IFNULL ( NULL , NULL ) AS DECIMAL ); + -----------------------------------------+ | cast ( ifnull ( null , null ) as decimal ( 10 )) | + -----------------------------------------+ | NULL | + -----------------------------------------+ 1 row in set ( 0 . 01 sec )","title":"**IFNULL**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_ifnull/#ifnull","text":"","title":"IFNULL"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_ifnull/#description","text":"If expr1 is not NULL , IFNULL() returns expr1; otherwise it returns expr2. The default return type of IFNULL(expr1,expr2) is the more \u201cgeneral\u201d of the two expressions, in the order STRING , REAL , or INTEGER .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_ifnull/#syntax","text":"> IFNULL(expr1,expr2)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_ifnull/#examples","text":"> SELECT IFNULL ( NULL , 10 ); + ------------------+ | ifnull ( null , 10 ) | + ------------------+ | 10 | + ------------------+ 1 row in set ( 0 . 00 sec ) SELECT CAST ( IFNULL ( NULL , NULL ) AS DECIMAL ); + -----------------------------------------+ | cast ( ifnull ( null , null ) as decimal ( 10 )) | + -----------------------------------------+ | NULL | + -----------------------------------------+ 1 row in set ( 0 . 01 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_nullif/","text":"NULLIF Description The NULLIF() function returns NULL if expr1 = expr2 is true, otherwise returns expr1. The return value has the same type as the first argument. Syntax > NULLIF(expr1,expr2) Examples > SELECT NULLIF ( 1 , 1 ); + --------------+ | nullif ( 1 , 1 ) | + --------------+ | NULL | + --------------+ 1 row in set ( 0 . 00 sec ) > SELECT NULLIF ( 1 , 2 ); + --------------+ | nullif ( 1 , 2 ) | + --------------+ | 1 | + --------------+ 1 row in set ( 0 . 01 sec ) > SELECT CAST ( IFNULL ( NULL , NULL ) AS DECIMAL ); + -----------------------------------------+ | cast ( ifnull ( null , null ) as decimal ( 10 )) | + -----------------------------------------+ | NULL | + -----------------------------------------+","title":"**NULLIF**"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_nullif/#nullif","text":"","title":"NULLIF"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_nullif/#description","text":"The NULLIF() function returns NULL if expr1 = expr2 is true, otherwise returns expr1. The return value has the same type as the first argument.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_nullif/#syntax","text":"> NULLIF(expr1,expr2)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/flow-control-functions/function_nullif/#examples","text":"> SELECT NULLIF ( 1 , 1 ); + --------------+ | nullif ( 1 , 1 ) | + --------------+ | NULL | + --------------+ 1 row in set ( 0 . 00 sec ) > SELECT NULLIF ( 1 , 2 ); + --------------+ | nullif ( 1 , 2 ) | + --------------+ | 1 | + --------------+ 1 row in set ( 0 . 01 sec ) > SELECT CAST ( IFNULL ( NULL , NULL ) AS DECIMAL ); + -----------------------------------------+ | cast ( ifnull ( null , null ) as decimal ( 10 )) | + -----------------------------------------+ | NULL | + -----------------------------------------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/and/","text":"AND,&& Description Logical AND,&& . Evaluates to true if all operands are nonzero and not NULL, to false if one or more operands are 0, otherwise NULL is returned. Syntax > SELECT column_1 AND column_2 FROM table_name; Examples > select 1 and 1 ; + ---------+ | 1 and 1 | + ---------+ | true | + ---------+ > select 1 and 0 ; + ---------+ | 1 and 0 | + ---------+ | false | + ---------+ > select 1 and null ; + ------------+ | 1 and null | + ------------+ | NULL | + ------------+ > select null and 0 ; + ------------+ | null and 0 | + ------------+ | false | + ------------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; > select a and b from t1 ; + ---------+ | a and b | + ---------+ | false | | false | | true | | false | | NULL | + ---------+ 5 rows in set ( 0 . 00 sec )","title":"AND,&&"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/and/#and","text":"","title":"AND,&amp;&amp;"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/and/#description","text":"Logical AND,&& . Evaluates to true if all operands are nonzero and not NULL, to false if one or more operands are 0, otherwise NULL is returned.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/and/#syntax","text":"> SELECT column_1 AND column_2 FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/and/#examples","text":"> select 1 and 1 ; + ---------+ | 1 and 1 | + ---------+ | true | + ---------+ > select 1 and 0 ; + ---------+ | 1 and 0 | + ---------+ | false | + ---------+ > select 1 and null ; + ------------+ | 1 and null | + ------------+ | NULL | + ------------+ > select null and 0 ; + ------------+ | null and 0 | + ------------+ | false | + ------------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; > select a and b from t1 ; + ---------+ | a and b | + ---------+ | false | | false | | true | | false | | NULL | + ---------+ 5 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/logical-operators-overview/","text":"Logical Operators Name Description AND,&& Logical AND NOT,! Negates value OR Logical OR XOR Logical XOR","title":"Logical Operators Overview"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/logical-operators-overview/#logical-operators","text":"Name Description AND,&& Logical AND NOT,! Negates value OR Logical OR XOR Logical XOR","title":"Logical Operators"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/not/","text":"NOT,! Description Logical NOT,! . Evaluates to true if the operand is 0, to false if the operand is nonzero, and NOT NULL returns NULL. Syntax > SELECT not column_name FROM table_name; Examples > select not 0 ; + -------+ | not 0 | + -------+ | true | + -------+ 1 row in set ( 0 . 02 sec ) > select not null ; + ----------+ | not null | + ----------+ | NULL | + ----------+ 1 row in set ( 0 . 00 sec ) > select not 1 ; + -------+ | not 1 | + -------+ | false | + -------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; > select not a and not b from t1 ; + -----------------+ | not a and not b | + -----------------+ | false | | false | | false | | true | | NULL | + -----------------+ 5 rows in set ( 0 . 00 sec ) Constraints ! is not supported for now.","title":"NOT,!"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/not/#not","text":"","title":"NOT,!"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/not/#description","text":"Logical NOT,! . Evaluates to true if the operand is 0, to false if the operand is nonzero, and NOT NULL returns NULL.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/not/#syntax","text":"> SELECT not column_name FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/not/#examples","text":"> select not 0 ; + -------+ | not 0 | + -------+ | true | + -------+ 1 row in set ( 0 . 02 sec ) > select not null ; + ----------+ | not null | + ----------+ | NULL | + ----------+ 1 row in set ( 0 . 00 sec ) > select not 1 ; + -------+ | not 1 | + -------+ | false | + -------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; > select not a and not b from t1 ; + -----------------+ | not a and not b | + -----------------+ | false | | false | | false | | true | | NULL | + -----------------+ 5 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/not/#constraints","text":"! is not supported for now.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/or/","text":"OR Description Logical OR,|| . When both operands are non-NULL, the result is true if any operand is nonzero, and false otherwise. With a NULL operand, the result is true if the other operand is nonzero, and NULL otherwise. If both operands are NULL , the result is NULL . Syntax > SELECT column_1 OR column_2 FROM table_name; Examples > select 1 or 1 ; + --------+ | 1 or 1 | + --------+ | true | + --------+ 1 row in set ( 0 . 01 sec ) > select 1 or 0 ; + --------+ | 1 or 0 | + --------+ | true | + --------+ 1 row in set ( 0 . 00 sec ) > select 0 or 0 ; + --------+ | 0 or 0 | + --------+ | false | + --------+ 1 row in set ( 0 . 01 sec ) > select 0 or null ; + -----------+ | 0 or null | + -----------+ | NULL | + -----------+ 1 row in set ( 0 . 00 sec ) > select 1 or null ; + -----------+ | 1 or null | + -----------+ | true | + -----------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; > select a or b from t1 ; + --------+ | a or b | + --------+ | true | | true | | true | | false | | NULL | + --------+ 5 rows in set ( 0 . 00 sec )","title":"OR"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/or/#or","text":"","title":"OR"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/or/#description","text":"Logical OR,|| . When both operands are non-NULL, the result is true if any operand is nonzero, and false otherwise. With a NULL operand, the result is true if the other operand is nonzero, and NULL otherwise. If both operands are NULL , the result is NULL .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/or/#syntax","text":"> SELECT column_1 OR column_2 FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/or/#examples","text":"> select 1 or 1 ; + --------+ | 1 or 1 | + --------+ | true | + --------+ 1 row in set ( 0 . 01 sec ) > select 1 or 0 ; + --------+ | 1 or 0 | + --------+ | true | + --------+ 1 row in set ( 0 . 00 sec ) > select 0 or 0 ; + --------+ | 0 or 0 | + --------+ | false | + --------+ 1 row in set ( 0 . 01 sec ) > select 0 or null ; + -----------+ | 0 or null | + -----------+ | NULL | + -----------+ 1 row in set ( 0 . 00 sec ) > select 1 or null ; + -----------+ | 1 or null | + -----------+ | true | + -----------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; > select a or b from t1 ; + --------+ | a or b | + --------+ | true | | true | | true | | false | | NULL | + --------+ 5 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/xor/","text":"XOR Description Logical XOR . Returns NULL if either operand is NULL. For non-NULL operands, evaluates to true if an odd number of operands is nonzero, otherwise false is returned. a XOR b is mathematically equal to (a AND (NOT b)) OR ((NOT a) and b) . Syntax > SELECT column_1 XOR column_2 FROM table_name; Examples > select 1 xor 1 ; + ---------+ | 1 xor 1 | + ---------+ | false | + ---------+ 1 row in set ( 0 . 01 sec ) > select 1 xor 0 ; + ---------+ | 1 xor 0 | + ---------+ | true | + ---------+ 1 row in set ( 0 . 00 sec ) > select 1 xor null ; + ------------+ | 1 xor null | + ------------+ | NULL | + ------------+ 1 row in set ( 0 . 01 sec ) > select 1 xor 1 xor 1 ; + ---------------+ | 1 xor 1 xor 1 | + ---------------+ | true | + ---------------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; > select a xor b from t1 ; + ---------+ | a xor b | + ---------+ | true | | true | | false | | false | | NULL | + ---------+ 5 rows in set ( 0 . 00 sec )","title":"XOR"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/xor/#xor","text":"","title":"XOR"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/xor/#description","text":"Logical XOR . Returns NULL if either operand is NULL. For non-NULL operands, evaluates to true if an odd number of operands is nonzero, otherwise false is returned. a XOR b is mathematically equal to (a AND (NOT b)) OR ((NOT a) and b) .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/xor/#syntax","text":"> SELECT column_1 XOR column_2 FROM table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/operators/logical-operators/xor/#examples","text":"> select 1 xor 1 ; + ---------+ | 1 xor 1 | + ---------+ | false | + ---------+ 1 row in set ( 0 . 01 sec ) > select 1 xor 0 ; + ---------+ | 1 xor 0 | + ---------+ | true | + ---------+ 1 row in set ( 0 . 00 sec ) > select 1 xor null ; + ------------+ | 1 xor null | + ------------+ | NULL | + ------------+ 1 row in set ( 0 . 01 sec ) > select 1 xor 1 xor 1 ; + ---------------+ | 1 xor 1 xor 1 | + ---------------+ | true | + ---------------+ 1 row in set ( 0 . 00 sec ) > create table t1 ( a boolean , b bool ); > insert into t1 values ( 0 , 1 ),( true , false ),( true , 1 ),( 0 , false ),( NULL , NULL ); > select * from t1 ; > select a xor b from t1 ; + ---------+ | a xor b | + ---------+ | true | | true | | false | | false | | NULL | + ---------+ 5 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/from-subquery/","text":"Subqueries in the FROM Clause (beta) Description This topic describes subqueries that occur as nested SELECT statements in the FROM clause of an outer SELECT statement. Such subqueries are sometimes called derived tables or table expressions because the outer query uses the results of the subquery as a data source. Syntax Every table in a FROM clause must have a name, therefore the [AS] name clause is mandatory. Any columns in the subquery select list must have unique names. > SELECT ... FROM (subquery) [AS] name ... Examples > CREATE TABLE tb1 ( c1 INT , c2 CHAR ( 5 ), c3 FLOAT ); > INSERT INTO tb1 VALUES ( 1 , '1' , 1 . 0 ); > INSERT INTO tb1 VALUES ( 2 , '2' , 2 . 0 ); > INSERT INTO tb1 VALUES ( 3 , '3' , 3 . 0 ); > select * from tb1 ; + ------+------+--------+ | c1 | c2 | c3 | + ------+------+--------+ | 1 | 1 | 1 . 0000 | | 2 | 2 | 2 . 0000 | | 3 | 3 | 3 . 0000 | + ------+------+--------+ 3 rows in set ( 0 . 03 sec ) > SELECT sc1 , sc2 , sc3 FROM ( SELECT c1 AS sc1 , c2 AS sc2 , c3 * 3 AS sc3 FROM tb1 ) AS sb WHERE sc1 > 1 ; + ------+------+--------+ | sc1 | sc2 | sc3 | + ------+------+--------+ | 2 | 2 | 6 . 0000 | | 3 | 3 | 9 . 0000 | + ------+------+--------+ 2 rows in set ( 0 . 02 sec )","title":"FROM SUBQUERY"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/from-subquery/#subqueries-in-the-from-clause-beta","text":"","title":"Subqueries in the FROM Clause (beta)"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/from-subquery/#description","text":"This topic describes subqueries that occur as nested SELECT statements in the FROM clause of an outer SELECT statement. Such subqueries are sometimes called derived tables or table expressions because the outer query uses the results of the subquery as a data source.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/from-subquery/#syntax","text":"Every table in a FROM clause must have a name, therefore the [AS] name clause is mandatory. Any columns in the subquery select list must have unique names. > SELECT ... FROM (subquery) [AS] name ...","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/from-subquery/#examples","text":"> CREATE TABLE tb1 ( c1 INT , c2 CHAR ( 5 ), c3 FLOAT ); > INSERT INTO tb1 VALUES ( 1 , '1' , 1 . 0 ); > INSERT INTO tb1 VALUES ( 2 , '2' , 2 . 0 ); > INSERT INTO tb1 VALUES ( 3 , '3' , 3 . 0 ); > select * from tb1 ; + ------+------+--------+ | c1 | c2 | c3 | + ------+------+--------+ | 1 | 1 | 1 . 0000 | | 2 | 2 | 2 . 0000 | | 3 | 3 | 3 . 0000 | + ------+------+--------+ 3 rows in set ( 0 . 03 sec ) > SELECT sc1 , sc2 , sc3 FROM ( SELECT c1 AS sc1 , c2 AS sc2 , c3 * 3 AS sc3 FROM tb1 ) AS sb WHERE sc1 > 1 ; + ------+------+--------+ | sc1 | sc2 | sc3 | + ------+------+--------+ | 2 | 2 | 6 . 0000 | | 3 | 3 | 9 . 0000 | + ------+------+--------+ 2 rows in set ( 0 . 02 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-any/","text":"Subqueries with ANY Description Comparison operators (=, >, < , etc.) are used only on subqueries that return one row. SQL Subqueries with ANY , you can make comparisons on subqueries that return multiple rows. ANY evaluate whether any or all of the values returned by a subquery match the left-hand expression. Subqueries that use the ANY keyword return true when any value retrieved in the subquery matches the value of the left-hand expression. note The word SOME is an alias for ANY . Syntax > SELECT column_name(s) FROM table_name WHERE column_name ANY (subquery); Examples > create table t1 ( a int ); > create table t2 ( a int , b int ); > create table t3 ( a int ); > create table t4 ( a int not null , b int not null ); > insert into t1 values ( 2 ); > insert into t2 values ( 1 , 7 ),( 2 , 7 ); > insert into t4 values ( 4 , 8 ),( 3 , 8 ),( 5 , 9 ); > insert into t3 values ( 6 ),( 7 ),( 3 ); > select * from t3 where a <> any ( select b from t2 ); + ------+ | a | + ------+ | 6 | | 3 | + ------+ 2 rows in set ( 0 . 00 sec ) > select * from t3 where a <> some ( select b from t2 ); + ------+ | a | + ------+ | 6 | | 3 | + ------+ 2 rows in set ( 0 . 00 sec ) > select * from t3 where a = some ( select b from t2 ); + ------+ | a | + ------+ | 7 | + ------+ 1 row in set ( 0 . 00 sec ) > select * from t3 where a = any ( select b from t2 ); + ------+ | a | + ------+ | 7 | + ------+ 1 row in set ( 0 . 00 sec )","title":"SUBQUERY with ANY"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-any/#subqueries-with-any","text":"","title":"Subqueries with ANY"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-any/#description","text":"Comparison operators (=, >, < , etc.) are used only on subqueries that return one row. SQL Subqueries with ANY , you can make comparisons on subqueries that return multiple rows. ANY evaluate whether any or all of the values returned by a subquery match the left-hand expression. Subqueries that use the ANY keyword return true when any value retrieved in the subquery matches the value of the left-hand expression. note The word SOME is an alias for ANY .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-any/#syntax","text":"> SELECT column_name(s) FROM table_name WHERE column_name ANY (subquery);","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-any/#examples","text":"> create table t1 ( a int ); > create table t2 ( a int , b int ); > create table t3 ( a int ); > create table t4 ( a int not null , b int not null ); > insert into t1 values ( 2 ); > insert into t2 values ( 1 , 7 ),( 2 , 7 ); > insert into t4 values ( 4 , 8 ),( 3 , 8 ),( 5 , 9 ); > insert into t3 values ( 6 ),( 7 ),( 3 ); > select * from t3 where a <> any ( select b from t2 ); + ------+ | a | + ------+ | 6 | | 3 | + ------+ 2 rows in set ( 0 . 00 sec ) > select * from t3 where a <> some ( select b from t2 ); + ------+ | a | + ------+ | 6 | | 3 | + ------+ 2 rows in set ( 0 . 00 sec ) > select * from t3 where a = some ( select b from t2 ); + ------+ | a | + ------+ | 7 | + ------+ 1 row in set ( 0 . 00 sec ) > select * from t3 where a = any ( select b from t2 ); + ------+ | a | + ------+ | 7 | + ------+ 1 row in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-exists/","text":"Subqueries with EXISTS or NOT EXISTS Description The EXISTS operator is used to test for the existence of any record in a subquery. If a subquery returns any rows at all, EXISTS subquery is TRUE , and NOT EXISTS subquery is FALSE . Syntax > SELECT column_name(s) FROM table_name WHERE EXISTS (SELECT column_name FROM table_name WHERE condition); Examples > create table t1 ( a int ); > create table t2 ( a int , b int ); > create table t3 ( a int ); > create table t4 ( a int not null , b int not null ); > insert into t1 values ( 2 ); > insert into t2 values ( 1 , 7 ),( 2 , 7 ); > insert into t4 values ( 4 , 8 ),( 3 , 8 ),( 5 , 9 ); > insert into t3 values ( 6 ),( 7 ),( 3 ); > select * from t3 where exists ( select * from t2 where t2 . b = t3 . a ); + ------+ | a | + ------+ | 7 | + ------+ 1 row in set ( 0 . 00 sec ) > select * from t3 where not exists ( select * from t2 where t2 . b = t3 . a ); + ------+ | a | + ------+ | 6 | | 3 | + ------+ 2 rows in set ( 0 . 00 sec )","title":"SUBQUERY with EXISTS"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-exists/#subqueries-with-exists-or-not-exists","text":"","title":"Subqueries with EXISTS or NOT EXISTS"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-exists/#description","text":"The EXISTS operator is used to test for the existence of any record in a subquery. If a subquery returns any rows at all, EXISTS subquery is TRUE , and NOT EXISTS subquery is FALSE .","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-exists/#syntax","text":"> SELECT column_name(s) FROM table_name WHERE EXISTS (SELECT column_name FROM table_name WHERE condition);","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-exists/#examples","text":"> create table t1 ( a int ); > create table t2 ( a int , b int ); > create table t3 ( a int ); > create table t4 ( a int not null , b int not null ); > insert into t1 values ( 2 ); > insert into t2 values ( 1 , 7 ),( 2 , 7 ); > insert into t4 values ( 4 , 8 ),( 3 , 8 ),( 5 , 9 ); > insert into t3 values ( 6 ),( 7 ),( 3 ); > select * from t3 where exists ( select * from t2 where t2 . b = t3 . a ); + ------+ | a | + ------+ | 7 | + ------+ 1 row in set ( 0 . 00 sec ) > select * from t3 where not exists ( select * from t2 where t2 . b = t3 . a ); + ------+ | a | + ------+ | 6 | | 3 | + ------+ 2 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-in/","text":"Subqueries with IN Description A subquery can be used with the IN operator as \"expression IN (subquery)\". The subquery should return a single column with one or more rows to form a list of values to be used by the IN operation. Use the IN clause for multiple-record, single-column subqueries. After the subquery returns results introduced by IN or NOT IN , the outer query uses them to return the final result. If any row in the sub-query result matches, the answer is true. If the subquery result is empty, the answer is false. If no row in the sub-query result matches, the answer is also false. If all of the values in the sub-query result are null, the answer is false. Syntax > SELECT ... FROM table_name WHERE column_name IN (subquery) Examples > create table t1 ( val varchar ( 10 )); > insert into t1 values ( 'aaa' ), ( 'bbb' ),( 'eee' ),( 'mmm' ),( 'ppp' ); > select count ( * ) from t1 as w1 where w1 . val in ( select w2 . val from t1 as w2 where w2 . val like 'm%' ) and w1 . val in ( select w3 . val from t1 as w3 where w3 . val like 'e%' ); + ----------+ | count ( * ) | + ----------+ | 0 | + ----------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( id int not null , text varchar ( 20 ) not null default '' , primary key ( id )); > insert into t1 ( id , text ) values ( 1 , 'text1' ), ( 2 , 'text2' ), ( 3 , 'text3' ), ( 4 , 'text4' ), ( 5 , 'text5' ), ( 6 , 'text6' ), ( 7 , 'text7' ), ( 8 , 'text8' ), ( 9 , 'text9' ), ( 10 , 'text10' ), ( 11 , 'text11' ), ( 12 , 'text12' ); > select * from t1 where id not in ( select id from t1 where id < 8 ); + ------+--------+ | id | text | + ------+--------+ | 8 | text8 | | 9 | text9 | | 10 | text10 | | 11 | text11 | | 12 | text12 | + ------+--------+ 5 rows in set ( 0 . 00 sec ) > CREATE TABLE t1 ( a int ); > CREATE TABLE t2 ( a int , b int ); > CREATE TABLE t3 ( b int NOT NULL ); > INSERT INTO t1 VALUES ( 1 ), ( 2 ), ( 3 ), ( 4 ); > INSERT INTO t2 VALUES ( 1 , 10 ), ( 3 , 30 ); > select * from t1 where t1 . a in ( SELECT t1 . a FROM t1 LEFT JOIN t2 ON t2 . a = t1 . a ); + ------+ | a | + ------+ | 1 | | 2 | | 3 | | 4 | + ------+ 4 rows in set ( 0 . 01 sec ) > SELECT * FROM t2 LEFT JOIN t3 ON t2 . b = t3 . b WHERE t3 . b IS NOT NULL OR t2 . a > 10 ; Empty set ( 0 . 01 sec ) > SELECT * FROM t1 WHERE t1 . a NOT IN ( SELECT a FROM t2 LEFT JOIN t3 ON t2 . b = t3 . b WHERE t3 . b IS NOT NULL OR t2 . a > 10 ); + ------+ | a | + ------+ | 1 | | 2 | | 3 | | 4 | + ------+ 4 rows in set ( 0 . 00 sec )","title":"SUBQUERY with IN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-in/#subqueries-with-in","text":"","title":"Subqueries with IN"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-in/#description","text":"A subquery can be used with the IN operator as \"expression IN (subquery)\". The subquery should return a single column with one or more rows to form a list of values to be used by the IN operation. Use the IN clause for multiple-record, single-column subqueries. After the subquery returns results introduced by IN or NOT IN , the outer query uses them to return the final result. If any row in the sub-query result matches, the answer is true. If the subquery result is empty, the answer is false. If no row in the sub-query result matches, the answer is also false. If all of the values in the sub-query result are null, the answer is false.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-in/#syntax","text":"> SELECT ... FROM table_name WHERE column_name IN (subquery)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/subqueries/subquery-with-in/#examples","text":"> create table t1 ( val varchar ( 10 )); > insert into t1 values ( 'aaa' ), ( 'bbb' ),( 'eee' ),( 'mmm' ),( 'ppp' ); > select count ( * ) from t1 as w1 where w1 . val in ( select w2 . val from t1 as w2 where w2 . val like 'm%' ) and w1 . val in ( select w3 . val from t1 as w3 where w3 . val like 'e%' ); + ----------+ | count ( * ) | + ----------+ | 0 | + ----------+ 1 row in set ( 0 . 01 sec ) > create table t1 ( id int not null , text varchar ( 20 ) not null default '' , primary key ( id )); > insert into t1 ( id , text ) values ( 1 , 'text1' ), ( 2 , 'text2' ), ( 3 , 'text3' ), ( 4 , 'text4' ), ( 5 , 'text5' ), ( 6 , 'text6' ), ( 7 , 'text7' ), ( 8 , 'text8' ), ( 9 , 'text9' ), ( 10 , 'text10' ), ( 11 , 'text11' ), ( 12 , 'text12' ); > select * from t1 where id not in ( select id from t1 where id < 8 ); + ------+--------+ | id | text | + ------+--------+ | 8 | text8 | | 9 | text9 | | 10 | text10 | | 11 | text11 | | 12 | text12 | + ------+--------+ 5 rows in set ( 0 . 00 sec ) > CREATE TABLE t1 ( a int ); > CREATE TABLE t2 ( a int , b int ); > CREATE TABLE t3 ( b int NOT NULL ); > INSERT INTO t1 VALUES ( 1 ), ( 2 ), ( 3 ), ( 4 ); > INSERT INTO t2 VALUES ( 1 , 10 ), ( 3 , 30 ); > select * from t1 where t1 . a in ( SELECT t1 . a FROM t1 LEFT JOIN t2 ON t2 . a = t1 . a ); + ------+ | a | + ------+ | 1 | | 2 | | 3 | | 4 | + ------+ 4 rows in set ( 0 . 01 sec ) > SELECT * FROM t2 LEFT JOIN t3 ON t2 . b = t3 . b WHERE t3 . b IS NOT NULL OR t2 . a > 10 ; Empty set ( 0 . 01 sec ) > SELECT * FROM t1 WHERE t1 . a NOT IN ( SELECT a FROM t2 LEFT JOIN t3 ON t2 . b = t3 . b WHERE t3 . b IS NOT NULL OR t2 . a > 10 ); + ------+ | a | + ------+ | 1 | | 2 | | 3 | | 4 | + ------+ 4 rows in set ( 0 . 00 sec )","title":"Examples"},{"location":"MatrixOne/Reference/System-Parameters/configuration-settings/","text":"The configuration file is located in matrixone/pkg/config/test/system_vars_config.toml . The 0.1.0 version is a standalone version, only the following parameters should be paied attention to. The other settings should remain default. General Settings Parameter Type Default Value Range Functionality rootpassword string \"\" string value password for root user dumpdatabase string default string value dump database name for backup port int64 6001 [0 - 65536] port defines which port the mo-server listens on and clients connect to host string 0.0.0.0 [0.0.0.0 - 255.255.255.255] listening ip sendRow bool false [true, false] send data row while producing dumpEnv bool false [true, false] dump Environment with memEngine Null nodes for testing Debug Settings Parameter Type Default Value Range Functionality level string debug [debug, info, warn, error, fatal] the log output level format string json [json, console] output log style filename string \"\" string value output log filename max-size int64 512 [0 - 314572800] maximum log file size max-days int64 0 [0 - 314572800] maximum log file days kept max-backups int64 0 [0 - 314572800] maximum numbers of old log files to retain Memory Settings Parameter Type Default Value Range Functionality hostMmuLimitation int64 1099511627776 [0 - 1099511627776] host mmu limitation. default: 1 << 40 = 1099511627776 guestMmuLimitation int64 1099511627776 [0 - 1099511627776] guest mmu limitation. default: 1 << 40 = 1099511627776 mempoolMaxSize int64 1099511627776 [0 - 1099511627776] mempool maxsize. default: 1 << 40 = 1099511627776 mempoolFactor int64 8 [0 - TBD] mempool factor. Default: 8 processLimitationSize int64 42949672960 [0 - 42949672960] process.Limitation.Size. default: 10 << 32 = 42949672960 processLimitationBatchRows int64 42949672960 [0 - 42949672960] process.Limitation.BatchRows. default: 10 << 32 = 42949672960 processLimitationBatchRows int64 42949672960 [0 - 42949672960] process.Limitation.BatchRows. default: 10 << 32 = 42949672960 processLimitationPartitionRows int64 42949672960 [0 - 42949672960] process.Limitation.PartitionRows. default: 10 << 32 = 42949672960","title":"General Settings"},{"location":"MatrixOne/Reference/System-Parameters/configuration-settings/#general-settings","text":"Parameter Type Default Value Range Functionality rootpassword string \"\" string value password for root user dumpdatabase string default string value dump database name for backup port int64 6001 [0 - 65536] port defines which port the mo-server listens on and clients connect to host string 0.0.0.0 [0.0.0.0 - 255.255.255.255] listening ip sendRow bool false [true, false] send data row while producing dumpEnv bool false [true, false] dump Environment with memEngine Null nodes for testing","title":"General Settings"},{"location":"MatrixOne/Reference/System-Parameters/configuration-settings/#debug-settings","text":"Parameter Type Default Value Range Functionality level string debug [debug, info, warn, error, fatal] the log output level format string json [json, console] output log style filename string \"\" string value output log filename max-size int64 512 [0 - 314572800] maximum log file size max-days int64 0 [0 - 314572800] maximum log file days kept max-backups int64 0 [0 - 314572800] maximum numbers of old log files to retain","title":"Debug Settings"},{"location":"MatrixOne/Reference/System-Parameters/configuration-settings/#memory-settings","text":"Parameter Type Default Value Range Functionality hostMmuLimitation int64 1099511627776 [0 - 1099511627776] host mmu limitation. default: 1 << 40 = 1099511627776 guestMmuLimitation int64 1099511627776 [0 - 1099511627776] guest mmu limitation. default: 1 << 40 = 1099511627776 mempoolMaxSize int64 1099511627776 [0 - 1099511627776] mempool maxsize. default: 1 << 40 = 1099511627776 mempoolFactor int64 8 [0 - TBD] mempool factor. Default: 8 processLimitationSize int64 42949672960 [0 - 42949672960] process.Limitation.Size. default: 10 << 32 = 42949672960 processLimitationBatchRows int64 42949672960 [0 - 42949672960] process.Limitation.BatchRows. default: 10 << 32 = 42949672960 processLimitationBatchRows int64 42949672960 [0 - 42949672960] process.Limitation.BatchRows. default: 10 << 32 = 42949672960 processLimitationPartitionRows int64 42949672960 [0 - 42949672960] process.Limitation.PartitionRows. default: 10 << 32 = 42949672960","title":"Memory Settings"},{"location":"MatrixOne/Reference/System-Parameters/distributed-settings/","text":"For a distributed setting, the following parameters should be paied attention to. Configuration Settings To configurate a distributed setting, following parameters need to be modified in the default Configuration file 'system_vars_config.toml'. nodeID nodeID is the Node ID of the cube. In a cluster, each node should have a different nodeID . addr-raft and addr-advertise-raft addr-raft is the address for raft-group rpc communication. It is the 10000 port of the node. addr-raft = \"localhost:10000\" Only docker deployment need adjust addr-advertise-raft For docker deployment, the ip is 0.0.0.0 addr-raft = \"0.0.0.0:10000\" In the case that some clients cannot access the raft-group, addr-advertise-raft must be manually set. addr-advertise-raft = \"${HOST}:10000\" addr-client and addr-advertise-client addr-client is the address for cube service. It is the 20000 port of the node. addr-client = \"localhost:20000\" Only docker deployment need adjust addr-advertise-client For docker deployment, the ip is 0.0.0.0 addr-client = \"0.0.0.0:20000\" In the case that a client cannot access Cube through the default client URLs listened to by Cube, addr-advertise-client must be manually set. addr-advertise-client = \"${HOST}:20000\" dir-data dir-data is the directory for cube data. In a cluster, each node should have a different dir-data . store-heartbeat-duration store-heartbeat-duration is the period for this node to report information to scheduler. It should be less than 10s. prophet name name in Prophet Configs is the name of the node. In a cluster, each node should have a different prophet name. name = \"node0\" rpc-addr and rpc-advertise-addr rpc-addr is the address for other clients to access prophet. It is the 30000 port of the node. rpc-addr = \"localhost:30000\" Only docker deployment need adjust rpc-advertise-addr For docker deployment, the ip is 0.0.0.0 rpc-addr = \"0.0.0.0:30000\" In the case that a client cannot access prophet, rpc-advertise-addr must be manually set. rpc-advertise-addr = \"${HOST}:30000\" prophet-node prophet-node is whether the node is a pure prophet node. For the three prophet nodes, prophet-node is true . prophet-node = true For pure prophet nodes, prophet-node is false prophet-node = false external-etcd For the three prophet nodes, external-etcd is empty. external-etcd = [\"\", \"\", \"\"] For pure storage nodes, external-etcd is the list of the client-urls of the three prophet nodes, i.e. the 40000 port of the prophet nodes. external-etcd = [\"http://ip_of_prophet_node1:40000\", \"http://ip_of_prophet_node2:40000\", \"http://ip_of_prophet_node3:40000\"] join join is for the second and third prophet nodes to join the raft group. For the first prophet node, join is a empty string. join = \"\" For the second and third prophet node, join is the peer-urls of the first prophet node. join = \"http://ip_of_the_first_prophet_node:40000\" For pure storage nodes, there's no need to adjust join . client-urls and advertise-client-urls client-urls is exposed to other nodes in the cluster. It is 40000 port of the node client-urls = \"http://localhost:40000\" Only docker deployment need adjust advertise-client-urls For docker deployment, the ip is 0.0.0.0 client-urls = \"http://0.0.0.0:40000\" In the case that some clients ccannot access prophet through the default client URLs listened to by prophet, advertise-client-urls must be manually set. advertise-client-urls = \"http://${HOST}:40000 peer-urls and advertise-peer-urls peer-urls is the list of peer URLs to be listened to by a prophet node. It is the 40000 port of the node. peer-urls = \"http://localhost:50000\" Only docker deployment need adjust advertise-peer-urls For docker deployment, the ip is 0.0.0.0 peer-urls = \"http://0.0.0.0:50000\" In the case that a node cannot be listened to by a prophet node, advertise-peer-urls should be manually set. advertise-peer-urls = \"http://${HOST}:50000\" max-replicas max-replicas is the max number of replica in a prophet group. It should be 3. max-replicas = 3","title":"Distributed Settings"},{"location":"MatrixOne/Reference/System-Parameters/distributed-settings/#configuration-settings","text":"To configurate a distributed setting, following parameters need to be modified in the default Configuration file 'system_vars_config.toml'. nodeID nodeID is the Node ID of the cube. In a cluster, each node should have a different nodeID . addr-raft and addr-advertise-raft addr-raft is the address for raft-group rpc communication. It is the 10000 port of the node. addr-raft = \"localhost:10000\" Only docker deployment need adjust addr-advertise-raft For docker deployment, the ip is 0.0.0.0 addr-raft = \"0.0.0.0:10000\" In the case that some clients cannot access the raft-group, addr-advertise-raft must be manually set. addr-advertise-raft = \"${HOST}:10000\" addr-client and addr-advertise-client addr-client is the address for cube service. It is the 20000 port of the node. addr-client = \"localhost:20000\" Only docker deployment need adjust addr-advertise-client For docker deployment, the ip is 0.0.0.0 addr-client = \"0.0.0.0:20000\" In the case that a client cannot access Cube through the default client URLs listened to by Cube, addr-advertise-client must be manually set. addr-advertise-client = \"${HOST}:20000\" dir-data dir-data is the directory for cube data. In a cluster, each node should have a different dir-data . store-heartbeat-duration store-heartbeat-duration is the period for this node to report information to scheduler. It should be less than 10s. prophet name name in Prophet Configs is the name of the node. In a cluster, each node should have a different prophet name. name = \"node0\" rpc-addr and rpc-advertise-addr rpc-addr is the address for other clients to access prophet. It is the 30000 port of the node. rpc-addr = \"localhost:30000\" Only docker deployment need adjust rpc-advertise-addr For docker deployment, the ip is 0.0.0.0 rpc-addr = \"0.0.0.0:30000\" In the case that a client cannot access prophet, rpc-advertise-addr must be manually set. rpc-advertise-addr = \"${HOST}:30000\" prophet-node prophet-node is whether the node is a pure prophet node. For the three prophet nodes, prophet-node is true . prophet-node = true For pure prophet nodes, prophet-node is false prophet-node = false external-etcd For the three prophet nodes, external-etcd is empty. external-etcd = [\"\", \"\", \"\"] For pure storage nodes, external-etcd is the list of the client-urls of the three prophet nodes, i.e. the 40000 port of the prophet nodes. external-etcd = [\"http://ip_of_prophet_node1:40000\", \"http://ip_of_prophet_node2:40000\", \"http://ip_of_prophet_node3:40000\"] join join is for the second and third prophet nodes to join the raft group. For the first prophet node, join is a empty string. join = \"\" For the second and third prophet node, join is the peer-urls of the first prophet node. join = \"http://ip_of_the_first_prophet_node:40000\" For pure storage nodes, there's no need to adjust join . client-urls and advertise-client-urls client-urls is exposed to other nodes in the cluster. It is 40000 port of the node client-urls = \"http://localhost:40000\" Only docker deployment need adjust advertise-client-urls For docker deployment, the ip is 0.0.0.0 client-urls = \"http://0.0.0.0:40000\" In the case that some clients ccannot access prophet through the default client URLs listened to by prophet, advertise-client-urls must be manually set. advertise-client-urls = \"http://${HOST}:40000 peer-urls and advertise-peer-urls peer-urls is the list of peer URLs to be listened to by a prophet node. It is the 40000 port of the node. peer-urls = \"http://localhost:50000\" Only docker deployment need adjust advertise-peer-urls For docker deployment, the ip is 0.0.0.0 peer-urls = \"http://0.0.0.0:50000\" In the case that a node cannot be listened to by a prophet node, advertise-peer-urls should be manually set. advertise-peer-urls = \"http://${HOST}:50000\" max-replicas max-replicas is the max number of replica in a prophet group. It should be 3. max-replicas = 3","title":"Configuration Settings"},{"location":"MatrixOne/Release-Notes/release-timeline/","text":"MatrixOne Release Timeline This document shows all the released MatrixOne versions in reverse chronological order. Version Release Date v0.4.0 2022/5/5 v0.3.0 2022/3/10 v0.2.0 2022/1/6 v0.1.0 2021/10/24","title":"**MatrixOne Release Timeline**"},{"location":"MatrixOne/Release-Notes/release-timeline/#matrixone-release-timeline","text":"This document shows all the released MatrixOne versions in reverse chronological order. Version Release Date v0.4.0 2022/5/5 v0.3.0 2022/3/10 v0.2.0 2022/1/6 v0.1.0 2021/10/24","title":"MatrixOne Release Timeline"},{"location":"MatrixOne/Release-Notes/v0.1.0/","text":"MatrixOne v0.1.0 Release Notes We are excited to announce the first release of MatrixOne 0.1.0 on 2021/10/24. Cheers! Docker docker pull matrixorigin/matrixone:0.1.0 Features SQL Following SQL statements are supported in this release. DDL CREATE / DROP DATABASE CREATE / DROP TABLE DML INSERT LOAD DATA SELECT WHERE GROUP BY ORDER BY LIMIT, OFFSET SHOW DATABASES TABLES USE Data Types TINYINT / SMALLINT / INT / BIGINT, SIGNED / UNSIGNED FLOAT / DOUBLE CHAR / VARCHAR Operators <, >=, <, <=, <>, !=, = BETWEEN \u2026 AND \u2026, NOT BETWEEN \u2026 AND \u2026 AND, &&, OR, || +, -, *, /, %, MOD, DIV, NEG CAST Aggregation Functions COUNT SUM AVG MAX MIN Database Engine MySQL dialect is supported. Build-in Append only columnar engine(AOE) has been supported as the first fusion database engine. Real-time analytical queries are supported. Vectorized query execution engine, based on MPP solution, is introduced. Part of the expression execution has been vectorized through SIMD instructions. Distributed AOE with strong consistency guaranteed by RAFT has been supported. The performance of replicated state machine has been greatly improved through the unique design of reusing RAFT log as well as Write-Ahead log without any redundancy. Contributors This release includes 453 commits by 16 authors. Special thanks to the first author: Yan Wenze (@nnsgmsone) Chen Mingsong\uff08@m-schen\uff09 Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Li Yang (@lignay) Lin Junhong (@iamlinjunhong) lni (@lni) Long Ran (@aunjgr) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Shen JiangWei(@LeftHandCold) Wei Ziran (@w-zr) Xiong Jingjuan (@anitajjx) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"v0.1.0"},{"location":"MatrixOne/Release-Notes/v0.1.0/#matrixone-v010-release-notes","text":"We are excited to announce the first release of MatrixOne 0.1.0 on 2021/10/24. Cheers!","title":"MatrixOne v0.1.0 Release Notes"},{"location":"MatrixOne/Release-Notes/v0.1.0/#docker","text":"docker pull matrixorigin/matrixone:0.1.0","title":"Docker"},{"location":"MatrixOne/Release-Notes/v0.1.0/#features","text":"","title":"Features"},{"location":"MatrixOne/Release-Notes/v0.1.0/#sql","text":"Following SQL statements are supported in this release.","title":"SQL"},{"location":"MatrixOne/Release-Notes/v0.1.0/#ddl","text":"CREATE / DROP DATABASE CREATE / DROP TABLE","title":"DDL"},{"location":"MatrixOne/Release-Notes/v0.1.0/#dml","text":"INSERT LOAD DATA SELECT WHERE GROUP BY ORDER BY LIMIT, OFFSET SHOW DATABASES TABLES USE","title":"DML"},{"location":"MatrixOne/Release-Notes/v0.1.0/#data-types","text":"TINYINT / SMALLINT / INT / BIGINT, SIGNED / UNSIGNED FLOAT / DOUBLE CHAR / VARCHAR","title":"Data Types"},{"location":"MatrixOne/Release-Notes/v0.1.0/#operators","text":"<, >=, <, <=, <>, !=, = BETWEEN \u2026 AND \u2026, NOT BETWEEN \u2026 AND \u2026 AND, &&, OR, || +, -, *, /, %, MOD, DIV, NEG CAST","title":"Operators"},{"location":"MatrixOne/Release-Notes/v0.1.0/#aggregation-functions","text":"COUNT SUM AVG MAX MIN","title":"Aggregation Functions"},{"location":"MatrixOne/Release-Notes/v0.1.0/#database-engine","text":"MySQL dialect is supported. Build-in Append only columnar engine(AOE) has been supported as the first fusion database engine. Real-time analytical queries are supported. Vectorized query execution engine, based on MPP solution, is introduced. Part of the expression execution has been vectorized through SIMD instructions. Distributed AOE with strong consistency guaranteed by RAFT has been supported. The performance of replicated state machine has been greatly improved through the unique design of reusing RAFT log as well as Write-Ahead log without any redundancy.","title":"Database Engine"},{"location":"MatrixOne/Release-Notes/v0.1.0/#contributors","text":"This release includes 453 commits by 16 authors. Special thanks to the first author: Yan Wenze (@nnsgmsone) Chen Mingsong\uff08@m-schen\uff09 Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Li Yang (@lignay) Lin Junhong (@iamlinjunhong) lni (@lni) Long Ran (@aunjgr) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Shen JiangWei(@LeftHandCold) Wei Ziran (@w-zr) Xiong Jingjuan (@anitajjx) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"Contributors"},{"location":"MatrixOne/Release-Notes/v0.2.0/","text":"MatrixOne v0.2.0 Release Notes We are excited to announce MatrixOne 0.2.0 release. Cheers! Docker docker pull matrixorigin/matrixone:0.2.0 Features Support automatic rebalancing for the built-in AOE columnar storage engine. Introduce new SQL parser. Introduce factorized SQL execution engine which is the fastest MPP in Golang. Support CREATE / DROP INDEX. Support PRIMARY KEY in CREATE TABLE. Support more data types for SQL binary operators. Support equi join with group by or aggregation statements. Support new types of DATE and DATETIME. Database Engine For continuous table creation actions in a script, the parameter of pre-allocated-group-num should be set to a bigger value such in cluster scenarios. Otherwise, \"no available raft group\" may be notified during tables creation sequence. Contributors This release includes 243 commits by 21 authors. BingLin Chang (@decster) Chen Mingsong\uff08@m-schen\uff09 Nan Deng (@dengn) Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Li Yang (@lignay) Lin Junhong (@iamlinjunhong) lni (@lni) Long Ran (@aunjgr) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Shen JiangWei(@LeftHandCold) Jian Wang(@jianwan0214) broccoliSpicy(@broccoliSpicy) Ryan Wang(@wanglei4687) Xiong Jingjuan (@anitajjx) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Yuesheng Li(@reusee) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"v0.2.0"},{"location":"MatrixOne/Release-Notes/v0.2.0/#matrixone-v020-release-notes","text":"We are excited to announce MatrixOne 0.2.0 release. Cheers!","title":"MatrixOne v0.2.0 Release Notes"},{"location":"MatrixOne/Release-Notes/v0.2.0/#docker","text":"docker pull matrixorigin/matrixone:0.2.0","title":"Docker"},{"location":"MatrixOne/Release-Notes/v0.2.0/#features","text":"Support automatic rebalancing for the built-in AOE columnar storage engine. Introduce new SQL parser. Introduce factorized SQL execution engine which is the fastest MPP in Golang. Support CREATE / DROP INDEX. Support PRIMARY KEY in CREATE TABLE. Support more data types for SQL binary operators. Support equi join with group by or aggregation statements. Support new types of DATE and DATETIME.","title":"Features"},{"location":"MatrixOne/Release-Notes/v0.2.0/#database-engine","text":"For continuous table creation actions in a script, the parameter of pre-allocated-group-num should be set to a bigger value such in cluster scenarios. Otherwise, \"no available raft group\" may be notified during tables creation sequence.","title":"Database Engine"},{"location":"MatrixOne/Release-Notes/v0.2.0/#contributors","text":"This release includes 243 commits by 21 authors. BingLin Chang (@decster) Chen Mingsong\uff08@m-schen\uff09 Nan Deng (@dengn) Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Li Yang (@lignay) Lin Junhong (@iamlinjunhong) lni (@lni) Long Ran (@aunjgr) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Shen JiangWei(@LeftHandCold) Jian Wang(@jianwan0214) broccoliSpicy(@broccoliSpicy) Ryan Wang(@wanglei4687) Xiong Jingjuan (@anitajjx) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Yuesheng Li(@reusee) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"Contributors"},{"location":"MatrixOne/Release-Notes/v0.3.0/","text":"MatrixOne v0.3.0 Release Notes We are excited to announce MatrixOne 0.3.0 release. Cheers! Docker docker pull matrixorigin/matrixone:0.3.0 Features Exports data into CSV file. Introduces parallel execution and improve performance for projection query. Introduces IN operator and allows you to specify multiple values in a WHERE clause. Support NULLABLE column in group by expression. Introduces new functions: round and floor. Introduces a Chaos Testing framework for distributed system. Known issues For continuous table creation actions in a script, the parameter of pre-allocated-group-num should be set to a bigger value such in cluster scenarios. Otherwise, \"no available raft group\" may be notified during tables creation sequence. Contributors This release includes 157 commits by 21 authors. broccoliSpicy(@broccoliSpicy) Chen Mingsong(@m-schen) hanfang (@aptend) O2 (@ikenchina) Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Lin Junhong (@iamlinjunhong) Long Ran (@aunjgr) Nan Deng (@dengn) Otter(@WenhaoKong2001) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Sundy Li(@sundy-li) Shen JiangWei(@LeftHandCold) Jian Wang(@jianwan0214) Wan Hanbo(@wanhanbo ) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Yuesheng Li(@reusee) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng) New Contributors @wanhanbo made their first contribution in https://github.com/matrixorigin/matrixone/pull/1600 @ikenchina made their first contribution in https://github.com/matrixorigin/matrixone/pull/1685 @sundy-li made their first contribution in https://github.com/matrixorigin/matrixone/pull/1704 @WenhaoKong2001 made their first contribution in https://github.com/matrixorigin/matrixone/pull/1838 We appreciate your contribution! Welcome to MatrixOne community. Full Changelog https://github.com/matrixorigin/matrixone/compare/v0.2.0...v0.3.0","title":"v0.3.0"},{"location":"MatrixOne/Release-Notes/v0.3.0/#matrixone-v030-release-notes","text":"We are excited to announce MatrixOne 0.3.0 release. Cheers!","title":"MatrixOne v0.3.0 Release Notes"},{"location":"MatrixOne/Release-Notes/v0.3.0/#docker","text":"docker pull matrixorigin/matrixone:0.3.0","title":"Docker"},{"location":"MatrixOne/Release-Notes/v0.3.0/#features","text":"Exports data into CSV file. Introduces parallel execution and improve performance for projection query. Introduces IN operator and allows you to specify multiple values in a WHERE clause. Support NULLABLE column in group by expression. Introduces new functions: round and floor. Introduces a Chaos Testing framework for distributed system.","title":"Features"},{"location":"MatrixOne/Release-Notes/v0.3.0/#known-issues","text":"For continuous table creation actions in a script, the parameter of pre-allocated-group-num should be set to a bigger value such in cluster scenarios. Otherwise, \"no available raft group\" may be notified during tables creation sequence.","title":"Known issues"},{"location":"MatrixOne/Release-Notes/v0.3.0/#contributors","text":"This release includes 157 commits by 21 authors. broccoliSpicy(@broccoliSpicy) Chen Mingsong(@m-schen) hanfang (@aptend) O2 (@ikenchina) Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Lin Junhong (@iamlinjunhong) Long Ran (@aunjgr) Nan Deng (@dengn) Otter(@WenhaoKong2001) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Sundy Li(@sundy-li) Shen JiangWei(@LeftHandCold) Jian Wang(@jianwan0214) Wan Hanbo(@wanhanbo ) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Yuesheng Li(@reusee) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"Contributors"},{"location":"MatrixOne/Release-Notes/v0.3.0/#new-contributors","text":"@wanhanbo made their first contribution in https://github.com/matrixorigin/matrixone/pull/1600 @ikenchina made their first contribution in https://github.com/matrixorigin/matrixone/pull/1685 @sundy-li made their first contribution in https://github.com/matrixorigin/matrixone/pull/1704 @WenhaoKong2001 made their first contribution in https://github.com/matrixorigin/matrixone/pull/1838 We appreciate your contribution! Welcome to MatrixOne community.","title":"New Contributors"},{"location":"MatrixOne/Release-Notes/v0.3.0/#full-changelog","text":"https://github.com/matrixorigin/matrixone/compare/v0.2.0...v0.3.0","title":"Full Changelog"},{"location":"MatrixOne/Release-Notes/v0.4.0/","text":"MatrixOne v0.4.0 Release Notes We are excited to announce MatrixOne 0.4.0 release. Cheers! Docker docker pull matrixorigin/matrixone:0.4.0 Features Support inner join with equality operator. Support subquery within from clause. Support decimal data type. Support following builtin functions: Mathematical: Abs, Log, Ln, Ceil, Exp, Power, Pi, Sin, Sinh, Cos, ACos, Tan, ATan, Cot Datetime: Month, Weekday, Date, DayOfYear String: Space, Reverse, Substring, Ltrim, Rtrim, StartsWith, EndsWith, Lpad, Rpad, Empty, LengthUTF8 Support following aggregate functions: Bit_and, Bit_or, Bit_xor, Stddev_pop, Var Known issues For continuous table creation actions in a script, the parameter of pre-allocated-group-num should be set to a bigger value such in cluster scenarios. Otherwise, \"no available raft group\" may be notified during tables creation sequence. Contributors This release includes 253 commits by 50 authors. New Contributors @BePPPower @JackTan25 @Charlie17Li @domingozhang @Fungx @JasonPeng1310 @jiajunhuang @NTH19 @noneback @RinChanNOWWW @chaixuqing @Y7n05h @yuxubinchen @adlternative @ajian2002 @bxiiiiii @coderzc @e11jah @fengttt @florashi181 @hiyoyolumi @jinfuchiang @ouyuanning @qingxinhome @supermario1990 @whileskies @xiw5 @yclchuxue @ZtXavier We appreciate your contribution! Welcome to MatrixOne community. Full Changelog https://github.com/matrixorigin/matrixone/compare/v0.3.0...v0.4.0","title":"v0.4.0"},{"location":"MatrixOne/Release-Notes/v0.4.0/#matrixone-v040-release-notes","text":"We are excited to announce MatrixOne 0.4.0 release. Cheers!","title":"MatrixOne v0.4.0 Release Notes"},{"location":"MatrixOne/Release-Notes/v0.4.0/#docker","text":"docker pull matrixorigin/matrixone:0.4.0","title":"Docker"},{"location":"MatrixOne/Release-Notes/v0.4.0/#features","text":"Support inner join with equality operator. Support subquery within from clause. Support decimal data type. Support following builtin functions: Mathematical: Abs, Log, Ln, Ceil, Exp, Power, Pi, Sin, Sinh, Cos, ACos, Tan, ATan, Cot Datetime: Month, Weekday, Date, DayOfYear String: Space, Reverse, Substring, Ltrim, Rtrim, StartsWith, EndsWith, Lpad, Rpad, Empty, LengthUTF8 Support following aggregate functions: Bit_and, Bit_or, Bit_xor, Stddev_pop, Var","title":"Features"},{"location":"MatrixOne/Release-Notes/v0.4.0/#known-issues","text":"For continuous table creation actions in a script, the parameter of pre-allocated-group-num should be set to a bigger value such in cluster scenarios. Otherwise, \"no available raft group\" may be notified during tables creation sequence.","title":"Known issues"},{"location":"MatrixOne/Release-Notes/v0.4.0/#contributors","text":"This release includes 253 commits by 50 authors.","title":"Contributors"},{"location":"MatrixOne/Release-Notes/v0.4.0/#new-contributors","text":"@BePPPower @JackTan25 @Charlie17Li @domingozhang @Fungx @JasonPeng1310 @jiajunhuang @NTH19 @noneback @RinChanNOWWW @chaixuqing @Y7n05h @yuxubinchen @adlternative @ajian2002 @bxiiiiii @coderzc @e11jah @fengttt @florashi181 @hiyoyolumi @jinfuchiang @ouyuanning @qingxinhome @supermario1990 @whileskies @xiw5 @yclchuxue @ZtXavier We appreciate your contribution! Welcome to MatrixOne community.","title":"New Contributors"},{"location":"MatrixOne/Release-Notes/v0.4.0/#full-changelog","text":"https://github.com/matrixorigin/matrixone/compare/v0.3.0...v0.4.0","title":"Full Changelog"}]}