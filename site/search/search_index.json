{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MatrixOne Documentation Welcome to MatrixOne documentation! MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine, across multiple datacenters, clouds, edges and other heterogenous infrastructures. If you find documentation issues, feel free to create an Issue to let us know or directly create a Pull Request to help fix or update it. Recommended articles Overview Get Started Reference MatrixOne Introduction Install MatrixOne SQL Reference MatrixOne Architecture Connect to MatrixOne Server v0.2.0 Release Notes MatrixCube Introduction SSB Test with MatrixOne","title":"Home"},{"location":"#matrixone-documentation","text":"Welcome to MatrixOne documentation! MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine, across multiple datacenters, clouds, edges and other heterogenous infrastructures. If you find documentation issues, feel free to create an Issue to let us know or directly create a Pull Request to help fix or update it.","title":"MatrixOne Documentation"},{"location":"#recommended-articles","text":"Overview Get Started Reference MatrixOne Introduction Install MatrixOne SQL Reference MatrixOne Architecture Connect to MatrixOne Server v0.2.0 Release Notes MatrixCube Introduction SSB Test with MatrixOne","title":"Recommended articles"},{"location":"MatrixOne/documentation_contribution_guide/","text":"How MatrixOne documentation project is managed? The MatrixOne documentation is managed in 3 repos: The main project framework and CI settings are in the matrixorigin.io repo. The markdown contents are in the docs/en/MatrixOne folder of matrixone repo. The images and unstructured data are located in the artwork repo. The matrixorigin.io repo contains a submodule which links to matrixone repo contents. The images are referred as webimage links from artwork repo. The matrixorigin.io has implemented a CI project, which will be triggered by a new code merge. This CI workflow publishs the documentation to https://docs.matrixorigin.io/. The documentation project is based on the mkdocs-material . You can find the corresponding syntax and commands with this project. How MatrixOne documentation content is organized? The MatrixOne documentation content is planned with 6 main modules. Overview: MatrixOne's introduction, features, architecture, tech design etc. Get Started: How to quickly deploy and run a MatrixOne in a standalone or a distributed environment. Develop: How to develop some applications based on MatrixOne using different programming language. Troubleshoot: Introduce common errors and debugging tools. Reference: SQL reference, Configuration parameters, Error Codes. FAQs: Product, Technical Design,SQL, Deployment FAQs. How to contribute to documentation project? Fork matrixorigin.io and matrixone repos. Clone the matrixorigin.io repo, using --repository to retrieve the submodule of matrixone repo. $ git clone --recursive git@github.com:yourusername/matrixorigin.io.git As the local repo has the full documentation project code, you can run mkdocs serve under matrixorigin.io folder, and check http://localhost:8000 to check if this project runs well. $ mkdocs serve Make your modification. If the modification is about the project settings, updating sitemap with new pages, or updating the CI workflow code. You can always check http://localhost:8000 to see if your modification is effective. If your modification is about the markdown contents, after you update the docs submodule of matrixorigin.io , the same modifcation should be applied to the matrixone repo. Push your git commits to your Github repos and make PR to matrixorigin.io and matrixone repos. Once your code for both repos is merged, the CI workflow starts running until the documentation website being updated. What we are expecting? Anyone using MatrixOne or interested in MatrixOne is welcome to make contributions for the documentation. You can report confusing concepts, wrong descriptions or better organization format. For the 0.2.0 version, our SQLs and configuration settings are not fully tested, if you find contraints or errors, you are welcome to make your modifiction. The FAQs part is a onging project too, the ones who are more familiar with the project can contribute better answers.","title":"Documentation Contribution Guide"},{"location":"MatrixOne/documentation_contribution_guide/#how-matrixone-documentation-project-is-managed","text":"The MatrixOne documentation is managed in 3 repos: The main project framework and CI settings are in the matrixorigin.io repo. The markdown contents are in the docs/en/MatrixOne folder of matrixone repo. The images and unstructured data are located in the artwork repo. The matrixorigin.io repo contains a submodule which links to matrixone repo contents. The images are referred as webimage links from artwork repo. The matrixorigin.io has implemented a CI project, which will be triggered by a new code merge. This CI workflow publishs the documentation to https://docs.matrixorigin.io/. The documentation project is based on the mkdocs-material . You can find the corresponding syntax and commands with this project.","title":"How MatrixOne documentation project is managed?"},{"location":"MatrixOne/documentation_contribution_guide/#how-matrixone-documentation-content-is-organized","text":"The MatrixOne documentation content is planned with 6 main modules. Overview: MatrixOne's introduction, features, architecture, tech design etc. Get Started: How to quickly deploy and run a MatrixOne in a standalone or a distributed environment. Develop: How to develop some applications based on MatrixOne using different programming language. Troubleshoot: Introduce common errors and debugging tools. Reference: SQL reference, Configuration parameters, Error Codes. FAQs: Product, Technical Design,SQL, Deployment FAQs.","title":"How MatrixOne documentation content is organized?"},{"location":"MatrixOne/documentation_contribution_guide/#how-to-contribute-to-documentation-project","text":"Fork matrixorigin.io and matrixone repos. Clone the matrixorigin.io repo, using --repository to retrieve the submodule of matrixone repo. $ git clone --recursive git@github.com:yourusername/matrixorigin.io.git As the local repo has the full documentation project code, you can run mkdocs serve under matrixorigin.io folder, and check http://localhost:8000 to check if this project runs well. $ mkdocs serve Make your modification. If the modification is about the project settings, updating sitemap with new pages, or updating the CI workflow code. You can always check http://localhost:8000 to see if your modification is effective. If your modification is about the markdown contents, after you update the docs submodule of matrixorigin.io , the same modifcation should be applied to the matrixone repo. Push your git commits to your Github repos and make PR to matrixorigin.io and matrixone repos. Once your code for both repos is merged, the CI workflow starts running until the documentation website being updated.","title":"How to contribute to documentation project?"},{"location":"MatrixOne/documentation_contribution_guide/#what-we-are-expecting","text":"Anyone using MatrixOne or interested in MatrixOne is welcome to make contributions for the documentation. You can report confusing concepts, wrong descriptions or better organization format. For the 0.2.0 version, our SQLs and configuration settings are not fully tested, if you find contraints or errors, you are welcome to make your modifiction. The FAQs part is a onging project too, the ones who are more familiar with the project can contribute better answers.","title":"What we are expecting?"},{"location":"MatrixOne/Develop/design-a-database/","text":"Design A Database","title":"Design A Database"},{"location":"MatrixOne/Develop/design-a-database/#design-a-database","text":"","title":"Design A Database"},{"location":"MatrixOne/FAQs/general-faqs/","text":"General FAQs","title":"General FAQs"},{"location":"MatrixOne/FAQs/general-faqs/#general-faqs","text":"","title":"General FAQs"},{"location":"MatrixOne/Get-Started/Playground/","text":"Playground MatrixOne Playground allow you to try SQL statements and explore features of MatrixOne instantly from your web browser with interactive tutorials. If you have some questions about SQL, you can also see SQL Reference . For tutorials about SSB test, you can see Tutorial . Limitations You can only operate in read-only mode in MatixOrigin Playground\uff0cso DDL commands and part of DML commands which may change the data are not available. The detail limitations are shown below: DDL commands are not available: create/drop table , truncate , update , set , use Part of DML commands are not available\uff1a insert , replace , delete , select into commit is not available call is not available max_result_rows =2000 Examples Click here to turn to Playground In Playground, You can follow different tutorials and pick one in the list box, and now the supported tutorials are shown below: Star Schema Benchmark\uff08SSB\uff09 Test We will use SSB as an example to show you the overall operation process of Playground . Test Preperations This tutorial walks you through the most popular Star Schema Benchmark\uff08SSB\uff09 Test SQL statements with MatrixOne. To better experience MatrixOne features and performance, test queries in this tutorial will run without filters. Before you started, the test datasets have been pre-loaded in database ssb . To list available tables in the database you can query : SHOW TABLES\uff1b Tips You can click on the command to copy and Run it in the terminal on the right. The query results are displayed in the lower right. Then you can run the queries on SSB datasets, click Continue . Run Query Command Now, You can query the table with SQL commands we provide. For example: Run Q1.1 query select sum(lo_revenue) as revenue from lineorder join dates on lo_orderdate = d_datekey\uff1b And you can use join in queries: Run Q1.2 query select sum(lo_revenue) as revenue from lineorder join dates on lo_orderdate = d_datekey\uff1b Additionally, group by and order by can be used: Run Q2.1 query select sum(lo_revenue) as lo_revenue, d_year, p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey group by d_year, p_brand order by d_year, p_brand; More query commands are provided in Playground , you can test on your own. Learn More This page describes the features, limitations, and examples of Playground. For information on other options that are available when trying out MatrixOne, see the following: Install MatrixOne What\u2018s New","title":"Playground"},{"location":"MatrixOne/Get-Started/Playground/#playground","text":"MatrixOne Playground allow you to try SQL statements and explore features of MatrixOne instantly from your web browser with interactive tutorials. If you have some questions about SQL, you can also see SQL Reference . For tutorials about SSB test, you can see Tutorial .","title":"Playground"},{"location":"MatrixOne/Get-Started/Playground/#limitations","text":"You can only operate in read-only mode in MatixOrigin Playground\uff0cso DDL commands and part of DML commands which may change the data are not available. The detail limitations are shown below: DDL commands are not available: create/drop table , truncate , update , set , use Part of DML commands are not available\uff1a insert , replace , delete , select into commit is not available call is not available max_result_rows =2000","title":"Limitations"},{"location":"MatrixOne/Get-Started/Playground/#examples","text":"Click here to turn to Playground In Playground, You can follow different tutorials and pick one in the list box, and now the supported tutorials are shown below: Star Schema Benchmark\uff08SSB\uff09 Test We will use SSB as an example to show you the overall operation process of Playground .","title":"Examples"},{"location":"MatrixOne/Get-Started/Playground/#test-preperations","text":"This tutorial walks you through the most popular Star Schema Benchmark\uff08SSB\uff09 Test SQL statements with MatrixOne. To better experience MatrixOne features and performance, test queries in this tutorial will run without filters. Before you started, the test datasets have been pre-loaded in database ssb . To list available tables in the database you can query : SHOW TABLES\uff1b Tips You can click on the command to copy and Run it in the terminal on the right. The query results are displayed in the lower right. Then you can run the queries on SSB datasets, click Continue .","title":"Test Preperations"},{"location":"MatrixOne/Get-Started/Playground/#run-query-command","text":"Now, You can query the table with SQL commands we provide. For example: Run Q1.1 query select sum(lo_revenue) as revenue from lineorder join dates on lo_orderdate = d_datekey\uff1b And you can use join in queries: Run Q1.2 query select sum(lo_revenue) as revenue from lineorder join dates on lo_orderdate = d_datekey\uff1b Additionally, group by and order by can be used: Run Q2.1 query select sum(lo_revenue) as lo_revenue, d_year, p_brand from lineorder join dates on lo_orderdate = d_datekey join part on lo_partkey = p_partkey join supplier on lo_suppkey = s_suppkey group by d_year, p_brand order by d_year, p_brand; More query commands are provided in Playground , you can test on your own.","title":"Run Query Command"},{"location":"MatrixOne/Get-Started/Playground/#learn-more","text":"This page describes the features, limitations, and examples of Playground. For information on other options that are available when trying out MatrixOne, see the following: Install MatrixOne What\u2018s New","title":"Learn More"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/","text":"Connect to MatrixOne Server Before you begin Make sure you have already installed MatrixOne . 1. Install MySQL client MatrixOne supports the MySQL wire protocol, so you can use MySQL client drivers to connect from various languages. Currently, MatrixOne is only compatible with Oracle MySQL client. This means that some features might not work with MariaDB client. 2. Connect to MatrixOne server You can use the MySQL command-line client to connect to MatrixOne server: $ mysql -h IP -P PORT -uUsername -p The connection string is the same format as MySQL accepts. You need to provide a user name and a password. Use the built-in test account for example: user: dump password: 111 $ mysql -h 127.0.0.1 -P 6001 -udump -p Enter password: Currently, MatrixOne only supports the TCP listener.","title":"Connect to MatrixOne Server"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/#connect-to-matrixone-server","text":"","title":"Connect to MatrixOne Server"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/#before-you-begin","text":"Make sure you have already installed MatrixOne .","title":"Before you begin"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/#1-install-mysql-client","text":"MatrixOne supports the MySQL wire protocol, so you can use MySQL client drivers to connect from various languages. Currently, MatrixOne is only compatible with Oracle MySQL client. This means that some features might not work with MariaDB client.","title":"1. Install MySQL client"},{"location":"MatrixOne/Get-Started/connect-to-matrixone-server/#2-connect-to-matrixone-server","text":"You can use the MySQL command-line client to connect to MatrixOne server: $ mysql -h IP -P PORT -uUsername -p The connection string is the same format as MySQL accepts. You need to provide a user name and a password. Use the built-in test account for example: user: dump password: 111 $ mysql -h 127.0.0.1 -P 6001 -udump -p Enter password: Currently, MatrixOne only supports the TCP listener.","title":"2. Connect to MatrixOne server"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/","text":"Install distributed MatrixOne MatrixOne supports distributed deloyment. At least 3 nodes are required for the distributed setting. Two Types of Nodes There are two types of nodes in a MatrixOne cluster: prophet nodes and pure storage nodes. The first three nodes are prophet nodes. The others are pure storage nodes. For example, if there're three nodes in the cluster, all the nodes are prophet nodes. If there're four nodes in the cluster, three are prophet nodes, one is a pure storage node. Installation Each node must install a MatrixOne as standalone version. Installation steps are the same as the standalone . Generate Default Configuration Run following command in directory matrixone to generate default Configuration. $ make config The default Configuration file is system_vars_config.toml . Configuration Settings To configurate a distributed setting, following parameters need to be modified in the default Configuration file 'system_vars_config.toml'. nodeID nodeID is the Node ID of the cube. In a cluster, each node should have a different nodeID . addr-raft and addr-advertise-raft addr-raft is the address for raft-group rpc communication. It is the 10000 port of the node. addr-raft = \"localhost:10000\" Only docker deployment need adjust addr-advertise-raft For docker deployment, the ip is 0.0.0.0 addr-raft = \"0.0.0.0:10000\" In the case that some clients cannot access the raft-group, addr-advertise-raft must be manually set. addr-advertise-raft = \"${HOST}:10000\" addr-client and addr-advertise-client addr-client is the address for cube service. It is the 20000 port of the node. addr-client = \"localhost:20000\" Only docker deployment need adjust addr-advertise-client For docker deployment, the ip is 0.0.0.0 addr-client = \"0.0.0.0:20000\" In the case that a client cannot access Cube through the default client URLs listened to by Cube, addr-advertise-client must be manually set. addr-advertise-client = \"${HOST}:20000\" dir-data dir-data is the directory for cube data. In a cluster, each node should have a different dir-data . store-heartbeat-duration store-heartbeat-duration is the period for this node to report information to scheduler. It should be less than 10s. prophet name name in Prophet Configs is the name of the node. In a cluster, each node should have a different prophet name. name = \"node0\" rpc-addr and rpc-advertise-addr rpc-addr is the address for other clients to access prophet. It is the 30000 port of the node. rpc-addr = \"localhost:30000\" Only docker deployment need adjust rpc-advertise-addr For docker deployment, the ip is 0.0.0.0 rpc-addr = \"0.0.0.0:30000\" In the case that a client cannot access prophet, rpc-advertise-addr must be manually set. rpc-advertise-addr = \"${HOST}:30000\" storage-node storage-node is whether the node is a pure storage node. For the three prophet nodes, storage-node is true . storage-node = true For pure storage nodes, storage-node is false storage-node = false external-etcd For the three prophet nodes, external-etcd is empty. external-etcd = [\"\", \"\", \"\"] For pure storage nodes, external-etcd is the list of the client-urls of the three prophet nodes, i.e. the 40000 port of the prophet nodes. external-etcd = [\"http://ip_of_prophet_node1:40000\", \"http://ip_of_prophet_node2:40000\", \"http://ip_of_prophet_node3:40000\"] join join is for the second and third prophet nodes to join the raft group. For the first prophet node, join is a empty string. join = \"\" For the second and third prophet node, join is the peer-urls of the first prophet node. join = \"http://ip_of_the_first_prophet_node:40000\" For pure storage nodes, there's no need to adjust join . client-urls and advertise-client-urls client-urls is exposed to other nodes in the cluster. It is 40000 port of the node client-urls = \"http://localhost:40000\" Only docker deployment need adjust advertise-client-urls For docker deployment, the ip is 0.0.0.0 client-urls = \"http://0.0.0.0:40000\" In the case that some clients ccannot access prophet through the default client URLs listened to by prophet, advertise-client-urls must be manually set. advertise-client-urls = \"http://${HOST}:40000 peer-urls and advertise-peer-urls peer-urls is the list of peer URLs to be listened to by a prophet node. It is the 40000 port of the node. peer-urls = \"http://localhost:50000\" Only docker deployment need adjust advertise-peer-urls For docker deployment, the ip is 0.0.0.0 peer-urls = \"http://0.0.0.0:50000\" In the case that a node cannot be listened to by a prophet node, advertise-peer-urls should be manually set. advertise-peer-urls = \"http://${HOST}:50000\" max-replicas max-replicas is the max number of replica in a prophet group. It should be 3. max-replicas = 3","title":"Install and configure distributed MatrixOne"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#install-distributed-matrixone","text":"MatrixOne supports distributed deloyment. At least 3 nodes are required for the distributed setting.","title":"Install distributed MatrixOne"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#two-types-of-nodes","text":"There are two types of nodes in a MatrixOne cluster: prophet nodes and pure storage nodes. The first three nodes are prophet nodes. The others are pure storage nodes. For example, if there're three nodes in the cluster, all the nodes are prophet nodes. If there're four nodes in the cluster, three are prophet nodes, one is a pure storage node.","title":"Two Types of Nodes"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#installation","text":"Each node must install a MatrixOne as standalone version. Installation steps are the same as the standalone .","title":"Installation"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#generate-default-configuration","text":"Run following command in directory matrixone to generate default Configuration. $ make config The default Configuration file is system_vars_config.toml .","title":"Generate Default Configuration"},{"location":"MatrixOne/Get-Started/install-distributed-matrixone/#configuration-settings","text":"To configurate a distributed setting, following parameters need to be modified in the default Configuration file 'system_vars_config.toml'. nodeID nodeID is the Node ID of the cube. In a cluster, each node should have a different nodeID . addr-raft and addr-advertise-raft addr-raft is the address for raft-group rpc communication. It is the 10000 port of the node. addr-raft = \"localhost:10000\" Only docker deployment need adjust addr-advertise-raft For docker deployment, the ip is 0.0.0.0 addr-raft = \"0.0.0.0:10000\" In the case that some clients cannot access the raft-group, addr-advertise-raft must be manually set. addr-advertise-raft = \"${HOST}:10000\" addr-client and addr-advertise-client addr-client is the address for cube service. It is the 20000 port of the node. addr-client = \"localhost:20000\" Only docker deployment need adjust addr-advertise-client For docker deployment, the ip is 0.0.0.0 addr-client = \"0.0.0.0:20000\" In the case that a client cannot access Cube through the default client URLs listened to by Cube, addr-advertise-client must be manually set. addr-advertise-client = \"${HOST}:20000\" dir-data dir-data is the directory for cube data. In a cluster, each node should have a different dir-data . store-heartbeat-duration store-heartbeat-duration is the period for this node to report information to scheduler. It should be less than 10s. prophet name name in Prophet Configs is the name of the node. In a cluster, each node should have a different prophet name. name = \"node0\" rpc-addr and rpc-advertise-addr rpc-addr is the address for other clients to access prophet. It is the 30000 port of the node. rpc-addr = \"localhost:30000\" Only docker deployment need adjust rpc-advertise-addr For docker deployment, the ip is 0.0.0.0 rpc-addr = \"0.0.0.0:30000\" In the case that a client cannot access prophet, rpc-advertise-addr must be manually set. rpc-advertise-addr = \"${HOST}:30000\" storage-node storage-node is whether the node is a pure storage node. For the three prophet nodes, storage-node is true . storage-node = true For pure storage nodes, storage-node is false storage-node = false external-etcd For the three prophet nodes, external-etcd is empty. external-etcd = [\"\", \"\", \"\"] For pure storage nodes, external-etcd is the list of the client-urls of the three prophet nodes, i.e. the 40000 port of the prophet nodes. external-etcd = [\"http://ip_of_prophet_node1:40000\", \"http://ip_of_prophet_node2:40000\", \"http://ip_of_prophet_node3:40000\"] join join is for the second and third prophet nodes to join the raft group. For the first prophet node, join is a empty string. join = \"\" For the second and third prophet node, join is the peer-urls of the first prophet node. join = \"http://ip_of_the_first_prophet_node:40000\" For pure storage nodes, there's no need to adjust join . client-urls and advertise-client-urls client-urls is exposed to other nodes in the cluster. It is 40000 port of the node client-urls = \"http://localhost:40000\" Only docker deployment need adjust advertise-client-urls For docker deployment, the ip is 0.0.0.0 client-urls = \"http://0.0.0.0:40000\" In the case that some clients ccannot access prophet through the default client URLs listened to by prophet, advertise-client-urls must be manually set. advertise-client-urls = \"http://${HOST}:40000 peer-urls and advertise-peer-urls peer-urls is the list of peer URLs to be listened to by a prophet node. It is the 40000 port of the node. peer-urls = \"http://localhost:50000\" Only docker deployment need adjust advertise-peer-urls For docker deployment, the ip is 0.0.0.0 peer-urls = \"http://0.0.0.0:50000\" In the case that a node cannot be listened to by a prophet node, advertise-peer-urls should be manually set. advertise-peer-urls = \"http://${HOST}:50000\" max-replicas max-replicas is the max number of replica in a prophet group. It should be 3. max-replicas = 3","title":"Configuration Settings"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/","text":"Install standalone MatrixOne MatrixOne supports Linux and MacOS. You can install a standalone MatrixOne version either by building from source or using docker . Building from source 1. Install Go as necessary Go version 1.17+ is required. 2. Get the MatrixOne code $ git clone https://github.com/matrixorigin/matrixone.git $ cd matrixone 3. Run make You can run make debug , make clean , or anything else our Makefile offers. $ make config $ make build 4. Boot MatrixOne server $ ./mo-server system_vars_config.toml Using docker 1. Install Docker Please verify that Docker daemon is running in the background: $ docker --version 2. Create and run the container for the latest release of MatrixOne It will pull the image from Docker Hub if not exists. $ docker run -d -p 6001:6001 --name matrixone matrixorigin/matrixone:latest","title":"Install Standalone MatrixOne"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#install-standalone-matrixone","text":"MatrixOne supports Linux and MacOS. You can install a standalone MatrixOne version either by building from source or using docker .","title":"Install standalone MatrixOne"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#building-from-source","text":"","title":"Building from source"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#1-install-go-as-necessary","text":"Go version 1.17+ is required.","title":"1. Install Go as necessary"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#2-get-the-matrixone-code","text":"$ git clone https://github.com/matrixorigin/matrixone.git $ cd matrixone","title":"2. Get the MatrixOne code"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#3-run-make","text":"You can run make debug , make clean , or anything else our Makefile offers. $ make config $ make build","title":"3. Run make"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#4-boot-matrixone-server","text":"$ ./mo-server system_vars_config.toml","title":"4. Boot MatrixOne server"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#using-docker","text":"","title":"Using docker"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#1-install-docker","text":"Please verify that Docker daemon is running in the background: $ docker --version","title":"1. Install Docker"},{"location":"MatrixOne/Get-Started/install-standalone-matrixone/#2-create-and-run-the-container-for-the-latest-release-of-matrixone","text":"It will pull the image from Docker Hub if not exists. $ docker run -d -p 6001:6001 --name matrixone matrixorigin/matrixone:latest","title":"2. Create and run the container for the latest release of MatrixOne"},{"location":"MatrixOne/Get-Started/set-up-matrixone/","text":"Set Up MatrixOne Matrixone supports both single node and distributed deployment, for single node deployment, you can start your journey with MatrixOne out of box. For distributed deployment, change each node's config file(system_vars_config.toml) according to the following instructions. Deploy MatrixOne on a distributed bare-metal cluster 1. Requirements: at least three nodes 2. set up the prophet genesis node 2.1. make sure the nodeID is unique 2.2. change the addr-raft ip to the machine ip 2.3. change the addr-client ip to the machine ip 2.4. make sure the prophet name is different from the names of other two prophet node 2.5. change the rpc-addr ip to the machine ip 2.6. change the client-urls ip to the machine ip 2.7. change the peer-urls ip to the machine ip 2.8. make sure the dir-data is different from the other nodes in the cluster 3. set up the other two prophet nodes 3.1. apply the above 8 steps of prophet genesis node setting 3.2. change the prophet join address from empty string to the prophet genesis node's peer-urls 4. set up pure storage node 4.1. make sure the nodeID is unique 4.2. change storage-node to false 4.3. change the addr-raft ip to the machine ip 4.4. change the addr-client ip to the machine ip 4.5. In the external-etcd attribute, fill the three empty string with the three client-urls of the three prophet node 4.6. make sure the dir-data is different from the other nodes in the cluster Deploy MatrixOne on a docker cluster Start MatrixOne cluster on docker or kubernetes, please refer to this repo matrixorigin/matrixone-operator","title":"**Set Up MatrixOne**"},{"location":"MatrixOne/Get-Started/set-up-matrixone/#set-up-matrixone","text":"Matrixone supports both single node and distributed deployment, for single node deployment, you can start your journey with MatrixOne out of box. For distributed deployment, change each node's config file(system_vars_config.toml) according to the following instructions.","title":"Set Up MatrixOne"},{"location":"MatrixOne/Get-Started/set-up-matrixone/#deploy-matrixone-on-a-distributed-bare-metal-cluster","text":"1. Requirements: at least three nodes 2. set up the prophet genesis node 2.1. make sure the nodeID is unique 2.2. change the addr-raft ip to the machine ip 2.3. change the addr-client ip to the machine ip 2.4. make sure the prophet name is different from the names of other two prophet node 2.5. change the rpc-addr ip to the machine ip 2.6. change the client-urls ip to the machine ip 2.7. change the peer-urls ip to the machine ip 2.8. make sure the dir-data is different from the other nodes in the cluster 3. set up the other two prophet nodes 3.1. apply the above 8 steps of prophet genesis node setting 3.2. change the prophet join address from empty string to the prophet genesis node's peer-urls 4. set up pure storage node 4.1. make sure the nodeID is unique 4.2. change storage-node to false 4.3. change the addr-raft ip to the machine ip 4.4. change the addr-client ip to the machine ip 4.5. In the external-etcd attribute, fill the three empty string with the three client-urls of the three prophet node 4.6. make sure the dir-data is different from the other nodes in the cluster","title":"Deploy MatrixOne on a distributed bare-metal cluster"},{"location":"MatrixOne/Get-Started/set-up-matrixone/#deploy-matrixone-on-a-docker-cluster","text":"Start MatrixOne cluster on docker or kubernetes, please refer to this repo matrixorigin/matrixone-operator","title":"Deploy MatrixOne on a docker cluster"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/","text":"Complete a SSB Test with MatrixOne Star Schema Benchmark\uff08SSB\uff09Test is a popular scenario for OLAP database performance tests. By going through this tutorial, you\u2019ll learn how to complete a SSB Test with MatrixOne. In v0.1.0, only single table can work in MatrixOne. The following contents can be followed to data generation, data importing and querying. Before you begin Make sure you have already installed MatrixOne and connected to MatrixOne Server . 1. Compile dbgen $ git clone git@github.com:vadimtk/ssb-dbgen.git $ cd ssb-dbgen $ make 2. Generate data With -s 1 dbgen generates 6 million rows (670MB), while while -s 10 it generates 60 million rows (which takes some time) $ ./dbgen -s 1 -T c $ ./dbgen -s 1 -T l` $ ./dbgen -s 1 -T p $ ./dbgen -s 1 -T s $ ./dbgen -s 1 -T d 3. Create tables in MatrixOne create database if not exists ssb; use ssb drop table if exists lineorder; drop table if exists part; drop table if exists supplier; drop table if exists customer; drop table if exists dim_date; drop table if exists lineorder_flat; create table lineorder ( lo_orderkey bigint, lo_linenumber int, lo_custkey int, lo_partkey int, lo_suppkey int, lo_orderdate char(10), lo_orderpriority char (15), lo_shippriority tinyint, lo_quantity double, lo_extendedprice double, lo_ordtotalprice double, lo_discount double, lo_revenue double, lo_supplycost double, lo_tax double, lo_commitdate char(10), lo_shipmode char (10) ) ; create table part ( p_partkey int, p_name varchar (22), p_mfgr char (6), p_category char (7), p_brand char (9), p_color varchar (11), p_type varchar (25), p_size int, p_container char (10) ) ; create table supplier ( s_suppkey int, s_name char (25), s_address varchar (25), s_city char (10), s_nation char (15), s_region char (12), s_phone char (15) ) ; create table customer ( c_custkey int, c_name varchar (25), c_address varchar (25), c_city char (10), c_nation char (15), c_region char (12), c_phone char (15), c_mktsegment char (10) ) ; create table dim_date ( d_datekey int, d_date char (18), d_dayofweek char (9), d_month char (9), d_year int, d_yearmonthnum int, d_yearmonth char (7), d_daynuminweek int, d_daynuminmonth int, d_daynuminyear int, d_monthnuminyear int, d_weeknuminyear int, d_sellingseason varchar (12), d_lastdayinweekfl varchar (1), d_lastdayinmonthfl varchar (1), d_holidayfl varchar (1), d_weekdayfl varchar (1) ) ; CREATE TABLE lineorder_flat ( LO_ORDERKEY bigint, LO_LINENUMBER int, LO_CUSTKEY int, LO_PARTKEY int, LO_SUPPKEY int, LO_ORDERDATE int, LO_ORDERPRIORITY char(15), LO_SHIPPRIORITY tinyint, LO_QUANTITY double, LO_EXTENDEDPRICE double, LO_ORDTOTALPRICE double, LO_DISCOUNT double, LO_REVENUE double, LO_SUPPLYCOST double, LO_TAX double, LO_COMMITDATE int, LO_SHIPMODE char(10), C_NAME varchar(25), C_ADDRESS varchar(25), C_CITY char(10), C_NATION char(15), C_REGION char(12), C_PHONE char(15), C_MKTSEGMENT char(10), S_NAME char(25), S_ADDRESS varchar(25), S_CITY char(10), S_NATION char(15), S_REGION char(12), S_PHONE char(15), P_NAME varchar(22), P_MFGR char(6), P_CATEGORY char(7), P_BRAND char(9), P_COLOR varchar(11), P_TYPE varchar(25), P_SIZE int, P_CONTAINER char(10) ); 4. Load data into the created tables If you use dbgen to generate date for ssb, there is still an extra step to replace the \u2018,\u2019 in the end of every line. In the directory of ssb-dbgen, use the following command. $ sed -i 's/.$//' customer.tbl $ sed -i 's/.$//' date.tbl $ sed -i 's/.$//' supplier.tbl $ sed -i 's/.$//' lineorder.tbl $ sed -i 's/.$//' part.tbl Then modify the parameter of system_vars_config.toml to a larger one in matrixone directory, such as 10GB. And restart MatrixOne service. max-entry-bytes = \"10GB\" Load data into related tables with this command in MatrixOne. load data infile '/ssb-dbgen-path/supplier.tbl ' into table supplier FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/customer.tbl ' into table customer FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/date.tbl ' into table dim_date FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/supplier.tbl ' into table supplier FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/part.tbl ' into table part FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/lineorder.tbl ' into table lineorder FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; Then you can query data in MatrixOne with the created table. If you want to run a single table SSB query test, there is still one more data files needed for lineorder_flat. You can get the data files directly: https://pan.baidu.com/s/1dCpcKsygdVuHzd-H-RWHFA code: k1rs Load data into lineorder_flat. load data infile '/ssb-dbgen-path/lineorder_flat.tbl ' into table lineorder_flat FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; 5. Run SSB Queries # Q1.1 SELECT sum(LO_EXTENDEDPRICE * LO_DISCOUNT) AS revenue FROM lineorder_flat WHERE LO_ORDERDATE<=19930131 AND LO_ORDERDATE>=19930101 AND LO_DISCOUNT BETWEEN 1 AND 3 AND LO_QUANTITY < 25; # Q1.2 SELECT sum(LO_EXTENDEDPRICE * LO_DISCOUNT) AS revenue FROM lineorder_flat WHERE LO_ORDERDATE<=19920131 AND LO_ORDERDATE>=19920101 AND LO_DISCOUNT BETWEEN 4 AND 6 AND LO_QUANTITY BETWEEN 26 AND 35; # Q1.3 SELECT sum(LO_EXTENDEDPRICE * LO_DISCOUNT) AS revenue FROM lineorder_flat WHERE LO_ORDERDATE = 19920101 AND LO_DISCOUNT BETWEEN 5 AND 7 AND LO_QUANTITY BETWEEN 26 AND 35; # Q2.1 SELECT sum(LO_REVENUE), LO_ORDERDATE, P_BRAND FROM lineorder_flat WHERE P_CATEGORY = 'MFGR#11' AND S_REGION = 'AMERICA' GROUP BY LO_ORDERDATE, P_BRAND ORDER BY LO_ORDERDATE, P_BRAND; # Q2.2 SELECT sum(LO_REVENUE), LO_ORDERDATE, P_BRAND FROM lineorder_flat WHERE P_BRAND BETWEEN 'MFGR#2221' AND 'MFGR#2228' AND S_REGION = 'ASIA' GROUP BY LO_ORDERDATE, P_BRAND ORDER BY LO_ORDERDATE, P_BRAND; # Q2.3 SELECT sum(LO_REVENUE), LO_ORDERDATE, P_BRAND FROM lineorder_flat WHERE P_BRAND = 'MFGR#2239' AND S_REGION = 'EUROPE' GROUP BY LO_ORDERDATE, P_BRAND ORDER BY LO_ORDERDATE, P_BRAND; # Q3.1 SELECT C_NATION, S_NATION, LO_ORDERDATE, sum(LO_REVENUE) AS revenue FROM lineorder_flat WHERE C_REGION = 'ASIA' AND S_REGION = 'ASIA' AND LO_ORDERDATE >= 19920101 AND LO_ORDERDATE <= 19970101 GROUP BY C_NATION, S_NATION, LO_ORDERDATE ORDER BY LO_ORDERDATE asc, revenue desc; # Q3.2 SELECT C_CITY, S_CITY, LO_ORDERDATE, sum(LO_REVENUE) AS revenue FROM lineorder_flat WHERE C_NATION = 'CHINA' AND S_NATION = 'CHINA' AND LO_ORDERDATE >= 19920101 AND LO_ORDERDATE <= 19971231 GROUP BY C_CITY, S_CITY, LO_ORDERDATE ORDER BY LO_ORDERDATE asc, revenue desc; # Q3.3 SELECT C_CITY, S_CITY, LO_ORDERDATE, sum(LO_REVENUE) AS revenue FROM lineorder_flat WHERE (C_CITY = 'UNITED KI0' OR C_CITY = 'UNITED KI7') AND (S_CITY = 'UNITED KI0' OR S_CITY = 'UNITED KI7') AND LO_ORDERDATE >= 19920101 AND LO_ORDERDATE <= 19971231 GROUP BY C_CITY, S_CITY, LO_ORDERDATE ORDER BY LO_ORDERDATE asc, revenue desc; # Q3.4 SELECT C_CITY, S_CITY, LO_ORDERDATE, sum(LO_REVENUE) AS revenue FROM lineorder_flat WHERE (C_CITY = 'UNITED KI0' OR C_CITY = 'UNITED KI7') AND (S_CITY = 'MOZAMBIQU1' OR S_CITY = 'KENYA 4') AND LO_ORDERDATE >= 19971201 GROUP BY C_CITY, S_CITY, LO_ORDERDATE ORDER BY LO_ORDERDATE asc, revenue desc; # Q4.1 SELECT LO_ORDERDATE, C_NATION, sum(LO_REVENUE - LO_SUPPLYCOST) AS profit FROM lineorder_flat WHERE C_REGION = 'AMERICA' AND S_REGION = 'AMERICA' AND (P_MFGR = 'MFGR#1' OR P_MFGR = 'MFGR#2') GROUP BY LO_ORDERDATE, C_NATION ORDER BY LO_ORDERDATE, C_NATION; # Q4.2 SELECT LO_ORDERDATE, S_NATION, P_CATEGORY, sum(LO_REVENUE - LO_SUPPLYCOST) AS profit FROM lineorder_flat WHERE C_REGION = 'AMERICA' AND S_REGION = 'AMERICA' AND (LO_ORDERDATE>= 19970101 OR LO_ORDERDATE <= 19981231) AND (P_MFGR = 'MFGR#1' OR P_MFGR = 'MFGR#2') GROUP BY LO_ORDERDATE, S_NATION, P_CATEGORY ORDER BY LO_ORDERDATE, S_NATION, P_CATEGORY; # Q4.3 SELECT LO_ORDERDATE, S_CITY, P_BRAND, sum(LO_REVENUE - LO_SUPPLYCOST) AS profit FROM lineorder_flat WHERE S_NATION = 'UNITED STATES' AND (LO_ORDERDATE>= 19970101 OR LO_ORDERDATE <= 19981231) AND P_CATEGORY = 'MFGR#14' GROUP BY LO_ORDERDATE, S_CITY, P_BRAND ORDER BY LO_ORDERDATE, S_CITY, P_BRAND;","title":"SSB Test with MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#complete-a-ssb-test-with-matrixone","text":"Star Schema Benchmark\uff08SSB\uff09Test is a popular scenario for OLAP database performance tests. By going through this tutorial, you\u2019ll learn how to complete a SSB Test with MatrixOne. In v0.1.0, only single table can work in MatrixOne. The following contents can be followed to data generation, data importing and querying.","title":"Complete a SSB Test with MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#before-you-begin","text":"Make sure you have already installed MatrixOne and connected to MatrixOne Server .","title":"Before you begin"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#1-compile-dbgen","text":"$ git clone git@github.com:vadimtk/ssb-dbgen.git $ cd ssb-dbgen $ make","title":"1. Compile dbgen"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#2-generate-data","text":"With -s 1 dbgen generates 6 million rows (670MB), while while -s 10 it generates 60 million rows (which takes some time) $ ./dbgen -s 1 -T c $ ./dbgen -s 1 -T l` $ ./dbgen -s 1 -T p $ ./dbgen -s 1 -T s $ ./dbgen -s 1 -T d","title":"2. Generate data"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#3-create-tables-in-matrixone","text":"create database if not exists ssb; use ssb drop table if exists lineorder; drop table if exists part; drop table if exists supplier; drop table if exists customer; drop table if exists dim_date; drop table if exists lineorder_flat; create table lineorder ( lo_orderkey bigint, lo_linenumber int, lo_custkey int, lo_partkey int, lo_suppkey int, lo_orderdate char(10), lo_orderpriority char (15), lo_shippriority tinyint, lo_quantity double, lo_extendedprice double, lo_ordtotalprice double, lo_discount double, lo_revenue double, lo_supplycost double, lo_tax double, lo_commitdate char(10), lo_shipmode char (10) ) ; create table part ( p_partkey int, p_name varchar (22), p_mfgr char (6), p_category char (7), p_brand char (9), p_color varchar (11), p_type varchar (25), p_size int, p_container char (10) ) ; create table supplier ( s_suppkey int, s_name char (25), s_address varchar (25), s_city char (10), s_nation char (15), s_region char (12), s_phone char (15) ) ; create table customer ( c_custkey int, c_name varchar (25), c_address varchar (25), c_city char (10), c_nation char (15), c_region char (12), c_phone char (15), c_mktsegment char (10) ) ; create table dim_date ( d_datekey int, d_date char (18), d_dayofweek char (9), d_month char (9), d_year int, d_yearmonthnum int, d_yearmonth char (7), d_daynuminweek int, d_daynuminmonth int, d_daynuminyear int, d_monthnuminyear int, d_weeknuminyear int, d_sellingseason varchar (12), d_lastdayinweekfl varchar (1), d_lastdayinmonthfl varchar (1), d_holidayfl varchar (1), d_weekdayfl varchar (1) ) ; CREATE TABLE lineorder_flat ( LO_ORDERKEY bigint, LO_LINENUMBER int, LO_CUSTKEY int, LO_PARTKEY int, LO_SUPPKEY int, LO_ORDERDATE int, LO_ORDERPRIORITY char(15), LO_SHIPPRIORITY tinyint, LO_QUANTITY double, LO_EXTENDEDPRICE double, LO_ORDTOTALPRICE double, LO_DISCOUNT double, LO_REVENUE double, LO_SUPPLYCOST double, LO_TAX double, LO_COMMITDATE int, LO_SHIPMODE char(10), C_NAME varchar(25), C_ADDRESS varchar(25), C_CITY char(10), C_NATION char(15), C_REGION char(12), C_PHONE char(15), C_MKTSEGMENT char(10), S_NAME char(25), S_ADDRESS varchar(25), S_CITY char(10), S_NATION char(15), S_REGION char(12), S_PHONE char(15), P_NAME varchar(22), P_MFGR char(6), P_CATEGORY char(7), P_BRAND char(9), P_COLOR varchar(11), P_TYPE varchar(25), P_SIZE int, P_CONTAINER char(10) );","title":"3. Create tables in MatrixOne"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#4-load-data-into-the-created-tables","text":"If you use dbgen to generate date for ssb, there is still an extra step to replace the \u2018,\u2019 in the end of every line. In the directory of ssb-dbgen, use the following command. $ sed -i 's/.$//' customer.tbl $ sed -i 's/.$//' date.tbl $ sed -i 's/.$//' supplier.tbl $ sed -i 's/.$//' lineorder.tbl $ sed -i 's/.$//' part.tbl Then modify the parameter of system_vars_config.toml to a larger one in matrixone directory, such as 10GB. And restart MatrixOne service. max-entry-bytes = \"10GB\" Load data into related tables with this command in MatrixOne. load data infile '/ssb-dbgen-path/supplier.tbl ' into table supplier FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/customer.tbl ' into table customer FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/date.tbl ' into table dim_date FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/supplier.tbl ' into table supplier FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/part.tbl ' into table part FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; load data infile '/ssb-dbgen-path/lineorder.tbl ' into table lineorder FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n'; Then you can query data in MatrixOne with the created table. If you want to run a single table SSB query test, there is still one more data files needed for lineorder_flat. You can get the data files directly: https://pan.baidu.com/s/1dCpcKsygdVuHzd-H-RWHFA code: k1rs Load data into lineorder_flat. load data infile '/ssb-dbgen-path/lineorder_flat.tbl ' into table lineorder_flat FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n';","title":"4. Load data into the created tables"},{"location":"MatrixOne/Get-Started/Tutorial/SSB-test-with-matrixone/#5-run-ssb-queries","text":"# Q1.1 SELECT sum(LO_EXTENDEDPRICE * LO_DISCOUNT) AS revenue FROM lineorder_flat WHERE LO_ORDERDATE<=19930131 AND LO_ORDERDATE>=19930101 AND LO_DISCOUNT BETWEEN 1 AND 3 AND LO_QUANTITY < 25; # Q1.2 SELECT sum(LO_EXTENDEDPRICE * LO_DISCOUNT) AS revenue FROM lineorder_flat WHERE LO_ORDERDATE<=19920131 AND LO_ORDERDATE>=19920101 AND LO_DISCOUNT BETWEEN 4 AND 6 AND LO_QUANTITY BETWEEN 26 AND 35; # Q1.3 SELECT sum(LO_EXTENDEDPRICE * LO_DISCOUNT) AS revenue FROM lineorder_flat WHERE LO_ORDERDATE = 19920101 AND LO_DISCOUNT BETWEEN 5 AND 7 AND LO_QUANTITY BETWEEN 26 AND 35; # Q2.1 SELECT sum(LO_REVENUE), LO_ORDERDATE, P_BRAND FROM lineorder_flat WHERE P_CATEGORY = 'MFGR#11' AND S_REGION = 'AMERICA' GROUP BY LO_ORDERDATE, P_BRAND ORDER BY LO_ORDERDATE, P_BRAND; # Q2.2 SELECT sum(LO_REVENUE), LO_ORDERDATE, P_BRAND FROM lineorder_flat WHERE P_BRAND BETWEEN 'MFGR#2221' AND 'MFGR#2228' AND S_REGION = 'ASIA' GROUP BY LO_ORDERDATE, P_BRAND ORDER BY LO_ORDERDATE, P_BRAND; # Q2.3 SELECT sum(LO_REVENUE), LO_ORDERDATE, P_BRAND FROM lineorder_flat WHERE P_BRAND = 'MFGR#2239' AND S_REGION = 'EUROPE' GROUP BY LO_ORDERDATE, P_BRAND ORDER BY LO_ORDERDATE, P_BRAND; # Q3.1 SELECT C_NATION, S_NATION, LO_ORDERDATE, sum(LO_REVENUE) AS revenue FROM lineorder_flat WHERE C_REGION = 'ASIA' AND S_REGION = 'ASIA' AND LO_ORDERDATE >= 19920101 AND LO_ORDERDATE <= 19970101 GROUP BY C_NATION, S_NATION, LO_ORDERDATE ORDER BY LO_ORDERDATE asc, revenue desc; # Q3.2 SELECT C_CITY, S_CITY, LO_ORDERDATE, sum(LO_REVENUE) AS revenue FROM lineorder_flat WHERE C_NATION = 'CHINA' AND S_NATION = 'CHINA' AND LO_ORDERDATE >= 19920101 AND LO_ORDERDATE <= 19971231 GROUP BY C_CITY, S_CITY, LO_ORDERDATE ORDER BY LO_ORDERDATE asc, revenue desc; # Q3.3 SELECT C_CITY, S_CITY, LO_ORDERDATE, sum(LO_REVENUE) AS revenue FROM lineorder_flat WHERE (C_CITY = 'UNITED KI0' OR C_CITY = 'UNITED KI7') AND (S_CITY = 'UNITED KI0' OR S_CITY = 'UNITED KI7') AND LO_ORDERDATE >= 19920101 AND LO_ORDERDATE <= 19971231 GROUP BY C_CITY, S_CITY, LO_ORDERDATE ORDER BY LO_ORDERDATE asc, revenue desc; # Q3.4 SELECT C_CITY, S_CITY, LO_ORDERDATE, sum(LO_REVENUE) AS revenue FROM lineorder_flat WHERE (C_CITY = 'UNITED KI0' OR C_CITY = 'UNITED KI7') AND (S_CITY = 'MOZAMBIQU1' OR S_CITY = 'KENYA 4') AND LO_ORDERDATE >= 19971201 GROUP BY C_CITY, S_CITY, LO_ORDERDATE ORDER BY LO_ORDERDATE asc, revenue desc; # Q4.1 SELECT LO_ORDERDATE, C_NATION, sum(LO_REVENUE - LO_SUPPLYCOST) AS profit FROM lineorder_flat WHERE C_REGION = 'AMERICA' AND S_REGION = 'AMERICA' AND (P_MFGR = 'MFGR#1' OR P_MFGR = 'MFGR#2') GROUP BY LO_ORDERDATE, C_NATION ORDER BY LO_ORDERDATE, C_NATION; # Q4.2 SELECT LO_ORDERDATE, S_NATION, P_CATEGORY, sum(LO_REVENUE - LO_SUPPLYCOST) AS profit FROM lineorder_flat WHERE C_REGION = 'AMERICA' AND S_REGION = 'AMERICA' AND (LO_ORDERDATE>= 19970101 OR LO_ORDERDATE <= 19981231) AND (P_MFGR = 'MFGR#1' OR P_MFGR = 'MFGR#2') GROUP BY LO_ORDERDATE, S_NATION, P_CATEGORY ORDER BY LO_ORDERDATE, S_NATION, P_CATEGORY; # Q4.3 SELECT LO_ORDERDATE, S_CITY, P_BRAND, sum(LO_REVENUE - LO_SUPPLYCOST) AS profit FROM lineorder_flat WHERE S_NATION = 'UNITED STATES' AND (LO_ORDERDATE>= 19970101 OR LO_ORDERDATE <= 19981231) AND P_CATEGORY = 'MFGR#14' GROUP BY LO_ORDERDATE, S_CITY, P_BRAND ORDER BY LO_ORDERDATE, S_CITY, P_BRAND;","title":"5. Run SSB Queries"},{"location":"MatrixOne/Glossary/glossary/","text":"MatrixOne Glossary **","title":"**MatrixOne Glossary**"},{"location":"MatrixOne/Glossary/glossary/#matrixone-glossary","text":"**","title":"MatrixOne Glossary"},{"location":"MatrixOne/Overview/matrixone-architecture/","text":"MatrixOne Architecture Architecture MatrixOne is totally redesigned. It consists of multiple components and form a complete system. The architecture is as follows: Query Parser Layer Parser: Parses SQL, Streaming Query, or Python language into an abstract syntax tree for further processing. Planner: Finds the best execution plan through rule-based, cost-based optimization algorithms, and transfers abstract syntax tree to plan tree. IR Generator: Converts Python code into an intermediate representation. Computation Layer JIT Compilation: Turns SQL plan tree or IR code into a native program using LLVM at runtime. Vectorized Execution: MatrixOne leverages SIMD instructions to construct vectorized execution pipelines. Cache: Multi-version cache of data, indexes, and metadata for queries. Cluster Management Layer (MatrixCube) MatrixCube is a fundamental library for building distributed systems, which offers guarantees about reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers only need to focus on the business logic on a single node. MatrixCube is currently built upon multi-raft to provide replicated state machine and will migrate to Paxos families to increase friendliness to scenarios spanning multiple data centers. Prophet: Used by MatrixCube to manage and schedule the MatrixOne cluster. Transaction Manager: MatrixOne supports distributed transaction of snapshot isolation level. Replicated State Machine: MatrixOne uses RAFT-based consensus algorithms and hyper logic clocks to implement strong consistency of the clusters. Introduction of more advanced state-machine replication protocols is yet to come. Replicated Storage Layer Row Storage: Stores serving workload, metadata, and catalog. Column Storage: Stores analytical workload and materialized views. Storage Provision Layer As an infrastructure agnostic DBMS, MtrixOne stores data in shared storage of S3 / HDFS, or the local disk, on-premise server, hybrid and any cloud, or even smart devices. Learn More This page outlines the architecture design of MatrixOne. For information on other options that are available when trying out MatrixOne, see the following: Install MatrixOne MySQL Compatibility What\u2018s New","title":"MatrixOne Architecture"},{"location":"MatrixOne/Overview/matrixone-architecture/#matrixone-architecture","text":"","title":"MatrixOne Architecture"},{"location":"MatrixOne/Overview/matrixone-architecture/#architecture","text":"MatrixOne is totally redesigned. It consists of multiple components and form a complete system. The architecture is as follows:","title":"Architecture"},{"location":"MatrixOne/Overview/matrixone-architecture/#query-parser-layer","text":"Parser: Parses SQL, Streaming Query, or Python language into an abstract syntax tree for further processing. Planner: Finds the best execution plan through rule-based, cost-based optimization algorithms, and transfers abstract syntax tree to plan tree. IR Generator: Converts Python code into an intermediate representation.","title":"Query Parser Layer"},{"location":"MatrixOne/Overview/matrixone-architecture/#computation-layer","text":"JIT Compilation: Turns SQL plan tree or IR code into a native program using LLVM at runtime. Vectorized Execution: MatrixOne leverages SIMD instructions to construct vectorized execution pipelines. Cache: Multi-version cache of data, indexes, and metadata for queries.","title":"Computation Layer"},{"location":"MatrixOne/Overview/matrixone-architecture/#cluster-management-layer-matrixcube","text":"MatrixCube is a fundamental library for building distributed systems, which offers guarantees about reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers only need to focus on the business logic on a single node. MatrixCube is currently built upon multi-raft to provide replicated state machine and will migrate to Paxos families to increase friendliness to scenarios spanning multiple data centers. Prophet: Used by MatrixCube to manage and schedule the MatrixOne cluster. Transaction Manager: MatrixOne supports distributed transaction of snapshot isolation level. Replicated State Machine: MatrixOne uses RAFT-based consensus algorithms and hyper logic clocks to implement strong consistency of the clusters. Introduction of more advanced state-machine replication protocols is yet to come.","title":"Cluster Management Layer (MatrixCube)"},{"location":"MatrixOne/Overview/matrixone-architecture/#replicated-storage-layer","text":"Row Storage: Stores serving workload, metadata, and catalog. Column Storage: Stores analytical workload and materialized views.","title":"Replicated Storage Layer"},{"location":"MatrixOne/Overview/matrixone-architecture/#storage-provision-layer","text":"As an infrastructure agnostic DBMS, MtrixOne stores data in shared storage of S3 / HDFS, or the local disk, on-premise server, hybrid and any cloud, or even smart devices.","title":"Storage Provision Layer"},{"location":"MatrixOne/Overview/matrixone-architecture/#learn-more","text":"This page outlines the architecture design of MatrixOne. For information on other options that are available when trying out MatrixOne, see the following: Install MatrixOne MySQL Compatibility What\u2018s New","title":"Learn More"},{"location":"MatrixOne/Overview/matrixone-introduction/","text":"MatrixOne Introduction MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine, across multiple datacenters, clouds, edges and other heterogenous infrastructures. Key Features Hyperconverged Engine Monolitic Engine A monolithic database engine is designed to support hybrid workloads: transactional, analytical, streaming, time-series, machine learning, etc. Built-in Streaming Engine With the built-in streaming engine, MatrixOne supports in-database streaming processing by groundbreaking incremental materialized view maintenance. Cloud & Edge Native Real Infrastructure Agnostic MatrixOne supports seemless workload migration and bursting among different locations and infrastructures. Multi-site Active/Active MatrixOne provides industry-leading latency control with optimized consistency protocol. Extreme Performance High Performance Accelerated queries supported by patented vectorized execution as well as optimal computation push down strategies through factorization techniques. Strong Consistency MatrixOne introduces a global, high-performance distributed transaction protocol across storage engines. High Scalability Seamless and non-disruptive scaling by disaggregated storage and compute. User Values Simplify Database Management and Maintenance To solve the problem of high and unpredictable cost of database selection process, management & maintenance due to database overabundance, MatrixOne all-in-one architecture will significantly simplify database management and maintenance, single database can serve multiple data applications. Reduce Data Fragmentation and Inconsistency Data flow and copy between different databases makes data sync and consistency increasingly difficult. The unified incrementally materialized view of MatrixOne makes the downstream can support real-time upstream update, achieve the end-to-end data processing without redundant ETL process. Decoupling Data Architecture From Infrastructure Currently the architecture design across different infrastructures is complicated, causes new data silos between cloud and edge, cloud and on-premise.MatrixOne is designed with unified architecture to support simplified data management and operations across different type of infrastructures. Extremely Fast Complex Query Performance Poor business agility as a result of slow complex queries and redundant intermediate tables in current data warehousing solutions. MatrixOne supports blazing fast experience even for star and snowflake schema queries, improving business agility by real-time analytics. An Solid OLTP-like OLAP Experience Current data warehousing solutions have the following problems such as high latency and absense of immediate visibility for data updates. MatrixOne brings OLTP (Online Transactional Processing) level consistency and high availability to CRUD operations in OLAP (Online Analytical Processing). Seamless and Non-disruptive Scaling It is difficult to balance performance and scalability to achieve optimum price-performance ratio in current data warehousing solutions. MatrixOne's disaggregated storage and compute architecture makes it fully automated and efficient scale in/out and up/down without disrupting applications. Learn More This page outlines the overall introduction of MatrixOne. For information on other options that are available when you what to know more about MatrixOne product design, see the following: MatrixOne Architecture","title":"MatrixOne Introduction"},{"location":"MatrixOne/Overview/matrixone-introduction/#matrixone-introduction","text":"MatrixOne is a future-oriented hyperconverged cloud & edge native DBMS that supports transactional, analytical, and streaming workload with a simplified and distributed database engine, across multiple datacenters, clouds, edges and other heterogenous infrastructures.","title":"MatrixOne Introduction"},{"location":"MatrixOne/Overview/matrixone-introduction/#key-features","text":"","title":"Key Features"},{"location":"MatrixOne/Overview/matrixone-introduction/#hyperconverged-engine","text":"Monolitic Engine A monolithic database engine is designed to support hybrid workloads: transactional, analytical, streaming, time-series, machine learning, etc. Built-in Streaming Engine With the built-in streaming engine, MatrixOne supports in-database streaming processing by groundbreaking incremental materialized view maintenance.","title":"Hyperconverged Engine"},{"location":"MatrixOne/Overview/matrixone-introduction/#cloud-edge-native","text":"Real Infrastructure Agnostic MatrixOne supports seemless workload migration and bursting among different locations and infrastructures. Multi-site Active/Active MatrixOne provides industry-leading latency control with optimized consistency protocol.","title":"Cloud &amp; Edge Native"},{"location":"MatrixOne/Overview/matrixone-introduction/#extreme-performance","text":"High Performance Accelerated queries supported by patented vectorized execution as well as optimal computation push down strategies through factorization techniques. Strong Consistency MatrixOne introduces a global, high-performance distributed transaction protocol across storage engines. High Scalability Seamless and non-disruptive scaling by disaggregated storage and compute.","title":"Extreme Performance"},{"location":"MatrixOne/Overview/matrixone-introduction/#user-values","text":"Simplify Database Management and Maintenance To solve the problem of high and unpredictable cost of database selection process, management & maintenance due to database overabundance, MatrixOne all-in-one architecture will significantly simplify database management and maintenance, single database can serve multiple data applications. Reduce Data Fragmentation and Inconsistency Data flow and copy between different databases makes data sync and consistency increasingly difficult. The unified incrementally materialized view of MatrixOne makes the downstream can support real-time upstream update, achieve the end-to-end data processing without redundant ETL process. Decoupling Data Architecture From Infrastructure Currently the architecture design across different infrastructures is complicated, causes new data silos between cloud and edge, cloud and on-premise.MatrixOne is designed with unified architecture to support simplified data management and operations across different type of infrastructures. Extremely Fast Complex Query Performance Poor business agility as a result of slow complex queries and redundant intermediate tables in current data warehousing solutions. MatrixOne supports blazing fast experience even for star and snowflake schema queries, improving business agility by real-time analytics. An Solid OLTP-like OLAP Experience Current data warehousing solutions have the following problems such as high latency and absense of immediate visibility for data updates. MatrixOne brings OLTP (Online Transactional Processing) level consistency and high availability to CRUD operations in OLAP (Online Analytical Processing). Seamless and Non-disruptive Scaling It is difficult to balance performance and scalability to achieve optimum price-performance ratio in current data warehousing solutions. MatrixOne's disaggregated storage and compute architecture makes it fully automated and efficient scale in/out and up/down without disrupting applications.","title":"User Values"},{"location":"MatrixOne/Overview/matrixone-introduction/#learn-more","text":"This page outlines the overall introduction of MatrixOne. For information on other options that are available when you what to know more about MatrixOne product design, see the following: MatrixOne Architecture","title":"Learn More"},{"location":"MatrixOne/Overview/mysql-compatibility/","text":"MySQL Compatibility MatrixOne SQL syntax conforms with MySQL 8.0.23 version. SQL Type SQL Syntax Compability with MySQL8.0.23 DDL CREATE DATABASE A database with Chinese name will be displayed incorrectly. Names with Latins support limitedly. ENCRYPTION can be used but doesn't work till now. CREATE TABLE Temporary tables are not supported seperatedly. Partition tables are not supported. Create table .. as clause is not supported now. All column level constraints are not supported now. CREATE other projects Not supported now. ALTER Not supported now. DROP DATABASE Same as MySQL. DROP TABLE Same as MySQL. DML INSERT LOW_PRIORITY, DELAYED, HIGH_PRIORITY are not supported now. Insert with select is not supported now. Batch Insert can be supported less than 5,000 rows. ON DUPLICATE KEY UPDATE is not supported now. DELAYED is not supported now. HAVING clause is not supported now. Names with Latins support limitedly. The current mode is just like only_full_group_by mode in MySQL. DELETE Not supported now. UPDATE Not supported now. SELECT All multi tables queries are not supported now. Sub query is not supported now. Distinct is limitedly support. For clause is not supported now. INTO OUTFILE is not supported now. LOAD DATA Only csv files can be loaded currently. The enclosed character shoud be \"\". FILEDS TERMINATED BY should be \",\" or \" LINES TERMINATED BY should be \"\\n\". SET is not supported now. Local key word is not supported now. Database Administration Statements SHOW Only show tables and show databases are supported. Where can be supported limitedly. Other statements Not supported now. Utility Statements USE Use database is the same as MySQL. Explain The result of explain a SQL is quite different with MySQL. Other statements Not supported now. Data Types Int/Bigint/Smallint/Tinyint Same as MySQL. char/varchar Same as MySQL. Float/double The precsion is a bit different with MySQL. It will be adjusted in future release. Date Not supported now. Other types Not supported now. Operatiors \"+\",\"-\",\"*\",\"/\" Same as MySQL. DIV, %, MOD Not supported now. LIKE, IN Not supported now. NOT, AND, &&,OR, \"||\" Same as MySQL. XOR Not supported now. MAX, MIN, COUNT, AVG Same as MySQL. CAST Supported limitedly.","title":"MySQL Compatibility"},{"location":"MatrixOne/Overview/mysql-compatibility/#mysql-compatibility","text":"MatrixOne SQL syntax conforms with MySQL 8.0.23 version. SQL Type SQL Syntax Compability with MySQL8.0.23 DDL CREATE DATABASE A database with Chinese name will be displayed incorrectly. Names with Latins support limitedly. ENCRYPTION can be used but doesn't work till now. CREATE TABLE Temporary tables are not supported seperatedly. Partition tables are not supported. Create table .. as clause is not supported now. All column level constraints are not supported now. CREATE other projects Not supported now. ALTER Not supported now. DROP DATABASE Same as MySQL. DROP TABLE Same as MySQL. DML INSERT LOW_PRIORITY, DELAYED, HIGH_PRIORITY are not supported now. Insert with select is not supported now. Batch Insert can be supported less than 5,000 rows. ON DUPLICATE KEY UPDATE is not supported now. DELAYED is not supported now. HAVING clause is not supported now. Names with Latins support limitedly. The current mode is just like only_full_group_by mode in MySQL. DELETE Not supported now. UPDATE Not supported now. SELECT All multi tables queries are not supported now. Sub query is not supported now. Distinct is limitedly support. For clause is not supported now. INTO OUTFILE is not supported now. LOAD DATA Only csv files can be loaded currently. The enclosed character shoud be \"\". FILEDS TERMINATED BY should be \",\" or \" LINES TERMINATED BY should be \"\\n\". SET is not supported now. Local key word is not supported now. Database Administration Statements SHOW Only show tables and show databases are supported. Where can be supported limitedly. Other statements Not supported now. Utility Statements USE Use database is the same as MySQL. Explain The result of explain a SQL is quite different with MySQL. Other statements Not supported now. Data Types Int/Bigint/Smallint/Tinyint Same as MySQL. char/varchar Same as MySQL. Float/double The precsion is a bit different with MySQL. It will be adjusted in future release. Date Not supported now. Other types Not supported now. Operatiors \"+\",\"-\",\"*\",\"/\" Same as MySQL. DIV, %, MOD Not supported now. LIKE, IN Not supported now. NOT, AND, &&,OR, \"||\" Same as MySQL. XOR Not supported now. MAX, MIN, COUNT, AVG Same as MySQL. CAST Supported limitedly.","title":"MySQL Compatibility"},{"location":"MatrixOne/Overview/what%27s-new/","text":"What's New The lastest version of MatrixOne is 0.2.0, releases on 6th Jan, 2022. See the following: v0.2.0 Release Notes","title":"What's New"},{"location":"MatrixOne/Overview/what%27s-new/#whats-new","text":"The lastest version of MatrixOne is 0.2.0, releases on 6th Jan, 2022. See the following: v0.2.0 Release Notes","title":"What's New"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/","text":"Auto-Rebalance & Scheduling MatrixCube is a framework to implement distributed system. For a distributed system, data are stored across many machines. When the number of machines changes, with cluster scaling out or machine crash for example, data need to be moved across machines. Prophet is the key component of MatrixCube for Auto-Rebalance and Scheduling. An Etcd Server is embedded inside Prophet for storing the metadata of the cluster. It has three main objectives to reach: Keep the storage level of each Store balanced. Keep the write/read requests balanced. Keep the logical table distribution balanced. We designed a mechanism of Heartbeat and Event Notify to achieve these objectives. Each Store and Leader Replica will send Hearbeat information to Prophet , Prophet will make scheduling decision based on the information. We need to configure certain Store s to take the duty of Prophet . Store Hearbeat Each Store sends Heartbeat periodically to Prophet , the Heartbeat includes: At the moment, how many Replicas are in this Store . At the moment, how much storage space does this Store have, how much space is already used, how much space remaining. Prophet collects all Heartbeats , and Prophet will understand a global Replica mapping and the storage space of each Store . Based on this information, Prophet sends scheduling orders, moving some Replica s to proper Store s, in order to balance the Replica numbers for each Store . Since each Replica of a Shard is the same size, the storage space is thus equalized. Replica Hearbeat For each Shard , it has several Replicas distributed in several Stores . These Replica s form a Raft-Group and a Leader is elected. This Leader sends periodically Heartbeats to Prophet . This Heartbeat has information as: At the moment, how many Replicas a Shard has, and the latest active time of each Replica . At the moment, who is the Leader Replica . Prophet collects all Hearbeat s and constructs a global Shard Replica and Replica Leader mapping. With this information, Prophet launches scheduling orders under the following circumstances: Add Replica order: if the number of Shard Replica is not enough, look for appropriate Stores to add Replicas . Remove Replica order: if the number of Shard Replica exceeds the limit, delete Replicas in appropriate Stores . Move Replica order: if the number of Shard Replica is not balanced, some Replicas will be moved to achieve the balance. Transfer Leader order: if the Leader number is not balanced in the cluster, some Leaders will be transferred. Event Notify The Heartbeat information collected will be synchronized to all MatrixCube Stores . Each Store will form the global routing table.","title":"Auto Rebalancing and Scheduling"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/#auto-rebalance-scheduling","text":"MatrixCube is a framework to implement distributed system. For a distributed system, data are stored across many machines. When the number of machines changes, with cluster scaling out or machine crash for example, data need to be moved across machines. Prophet is the key component of MatrixCube for Auto-Rebalance and Scheduling. An Etcd Server is embedded inside Prophet for storing the metadata of the cluster. It has three main objectives to reach: Keep the storage level of each Store balanced. Keep the write/read requests balanced. Keep the logical table distribution balanced. We designed a mechanism of Heartbeat and Event Notify to achieve these objectives. Each Store and Leader Replica will send Hearbeat information to Prophet , Prophet will make scheduling decision based on the information. We need to configure certain Store s to take the duty of Prophet .","title":"Auto-Rebalance &amp; Scheduling"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/#store-hearbeat","text":"Each Store sends Heartbeat periodically to Prophet , the Heartbeat includes: At the moment, how many Replicas are in this Store . At the moment, how much storage space does this Store have, how much space is already used, how much space remaining. Prophet collects all Heartbeats , and Prophet will understand a global Replica mapping and the storage space of each Store . Based on this information, Prophet sends scheduling orders, moving some Replica s to proper Store s, in order to balance the Replica numbers for each Store . Since each Replica of a Shard is the same size, the storage space is thus equalized.","title":"Store Hearbeat"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/#replica-hearbeat","text":"For each Shard , it has several Replicas distributed in several Stores . These Replica s form a Raft-Group and a Leader is elected. This Leader sends periodically Heartbeats to Prophet . This Heartbeat has information as: At the moment, how many Replicas a Shard has, and the latest active time of each Replica . At the moment, who is the Leader Replica . Prophet collects all Hearbeat s and constructs a global Shard Replica and Replica Leader mapping. With this information, Prophet launches scheduling orders under the following circumstances: Add Replica order: if the number of Shard Replica is not enough, look for appropriate Stores to add Replicas . Remove Replica order: if the number of Shard Replica exceeds the limit, delete Replicas in appropriate Stores . Move Replica order: if the number of Shard Replica is not balanced, some Replicas will be moved to achieve the balance. Transfer Leader order: if the Leader number is not balanced in the cluster, some Leaders will be transferred.","title":"Replica Hearbeat"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-auto-rebalance-scheduling/#event-notify","text":"The Heartbeat information collected will be synchronized to all MatrixCube Stores . Each Store will form the global routing table.","title":"Event Notify"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/","text":"MatrixCube Introduction MatrixCube is a fundamental library for building distributed systems, which offers guarantees about reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers only need to focus on the business logic on a single node. MatrixCube is currently built upon multi-raft to provide replicated state machine and will migrate to Paxos families to increase friendliness to scenarios spanning multiple data centers. Unlike many other distributed systems, MatrixCube is designed as part of the storage nodes. A matrixone distributed deployment doesn't not have dedicated scheduling nodes. MatrixCube cannot work as a standalone module. MatrixCube Architecture Key Concepts There are several key concepts for understanding how MatrixCube works. Store A MatrixCube distributed system consists of several physical computers, our data are stored across these physical computers. We call each computer inside this cluster a Store . Shard Our data in database are organized in tables logically. But for physical storage, the data are split into different partitions to store in order to get better scalability. Each partition is called a Shard . In our design, a new created table is initially a Shard . When the size of the table exceeds the Shard size limit, the Shard will split. Replica To provide reliable service, each Shard is stored not only once, it will have several copy stored in different Stores . We call each copy a Replica . A Shard can have multiple Replica , the data in each Replica are the same. Raft-group and Leader Since multiple Replicas are located in different Stores , once a Replica is updated, the other Replicas must be updated to keep data consistency. When a client makes query to no matter which Replica , it always gets the same result. We deploy Raft protocol to implement the concensus process. The Replicas of a particular Shard group into a Raft-group . In each Raft-group , a Leader is elected to be the representative of this group. All consistent read and write requests are handled only by the leader. Learn more about: How does a Leader get elected in Raft? Data Storage A DataStorage is an interface for implementing distributed storage service. It must be defined in prior to using MatrixCube. DataStorage needs to be implemented based on the characteristics of storage engine. Some common distributed storage service can be easily constructed based on DataStorage , such as Distributed Redis , Distributed Key-Value , Distributed File System etc. A default Key-Value based DataStorage is provided to meet the requirements of most scenarios. Prophet Prophet is a scheduling module. It takes charge of Auto-Rebalance , which keeps the system storage level and read/write throughput level balanced across Stores . The inital 3 Stores of a MatrixCube cluster are all Prophet Nodes . Learn more about How does Prophet handle the scheduling? Raftstore Raftstore is the core component of MatrixCube, it implements the most important features of MatrixCube: Metadata storage: including the metadata of Store , Shard , Raft-log . Multi-Raft management: the relationship between Store , Shard , Replica , Raft-Group , the communication between multiple Raft-Group s, Leader election and re-election. Global Routing: a global routing table will be constructed with the Event Notify mechanism of Prophet . The read/write routing will be based on this routing table. Shard Proxy: a proxy for read/write request for Shard . With the proxy, the detailed implementation of Multi-Raft is senseless and all Store s are equal for users. User can make request to any Store , all requests will be routed to the right Store by Shard Proxy . Learn more about How do the Shard Proxy and Global Routing work? Key Features Strong Consistency MatrixCube provides a strong consistency. It is guaranted that after any successful data write, the reading afterwards will get the latest value, no matter from which store. Fault Tolerance The distributed storage service implemented by MatrixCube is a fault tolerant and high available service. When a Shard has 2*N+1 Replicas , the system can still work until N+1 Replicas fail. For example, a cluster with 3 Stores can survive with 1 Store failure; a cluster with 5 Stores can survive with 2 Stores failure. Shard Splitting There is a certain limit to a Shard size. Whenever a Shard exceeds its storage limit, MatrixCube splits a Shard into two Shards and keep each Shard with the same storage level. You can checkout a more detailed descripition about this process with How does the Shard Splitting work? . Auto-Rebalance A distributed system should leverage all the computation power and storage of all nodes. For a MatrixCube cluster, when there is an increase or decrease of Stores , an Auto-Rebalance will occur, which moves data across Stores to reach balance for each single Store . Learn more about: How does the Auto-Rebalance work? . Scale-out With shard splitting and auto-rebalance, a MatrixCube distributed system is capable of scaling out. The cluster storage and throughput capability are proportional to the number of Stores . User-defined storage engine MatrixCube has no limit to standalone data storage engine. Any storage engine implementing DataStorage interface defined by MatrixCube could construct a MatrixCube-based distributed system. By default, MatrixCube provides a Pebble -based Key-Value storage engine. ( Pebble is a Go version of RocksDB ). User-defined Read/Write As a general distributed framework, different distributed storage system could be build based on MatrixCube. User can also customize their read/write commands. As long as it works in a standalone version, MatrixCube can help you upgrading it to a distributed version.","title":"MatrixCube Introduction"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#matrixcube-introduction","text":"MatrixCube is a fundamental library for building distributed systems, which offers guarantees about reliability, consistency, and scalability. It is designed to facilitate distributed, stateful application building to allow developers only need to focus on the business logic on a single node. MatrixCube is currently built upon multi-raft to provide replicated state machine and will migrate to Paxos families to increase friendliness to scenarios spanning multiple data centers. Unlike many other distributed systems, MatrixCube is designed as part of the storage nodes. A matrixone distributed deployment doesn't not have dedicated scheduling nodes. MatrixCube cannot work as a standalone module.","title":"MatrixCube Introduction"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#matrixcube-architecture","text":"","title":"MatrixCube Architecture"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#key-concepts","text":"There are several key concepts for understanding how MatrixCube works.","title":"Key Concepts"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#store","text":"A MatrixCube distributed system consists of several physical computers, our data are stored across these physical computers. We call each computer inside this cluster a Store .","title":"Store"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#shard","text":"Our data in database are organized in tables logically. But for physical storage, the data are split into different partitions to store in order to get better scalability. Each partition is called a Shard . In our design, a new created table is initially a Shard . When the size of the table exceeds the Shard size limit, the Shard will split.","title":"Shard"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#replica","text":"To provide reliable service, each Shard is stored not only once, it will have several copy stored in different Stores . We call each copy a Replica . A Shard can have multiple Replica , the data in each Replica are the same.","title":"Replica"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#raft-group-and-leader","text":"Since multiple Replicas are located in different Stores , once a Replica is updated, the other Replicas must be updated to keep data consistency. When a client makes query to no matter which Replica , it always gets the same result. We deploy Raft protocol to implement the concensus process. The Replicas of a particular Shard group into a Raft-group . In each Raft-group , a Leader is elected to be the representative of this group. All consistent read and write requests are handled only by the leader. Learn more about: How does a Leader get elected in Raft?","title":"Raft-group and Leader"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#data-storage","text":"A DataStorage is an interface for implementing distributed storage service. It must be defined in prior to using MatrixCube. DataStorage needs to be implemented based on the characteristics of storage engine. Some common distributed storage service can be easily constructed based on DataStorage , such as Distributed Redis , Distributed Key-Value , Distributed File System etc. A default Key-Value based DataStorage is provided to meet the requirements of most scenarios.","title":"Data Storage"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#prophet","text":"Prophet is a scheduling module. It takes charge of Auto-Rebalance , which keeps the system storage level and read/write throughput level balanced across Stores . The inital 3 Stores of a MatrixCube cluster are all Prophet Nodes . Learn more about How does Prophet handle the scheduling?","title":"Prophet"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#raftstore","text":"Raftstore is the core component of MatrixCube, it implements the most important features of MatrixCube: Metadata storage: including the metadata of Store , Shard , Raft-log . Multi-Raft management: the relationship between Store , Shard , Replica , Raft-Group , the communication between multiple Raft-Group s, Leader election and re-election. Global Routing: a global routing table will be constructed with the Event Notify mechanism of Prophet . The read/write routing will be based on this routing table. Shard Proxy: a proxy for read/write request for Shard . With the proxy, the detailed implementation of Multi-Raft is senseless and all Store s are equal for users. User can make request to any Store , all requests will be routed to the right Store by Shard Proxy . Learn more about How do the Shard Proxy and Global Routing work?","title":"Raftstore"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#key-features","text":"","title":"Key Features"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#strong-consistency","text":"MatrixCube provides a strong consistency. It is guaranted that after any successful data write, the reading afterwards will get the latest value, no matter from which store.","title":"Strong Consistency"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#fault-tolerance","text":"The distributed storage service implemented by MatrixCube is a fault tolerant and high available service. When a Shard has 2*N+1 Replicas , the system can still work until N+1 Replicas fail. For example, a cluster with 3 Stores can survive with 1 Store failure; a cluster with 5 Stores can survive with 2 Stores failure.","title":"Fault Tolerance"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#shard-splitting","text":"There is a certain limit to a Shard size. Whenever a Shard exceeds its storage limit, MatrixCube splits a Shard into two Shards and keep each Shard with the same storage level. You can checkout a more detailed descripition about this process with How does the Shard Splitting work? .","title":"Shard Splitting"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#auto-rebalance","text":"A distributed system should leverage all the computation power and storage of all nodes. For a MatrixCube cluster, when there is an increase or decrease of Stores , an Auto-Rebalance will occur, which moves data across Stores to reach balance for each single Store . Learn more about: How does the Auto-Rebalance work? .","title":"Auto-Rebalance"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#scale-out","text":"With shard splitting and auto-rebalance, a MatrixCube distributed system is capable of scaling out. The cluster storage and throughput capability are proportional to the number of Stores .","title":"Scale-out"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#user-defined-storage-engine","text":"MatrixCube has no limit to standalone data storage engine. Any storage engine implementing DataStorage interface defined by MatrixCube could construct a MatrixCube-based distributed system. By default, MatrixCube provides a Pebble -based Key-Value storage engine. ( Pebble is a Go version of RocksDB ).","title":"User-defined storage engine"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-introduction/#user-defined-readwrite","text":"As a general distributed framework, different distributed storage system could be build based on MatrixCube. User can also customize their read/write commands. As long as it works in a standalone version, MatrixCube can help you upgrading it to a distributed version.","title":"User-defined Read/Write"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-proxy-routing/","text":"Shard Proxy and Global Routing A distributed system consists of multiple servers. A lot of complicated traffic and coordination mechanisms are implemented to make the data stored in all servers balanced and the service equally scaled. But users usually don't care and have little intention to understand the distributed detail. Therefore, we designed a Shard Proxy to get a simple user experience just like working with a standalone database.The Shard Proxy is a central module to accept all user read/write requests. For example, when a user is quering for a certain table from a database. For a distributed database system, this request is actually looking for a Shard in a ceratin Store . A user can send this request to any Store of the system. The Shard Proxy of the Store will take that request, it will look up for the Global Routing table to find the correct Store . As we have explained in the Raft Group and Leader , Leader is the representative of a Raft Group , all read and write requests are handled only by the leader. Therefore, when a request for certain rows are executed. * Firstly, we need to locate the Shard where these rows are stored. * Secondly, locate the Leader Replica of this Shard group. * Thirdly, route the request to the Store where the Leader Replica is located. * Finally, Leader Replica executes the request and returns response. Example We have a cluster of 3 Stores , and their status are as below: Range Store1 Store2 Store3 Shard1 [key1-key10) Leader Follower Follower Shard2 [key10-key20) Follower Leader Follower Shard3 [key20-key30) Follower Follower Leader A user sends requests on key1, key10 and key20, the following diagram illustrates how the requests gets through Shard Proxy and being routed.","title":"Shard Proxy and Routing"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-proxy-routing/#shard-proxy-and-global-routing","text":"A distributed system consists of multiple servers. A lot of complicated traffic and coordination mechanisms are implemented to make the data stored in all servers balanced and the service equally scaled. But users usually don't care and have little intention to understand the distributed detail. Therefore, we designed a Shard Proxy to get a simple user experience just like working with a standalone database.The Shard Proxy is a central module to accept all user read/write requests. For example, when a user is quering for a certain table from a database. For a distributed database system, this request is actually looking for a Shard in a ceratin Store . A user can send this request to any Store of the system. The Shard Proxy of the Store will take that request, it will look up for the Global Routing table to find the correct Store . As we have explained in the Raft Group and Leader , Leader is the representative of a Raft Group , all read and write requests are handled only by the leader. Therefore, when a request for certain rows are executed. * Firstly, we need to locate the Shard where these rows are stored. * Secondly, locate the Leader Replica of this Shard group. * Thirdly, route the request to the Store where the Leader Replica is located. * Finally, Leader Replica executes the request and returns response.","title":"Shard Proxy and Global Routing"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-proxy-routing/#example","text":"We have a cluster of 3 Stores , and their status are as below: Range Store1 Store2 Store3 Shard1 [key1-key10) Leader Follower Follower Shard2 [key10-key20) Follower Leader Follower Shard3 [key20-key30) Follower Follower Leader A user sends requests on key1, key10 and key20, the following diagram illustrates how the requests gets through Shard Proxy and being routed.","title":"Example"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-shard-splitting/","text":"Shard Splitting A Shard is a data partition, or a data slice. A distributed system ususally cut a big data trunk to pieces, and put these pieces to different machines to increase the overall storage capability and handle greater workloads. A Shard will also have several Replicas to maintain a high availability. All these Replicas form a Raft-Group . In our design, a created new table is a Shard . A Shard has a certain size limit defined by a user-defined parameter. As data size of a table increases, it will exceed the size limit of a Shard . At this moment, a Shard Splitting will occur. The original Shard will be cut in into two Shards , each Shard has a relatively equal storage level. In the meantime, all other Replicas of this Raft-Group will be splitted with the same behavior. The original Raft-Group will be removed, and two new Raft-Groups will be created . Once two new Raft-Groups are created, a re-election will immediately be hold. In most cases, the original Replica leader will still be elected as leaders . The belowing diagram illustrates how the shard splitting works:","title":"Shard Splitting"},{"location":"MatrixOne/Overview/matrixcube/matrixcube-shard-splitting/#shard-splitting","text":"A Shard is a data partition, or a data slice. A distributed system ususally cut a big data trunk to pieces, and put these pieces to different machines to increase the overall storage capability and handle greater workloads. A Shard will also have several Replicas to maintain a high availability. All these Replicas form a Raft-Group . In our design, a created new table is a Shard . A Shard has a certain size limit defined by a user-defined parameter. As data size of a table increases, it will exceed the size limit of a Shard . At this moment, a Shard Splitting will occur. The original Shard will be cut in into two Shards , each Shard has a relatively equal storage level. In the meantime, all other Replicas of this Raft-Group will be splitted with the same behavior. The original Raft-Group will be removed, and two new Raft-Groups will be created . Once two new Raft-Groups are created, a re-election will immediately be hold. In most cases, the original Replica leader will still be elected as leaders . The belowing diagram illustrates how the shard splitting works:","title":"Shard Splitting"},{"location":"MatrixOne/Reference/configuration-settings/","text":"The configuration file is located in matrixone/pkg/config/test/system_vars_config.toml . The 0.1.0 version is a standalone version, only the following parameters should be paied attention to. The other settings should remain default. General Settings Parameter Type Default Value Range Functionality rootpassword string \"\" string value password for root user dumpdatabase string default string value dump database name for backup port int64 6001 [0 - 65536] port defines which port the mo-server listens on and clients connect to host string 0.0.0.0 [0.0.0.0 - 255.255.255.255] listening ip sendRow bool false [true, false] send data row while producing dumpEnv bool false [true, false] dump Environment with memEngine Null nodes for testing Debug Settings Parameter Type Default Value Range Functionality level string debug [debug, info, warn, error, fatal] the log output level format string json [json, console] output log style filename string \"\" string value output log filename max-size int64 512 [0 - 314572800] maximum log file size max-days int64 0 [0 - 314572800] maximum log file days kept max-backups int64 0 [0 - 314572800] maximum numbers of old log files to retain Memory Settings Parameter Type Default Value Range Functionality hostMmuLimitation int64 1099511627776 [0 - 1099511627776] host mmu limitation. default: 1 << 40 = 1099511627776 guestMmuLimitation int64 1099511627776 [0 - 1099511627776] guest mmu limitation. default: 1 << 40 = 1099511627776 mempoolMaxSize int64 1099511627776 [0 - 1099511627776] mempool maxsize. default: 1 << 40 = 1099511627776 mempoolFactor int64 8 [0 - TBD] mempool factor. Default: 8 processLimitationSize int64 42949672960 [0 - 42949672960] process.Limitation.Size. default: 10 << 32 = 42949672960 processLimitationBatchRows int64 42949672960 [0 - 42949672960] process.Limitation.BatchRows. default: 10 << 32 = 42949672960 processLimitationBatchRows int64 42949672960 [0 - 42949672960] process.Limitation.BatchRows. default: 10 << 32 = 42949672960 processLimitationPartitionRows int64 42949672960 [0 - 42949672960] process.Limitation.PartitionRows. default: 10 << 32 = 42949672960","title":"Configuration Settings"},{"location":"MatrixOne/Reference/configuration-settings/#general-settings","text":"Parameter Type Default Value Range Functionality rootpassword string \"\" string value password for root user dumpdatabase string default string value dump database name for backup port int64 6001 [0 - 65536] port defines which port the mo-server listens on and clients connect to host string 0.0.0.0 [0.0.0.0 - 255.255.255.255] listening ip sendRow bool false [true, false] send data row while producing dumpEnv bool false [true, false] dump Environment with memEngine Null nodes for testing","title":"General Settings"},{"location":"MatrixOne/Reference/configuration-settings/#debug-settings","text":"Parameter Type Default Value Range Functionality level string debug [debug, info, warn, error, fatal] the log output level format string json [json, console] output log style filename string \"\" string value output log filename max-size int64 512 [0 - 314572800] maximum log file size max-days int64 0 [0 - 314572800] maximum log file days kept max-backups int64 0 [0 - 314572800] maximum numbers of old log files to retain","title":"Debug Settings"},{"location":"MatrixOne/Reference/configuration-settings/#memory-settings","text":"Parameter Type Default Value Range Functionality hostMmuLimitation int64 1099511627776 [0 - 1099511627776] host mmu limitation. default: 1 << 40 = 1099511627776 guestMmuLimitation int64 1099511627776 [0 - 1099511627776] guest mmu limitation. default: 1 << 40 = 1099511627776 mempoolMaxSize int64 1099511627776 [0 - 1099511627776] mempool maxsize. default: 1 << 40 = 1099511627776 mempoolFactor int64 8 [0 - TBD] mempool factor. Default: 8 processLimitationSize int64 42949672960 [0 - 42949672960] process.Limitation.Size. default: 10 << 32 = 42949672960 processLimitationBatchRows int64 42949672960 [0 - 42949672960] process.Limitation.BatchRows. default: 10 << 32 = 42949672960 processLimitationBatchRows int64 42949672960 [0 - 42949672960] process.Limitation.BatchRows. default: 10 << 32 = 42949672960 processLimitationPartitionRows int64 42949672960 [0 - 42949672960] process.Limitation.PartitionRows. default: 10 << 32 = 42949672960","title":"Memory Settings"},{"location":"MatrixOne/Reference/SQL-Reference/data-types/","text":"Data Types MatrixOne Data types conforms with MySQL Data types definition. Reference: https://dev.mysql.com/doc/refman/8.0/en/data-types.html Integer Numbers Data Type Size Min Value Max Value TINYINT 1 byte -128 127 SMALLINT 2 byte -32768 32767 INT 4 byte -2147483648 2147483647 BIGINT 8 byte -9223372036854775808 9223372036854775807 TINYINT UNSIGNED 1 byte 0 255 SMALLINT UNSIGNED 2 byte 0 65535 INT UNSIGNED 4 byte 0 4294967295 BIGINT UNSIGNED 8 byte 0 18446744073709551615 Real Numbers Data Type Size Precision Syntax FLOAT32 4 byte 23 bits FLOAT FLOAT64 8 byte 53 bits DOUBLE String Types Data Type Size Syntax String 24 byte CHAR, VARCHAR Time and Date Types Data Type Size Resolution Min Value Max Value Precision Date 2 byte day 1000-01-01 9999-12-31 YYYY-MM-DD DateTime 4 byte second 1970-01-01 00:00:00 2105-12-31 23:59:59 YYYY-MM-DD hh:mm:ss Examples //Create a table named \"numtable\" with 3 attributes of an \"int\", a \"float\" and a \"double\" > create table numtable(id int,fl float, dl double); //Insert a dataset of int, float and double into table \"numtable\" > insert into numtable values(3,1.234567,1.2345678912345678912); // Create a table named \"numtable\" with 2 attributes of an \"int\" and a \"float\" up to 5 digits in total, of which 3 digits may be after the decimal point. > create table numtable(id int,fl float(5,3)); //Insert a dataset of int, float into table \"numtable\" > insert into numtable values(3,99.123); //Create a table named \"numtable\" with 2 attributes of an \"int\" and a \"float\" up to 23 digits in total. > create table numtable(id int,fl float(23)); //Insert a dataset of int, float into table \"numtable\" > insert into numtable values(1,1.2345678901234567890123456789); //Create a table named \"numtable\" with 4 attributes of an \"unsigned tinyint\", an \"unsigned smallint\", an \"unsigned int\" and an \"unsigned bigint\" > create table numtable(a tinyint unsigned, b smallint unsigned, c int unsigned, d bigint unsigned); //Insert a dataset of unsigned (tinyint, smallint, int and bigint) into table \"numtable\" > insert into numtable values(255,65535,4294967295,18446744073709551615); //Create a table named \"names\" with 2 attributes of a \"varchar\" and a \"char\" > create table names(name varchar(255),age char(255)); //Insert a data of \"varchar\" and \"char\" into table \"names\" > insert into names(name, age) values('Abby', '24');","title":"Data Types"},{"location":"MatrixOne/Reference/SQL-Reference/data-types/#data-types","text":"MatrixOne Data types conforms with MySQL Data types definition. Reference: https://dev.mysql.com/doc/refman/8.0/en/data-types.html","title":"Data Types"},{"location":"MatrixOne/Reference/SQL-Reference/data-types/#integer-numbers","text":"Data Type Size Min Value Max Value TINYINT 1 byte -128 127 SMALLINT 2 byte -32768 32767 INT 4 byte -2147483648 2147483647 BIGINT 8 byte -9223372036854775808 9223372036854775807 TINYINT UNSIGNED 1 byte 0 255 SMALLINT UNSIGNED 2 byte 0 65535 INT UNSIGNED 4 byte 0 4294967295 BIGINT UNSIGNED 8 byte 0 18446744073709551615","title":"Integer Numbers"},{"location":"MatrixOne/Reference/SQL-Reference/data-types/#real-numbers","text":"Data Type Size Precision Syntax FLOAT32 4 byte 23 bits FLOAT FLOAT64 8 byte 53 bits DOUBLE","title":"Real Numbers"},{"location":"MatrixOne/Reference/SQL-Reference/data-types/#string-types","text":"Data Type Size Syntax String 24 byte CHAR, VARCHAR","title":"String Types"},{"location":"MatrixOne/Reference/SQL-Reference/data-types/#time-and-date-types","text":"Data Type Size Resolution Min Value Max Value Precision Date 2 byte day 1000-01-01 9999-12-31 YYYY-MM-DD DateTime 4 byte second 1970-01-01 00:00:00 2105-12-31 23:59:59 YYYY-MM-DD hh:mm:ss","title":"Time and Date Types"},{"location":"MatrixOne/Reference/SQL-Reference/data-types/#examples","text":"//Create a table named \"numtable\" with 3 attributes of an \"int\", a \"float\" and a \"double\" > create table numtable(id int,fl float, dl double); //Insert a dataset of int, float and double into table \"numtable\" > insert into numtable values(3,1.234567,1.2345678912345678912); // Create a table named \"numtable\" with 2 attributes of an \"int\" and a \"float\" up to 5 digits in total, of which 3 digits may be after the decimal point. > create table numtable(id int,fl float(5,3)); //Insert a dataset of int, float into table \"numtable\" > insert into numtable values(3,99.123); //Create a table named \"numtable\" with 2 attributes of an \"int\" and a \"float\" up to 23 digits in total. > create table numtable(id int,fl float(23)); //Insert a dataset of int, float into table \"numtable\" > insert into numtable values(1,1.2345678901234567890123456789); //Create a table named \"numtable\" with 4 attributes of an \"unsigned tinyint\", an \"unsigned smallint\", an \"unsigned int\" and an \"unsigned bigint\" > create table numtable(a tinyint unsigned, b smallint unsigned, c int unsigned, d bigint unsigned); //Insert a dataset of unsigned (tinyint, smallint, int and bigint) into table \"numtable\" > insert into numtable values(255,65535,4294967295,18446744073709551615); //Create a table named \"names\" with 2 attributes of a \"varchar\" and a \"char\" > create table names(name varchar(255),age char(255)); //Insert a data of \"varchar\" and \"char\" into table \"names\" > insert into names(name, age) values('Abby', '24');","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/","text":"AVG Description Aggregate function. The AVG() function calculates the average value of the argument. Syntax > AVG(expr) Arguments Arguments Description expr Any numerical expression Returned Value The arithmetic mean, always as Double. NaN if the input parameter is empty. Examples Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT AVG(*) FROM numbers(3); +--------+ | avg(*) | +--------+ | 1 | +--------+ > SELECT AVG(number) FROM numbers(3); +-------------+ | avg(number) | +-------------+ | 1 | +-------------+ > SELECT AVG(number+1) FROM numbers(3); +----------------------+ | avg(plus(number, 1)) | +----------------------+ | 2 | +----------------------+ > SELECT AVG(number+1) AS a FROM numbers(3); +------+ | a | +------+ | 2 | +------+","title":"AVG"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#avg","text":"","title":"AVG"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#description","text":"Aggregate function. The AVG() function calculates the average value of the argument.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#syntax","text":"> AVG(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#arguments","text":"Arguments Description expr Any numerical expression","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#returned-value","text":"The arithmetic mean, always as Double. NaN if the input parameter is empty.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/avg/#examples","text":"Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT AVG(*) FROM numbers(3); +--------+ | avg(*) | +--------+ | 1 | +--------+ > SELECT AVG(number) FROM numbers(3); +-------------+ | avg(number) | +-------------+ | 1 | +-------------+ > SELECT AVG(number+1) FROM numbers(3); +----------------------+ | avg(plus(number, 1)) | +----------------------+ | 2 | +----------------------+ > SELECT AVG(number+1) AS a FROM numbers(3); +------+ | a | +------+ | 2 | +------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/","text":"COUNT Description Aggregate function. The COUNT() function calculates the number of records returned by a select query. Note: NULL values are not counted. Syntax > COUNT(expr) Arguments Arguments Description expr Any expression.This may be a column name, the result of another function, or a math operation. * is also allowed, to indicate pure row counting. Returned Value Returns a count of the number of non-NULL values of expre in the rows retrieved by a SELECT statement. The result is a BIGINT value. If there are no matching rows, COUNT() returns 0. Examples Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT count(*) FROM numbers(3); +----------+ | count(*) | +----------+ | 3 | +----------+ > SELECT count(number) FROM numbers(3); +---------------+ | count(number) | +---------------+ | 3 | +---------------+ > SELECT count(number) AS c FROM numbers(3); +------+ | c | +------+ | 3 | +------+","title":"COUNT"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#count","text":"","title":"COUNT"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#description","text":"Aggregate function. The COUNT() function calculates the number of records returned by a select query. Note: NULL values are not counted.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#syntax","text":"> COUNT(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#arguments","text":"Arguments Description expr Any expression.This may be a column name, the result of another function, or a math operation. * is also allowed, to indicate pure row counting.","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#returned-value","text":"Returns a count of the number of non-NULL values of expre in the rows retrieved by a SELECT statement. The result is a BIGINT value. If there are no matching rows, COUNT() returns 0.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/count/#examples","text":"Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT count(*) FROM numbers(3); +----------+ | count(*) | +----------+ | 3 | +----------+ > SELECT count(number) FROM numbers(3); +---------------+ | count(number) | +---------------+ | 3 | +---------------+ > SELECT count(number) AS c FROM numbers(3); +------+ | c | +------+ | 3 | +------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/","text":"MAX Description Aggregate function. The MAX() function calculates the maximum value across a group of values. Syntax > MAX(expr) Arguments Arguments Description expr Any expression Returned Value Returns the maximum value of expr. MAX() may take a string argument, in such cases, it returns the maximum string value. Examples Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT MAX(*) FROM numbers(3); +--------+ | max(*) | +--------+ | 2 | +--------+ > SELECT MAX(number) FROM numbers(3); +-------------+ | max(number) | +-------------+ | 2 | +-------------+ > SELECT MAX(number) AS max FROM numbers(3); +------+ | max | +------+ | 2 | +------+","title":"MAX"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#max","text":"","title":"MAX"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#description","text":"Aggregate function. The MAX() function calculates the maximum value across a group of values.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#syntax","text":"> MAX(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#arguments","text":"Arguments Description expr Any expression","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#returned-value","text":"Returns the maximum value of expr. MAX() may take a string argument, in such cases, it returns the maximum string value.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/max/#examples","text":"Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT MAX(*) FROM numbers(3); +--------+ | max(*) | +--------+ | 2 | +--------+ > SELECT MAX(number) FROM numbers(3); +-------------+ | max(number) | +-------------+ | 2 | +-------------+ > SELECT MAX(number) AS max FROM numbers(3); +------+ | max | +------+ | 2 | +------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/","text":"MIN Description Aggregate function. The MAX() function calculates the maximum value across a group of values. Syntax > MIN(expr) Arguments Arguments Description expr Any expression Returned Value Returns the minimum value of expr. MIN() may take a string argument, in such cases, it returns the minimum string value. Examples Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT MIN(*) FROM numbers(3); +--------+ | min(*) | +--------+ | 0 | +--------+ > SELECT MIN(number) FROM numbers(3); +-------------+ | min(number) | +-------------+ | 0 | +-------------+ > SELECT MIN(number) AS min FROM numbers(3); +------+ | min | +------+ | 0 | +------+","title":"MIN"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#min","text":"","title":"MIN"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#description","text":"Aggregate function. The MAX() function calculates the maximum value across a group of values.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#syntax","text":"> MIN(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#arguments","text":"Arguments Description expr Any expression","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#returned-value","text":"Returns the minimum value of expr. MIN() may take a string argument, in such cases, it returns the minimum string value.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/min/#examples","text":"Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT MIN(*) FROM numbers(3); +--------+ | min(*) | +--------+ | 0 | +--------+ > SELECT MIN(number) FROM numbers(3); +-------------+ | min(number) | +-------------+ | 0 | +-------------+ > SELECT MIN(number) AS min FROM numbers(3); +------+ | min | +------+ | 0 | +------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/","text":"SUM Description Aggregate function. The SUM() function calculates the sum of a set of values. Note: NULL values are not counted. Syntax > SUM(expr) Arguments Arguments Description expr Any expression Returned Value Returns the sum of expr. A double if the input type is double, otherwise integer. f there are no matching rows, SUM() returns NULL. Examples Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT SUM(*) FROM numbers(3); +--------+ | sum(*) | +--------+ | 3 | +--------+ > SELECT SUM(number) FROM numbers(3); +-------------+ | sum(number) | +-------------+ | 3 | +-------------+ > SELECT SUM(number) AS sum FROM numbers(3); +------+ | sum | +------+ | 3 | +------+ > SELECT SUM(number+2) AS sum FROM numbers(3); +------+ | sum | +------+ | 9 | +------+","title":"SUM"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#sum","text":"","title":"SUM"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#description","text":"Aggregate function. The SUM() function calculates the sum of a set of values. Note: NULL values are not counted.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#syntax","text":"> SUM(expr)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#arguments","text":"Arguments Description expr Any expression","title":"Arguments"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#returned-value","text":"Returns the sum of expr. A double if the input type is double, otherwise integer. f there are no matching rows, SUM() returns NULL.","title":"Returned Value"},{"location":"MatrixOne/Reference/SQL-Reference/Aggregate-Functions/sum/#examples","text":"Note: numbers(N) \u2013 A table for test with the single number column (UInt64) that contains integers from 0 to N-1. > SELECT SUM(*) FROM numbers(3); +--------+ | sum(*) | +--------+ | 3 | +--------+ > SELECT SUM(number) FROM numbers(3); +-------------+ | sum(number) | +-------------+ | 3 | +-------------+ > SELECT SUM(number) AS sum FROM numbers(3); +------+ | sum | +------+ | 3 | +------+ > SELECT SUM(number+2) AS sum FROM numbers(3); +------+ | sum | +------+ | 9 | +------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/","text":"CREATE DATABASE Description Create a database. Syntax > CREATE DATABASE [IF NOT EXISTS] <database_name> [create_option] ... > create_option: [DEFAULT] { CHARACTER SET [=] charset_name | COLLATE [=] collation_name | ENCRYPTION [=] {'Y' | 'N'} } create_database_statement: Examples > CREATE DATABASE test01; > CREATE DATABASE IF NOT EXISTS test01; > CREATE DATABASE test03 DEFAULT CHARACTER SET utf8 collate utf8_general_ci ENCRYPTION 'Y'; > CREATE DATABASE test04 CHARACTER SET=utf8 collate=utf8_general_ci ENCRYPTION='N';","title":"CREATE DATABASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#create-database","text":"","title":"CREATE DATABASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#description","text":"Create a database.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#syntax","text":"> CREATE DATABASE [IF NOT EXISTS] <database_name> [create_option] ... > create_option: [DEFAULT] { CHARACTER SET [=] charset_name | COLLATE [=] collation_name | ENCRYPTION [=] {'Y' | 'N'} }","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#create_database_statement","text":"","title":"create_database_statement:"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-database/#examples","text":"> CREATE DATABASE test01; > CREATE DATABASE IF NOT EXISTS test01; > CREATE DATABASE test03 DEFAULT CHARACTER SET utf8 collate utf8_general_ci ENCRYPTION 'Y'; > CREATE DATABASE test04 CHARACTER SET=utf8 collate=utf8_general_ci ENCRYPTION='N';","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/","text":"CREATE INDEX Description Create an index on a table column. Syntax > CREATE INDEX index_name ON table_name (column_name) Examples > CREATE INDEX PIndex ON Persons (LastName); Constraints The index can only be applied for a single column. The index type, UNIQUE/FULLTEXT statements are not supported yet.","title":"CREATE INDEX"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#create-index","text":"","title":"CREATE INDEX"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#description","text":"Create an index on a table column.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#syntax","text":"> CREATE INDEX index_name ON table_name (column_name)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#examples","text":"> CREATE INDEX PIndex ON Persons (LastName);","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-index/#constraints","text":"The index can only be applied for a single column. The index type, UNIQUE/FULLTEXT statements are not supported yet.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/","text":"CREATE TABLE Description Create a new table. Syntax > CREATE TABLE [IF NOT EXISTS] [db.]table_name ( name1 type1, name2 type2, ... ) create_table_statement: Examples > CREATE TABLE test(a int, b varchar(10)); > INSERT INTO test values(123, 'abc'); > SELECT * FROM test; +------+---------+ | a | b | +------+---------+ | 123 | abc | +------+---------+","title":"CREATE TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#create-table","text":"","title":"CREATE TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#description","text":"Create a new table.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#syntax","text":"> CREATE TABLE [IF NOT EXISTS] [db.]table_name ( name1 type1, name2 type2, ... )","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#create_table_statement","text":"","title":"create_table_statement:"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/create-table/#examples","text":"> CREATE TABLE test(a int, b varchar(10)); > INSERT INTO test values(123, 'abc'); > SELECT * FROM test; +------+---------+ | a | b | +------+---------+ | 123 | abc | +------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/","text":"DROP DATABASE Description Drop a database. Syntax > DROP DATABASE [IF EXISTS] <database_name> drop_database_statement: Examples > DROP DATABASE test01;","title":"DROP DATABASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#drop-database","text":"","title":"DROP DATABASE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#description","text":"Drop a database.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#syntax","text":"> DROP DATABASE [IF EXISTS] <database_name>","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#drop_database_statement","text":"","title":"drop_database_statement:"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-database/#examples","text":"> DROP DATABASE test01;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/","text":"DROP INDEX Description DROP INDEX drops the index named index_name from the table table_name. Syntax > DROP INDEX index_name ON table_name; Examples > DROP INDEX PIndex ON Persons;","title":"DROP INDEX"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/#drop-index","text":"","title":"DROP INDEX"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/#description","text":"DROP INDEX drops the index named index_name from the table table_name.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/#syntax","text":"> DROP INDEX index_name ON table_name;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-index/#examples","text":"> DROP INDEX PIndex ON Persons;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/","text":"DROP TABLE Description Deletes the table. Syntax > DROP TABLE [IF EXISTS] [db.]name drop_table_statement: Examples > CREATE TABLE table01(a int); > DROP TABLE table01;","title":"DROP TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#drop-table","text":"","title":"DROP TABLE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#description","text":"Deletes the table.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#syntax","text":"> DROP TABLE [IF EXISTS] [db.]name","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#drop_table_statement","text":"","title":"drop_table_statement:"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Definition-Statements/drop-table/#examples","text":"> CREATE TABLE table01(a int); > DROP TABLE table01;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/cast/","text":"CAST Description The CAST() function converts a value (of any type) into the specified datatype. Syntax > CAST(value AS datatype) Parameter Values Parameter Description value Required. The value to convert datatype Required. The datatype to convert to The datatype can be one of the following: Value Description DATE Converts value to DATE. Format: \"YYYY-MM-DD\" DATETIME Converts value to DATETIME. Format: \"YYYY-MM-DD HH:MM:SS\" DECIMAL Converts value to DECIMAL. Use the optional M and D parameters to specify the maximum number of digits (M) and the number of digits following the decimal point (D). TIME Converts value to TIME. Format: \"HH:MM:SS\" CHAR Converts value to CHAR (a fixed length string) NCHAR Converts value to NCHAR (like CHAR, but produces a string with the national character set) SIGNED Converts value to SIGNED (a signed 64-bit integer) UNSIGNED Converts value to UNSIGNED (an unsigned 64-bit integer) BINARY Converts value to BINARY (a binary string) Examples #Convert a value to a DATE datatype: > SELECT CAST(\"2017-08-29\" AS DATE); #Convert a value to a CHAR datatype: > SELECT CAST(150 AS CHAR); #Convert a value to a SIGNED datatype: >SELECT CAST(5-10 AS SIGNED); Constraints","title":"CAST"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/cast/#cast","text":"","title":"CAST"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/cast/#description","text":"The CAST() function converts a value (of any type) into the specified datatype.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/cast/#syntax","text":"> CAST(value AS datatype)","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/cast/#parameter-values","text":"Parameter Description value Required. The value to convert datatype Required. The datatype to convert to The datatype can be one of the following: Value Description DATE Converts value to DATE. Format: \"YYYY-MM-DD\" DATETIME Converts value to DATETIME. Format: \"YYYY-MM-DD HH:MM:SS\" DECIMAL Converts value to DECIMAL. Use the optional M and D parameters to specify the maximum number of digits (M) and the number of digits following the decimal point (D). TIME Converts value to TIME. Format: \"HH:MM:SS\" CHAR Converts value to CHAR (a fixed length string) NCHAR Converts value to NCHAR (like CHAR, but produces a string with the national character set) SIGNED Converts value to SIGNED (a signed 64-bit integer) UNSIGNED Converts value to UNSIGNED (an unsigned 64-bit integer) BINARY Converts value to BINARY (a binary string)","title":"Parameter Values"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/cast/#examples","text":"#Convert a value to a DATE datatype: > SELECT CAST(\"2017-08-29\" AS DATE); #Convert a value to a CHAR datatype: > SELECT CAST(150 AS CHAR); #Convert a value to a SIGNED datatype: >SELECT CAST(5-10 AS SIGNED);","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/cast/#constraints","text":"","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/","text":"INSERT Description Writing data. Syntax > INSERT INTO [db.]table [(c1, c2, c3)] VALUES (v11, v12, v13), (v21, v22, v23), ... Examples > CREATE TABLE test(a int, b varchar(10)); > INSERT INTO test values(123, 'abc'); > SELECT * FROM test; +------+---------+ | a | b | +------+---------+ | 123 | abc | +------+---------+","title":"INSERT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/#insert","text":"","title":"INSERT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/#description","text":"Writing data.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/#syntax","text":"> INSERT INTO [db.]table [(c1, c2, c3)] VALUES (v11, v12, v13), (v21, v22, v23), ...","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/insert/#examples","text":"> CREATE TABLE test(a int, b varchar(10)); > INSERT INTO test values(123, 'abc'); > SELECT * FROM test; +------+---------+ | a | b | +------+---------+ | 123 | abc | +------+---------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/like/","text":"LIKE Description The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. There are two wildcards often used in conjunction with the LIKE operator: The percent sign (%) represents zero, one, or multiple characters The underscore sign (_) represents one, single character Syntax > SELECT column1, column2, ... FROM table_name WHERE columnN LIKE pattern; Examples > SELECT * FROM Customers WHERE CustomerName LIKE 'a%'; //The following SQL statement selects all customers with a CustomerName starting with \"a\" > SELECT * FROM Customers WHERE CustomerName LIKE '%a'; //The following SQL statement selects all customers with a CustomerName ending with \"a\" > SELECT * FROM Customers WHERE CustomerName LIKE '%or%'; //The following SQL statement selects all customers with a CustomerName that have \"or\" in any position > SELECT * FROM Customers WHERE CustomerName LIKE '_r%'; //The following SQL statement selects all customers with a CustomerName that have \"r\" in the second position > SELECT * FROM Customers WHERE CustomerName LIKE 'a__%'; //The following SQL statement selects all customers with a CustomerName that starts with \"a\" and are at least 3 characters in length > SELECT * FROM Customers WHERE ContactName LIKE 'a%o'; //The following SQL statement selects all customers with a ContactName that starts with \"a\" and ends with \"o\" > SELECT * FROM Customers WHERE CustomerName NOT LIKE 'a%'; //The following SQL statement selects all customers with a CustomerName that does NOT start with \"a\" Constraints NOT LIKE is not supported for now.","title":"LIKE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/like/#like","text":"","title":"LIKE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/like/#description","text":"The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. There are two wildcards often used in conjunction with the LIKE operator: The percent sign (%) represents zero, one, or multiple characters The underscore sign (_) represents one, single character","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/like/#syntax","text":"> SELECT column1, column2, ... FROM table_name WHERE columnN LIKE pattern;","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/like/#examples","text":"> SELECT * FROM Customers WHERE CustomerName LIKE 'a%'; //The following SQL statement selects all customers with a CustomerName starting with \"a\" > SELECT * FROM Customers WHERE CustomerName LIKE '%a'; //The following SQL statement selects all customers with a CustomerName ending with \"a\" > SELECT * FROM Customers WHERE CustomerName LIKE '%or%'; //The following SQL statement selects all customers with a CustomerName that have \"or\" in any position > SELECT * FROM Customers WHERE CustomerName LIKE '_r%'; //The following SQL statement selects all customers with a CustomerName that have \"r\" in the second position > SELECT * FROM Customers WHERE CustomerName LIKE 'a__%'; //The following SQL statement selects all customers with a CustomerName that starts with \"a\" and are at least 3 characters in length > SELECT * FROM Customers WHERE ContactName LIKE 'a%o'; //The following SQL statement selects all customers with a ContactName that starts with \"a\" and ends with \"o\" > SELECT * FROM Customers WHERE CustomerName NOT LIKE 'a%'; //The following SQL statement selects all customers with a CustomerName that does NOT start with \"a\"","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/like/#constraints","text":"NOT LIKE is not supported for now.","title":"Constraints"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/","text":"LOAD DATA Description The LOAD DATA statement reads rows from a text file into a table at a very high speed. Syntax > LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name' [REPLACE | IGNORE] INTO TABLE tbl_name [PARTITION (partition_name [, partition_name] ...)] [CHARACTER SET charset_name] [{FIELDS | COLUMNS} [TERMINATED BY 'string'] [[OPTIONALLY] ENCLOSED BY 'char'] [ESCAPED BY 'char'] ] [LINES [STARTING BY 'string'] [TERMINATED BY 'string'] ] [IGNORE number {LINES | ROWS}] [(col_name_or_user_var [, col_name_or_user_var] ...)] [SET col_name={expr | DEFAULT} [, col_name={expr | DEFAULT}] ...] Examples The SSB Test is an example of LOAD DATA syntax. Complete a SSB Test with MatrixOne > LOAD DATA INFILE '/ssb-dbgen-path/lineorder_flat.tbl ' INTO TABLE lineorder_flat;","title":"LOAD DATA"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/#load-data","text":"","title":"LOAD DATA"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/#description","text":"The LOAD DATA statement reads rows from a text file into a table at a very high speed.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/#syntax","text":"> LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name' [REPLACE | IGNORE] INTO TABLE tbl_name [PARTITION (partition_name [, partition_name] ...)] [CHARACTER SET charset_name] [{FIELDS | COLUMNS} [TERMINATED BY 'string'] [[OPTIONALLY] ENCLOSED BY 'char'] [ESCAPED BY 'char'] ] [LINES [STARTING BY 'string'] [TERMINATED BY 'string'] ] [IGNORE number {LINES | ROWS}] [(col_name_or_user_var [, col_name_or_user_var] ...)] [SET col_name={expr | DEFAULT} [, col_name={expr | DEFAULT}] ...]","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/load-data/#examples","text":"The SSB Test is an example of LOAD DATA syntax. Complete a SSB Test with MatrixOne > LOAD DATA INFILE '/ssb-dbgen-path/lineorder_flat.tbl ' INTO TABLE lineorder_flat;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/","text":"SELECT Description Retrieves data from a table. Syntax > SELECT [ALL | DISTINCT] select_expr [[AS] alias], ... [INTO variable [, ...]] [ FROM table_references [WHERE expr] [GROUP BY {{col_name | expr | position}, ... | extended_grouping_expr}] [HAVING expr] [ORDER BY {col_name | expr} [ASC | DESC], ...] [LIMIT row_count] [OFFSET row_count] ] Examples > SELECT number FROM numbers(3); +--------+ | number | +--------+ | 0 | | 1 | | 2 | +--------+ > SELECT * FROM t1 WHERE spID>2 AND userID <2 || userID >=2 OR userID < 2 LIMIT 3; > SELECT userID,MAX(score) max_score FROM t1 WHERE userID <2 || userID > 3 GROUP BY userID ORDER BY max_score;","title":"SELECT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#select","text":"","title":"SELECT"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#description","text":"Retrieves data from a table.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#syntax","text":"> SELECT [ALL | DISTINCT] select_expr [[AS] alias], ... [INTO variable [, ...]] [ FROM table_references [WHERE expr] [GROUP BY {{col_name | expr | position}, ... | extended_grouping_expr}] [HAVING expr] [ORDER BY {col_name | expr} [ASC | DESC], ...] [LIMIT row_count] [OFFSET row_count] ]","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/select/#examples","text":"> SELECT number FROM numbers(3); +--------+ | number | +--------+ | 0 | | 1 | | 2 | +--------+ > SELECT * FROM t1 WHERE spID>2 AND userID <2 || userID >=2 OR userID < 2 LIMIT 3; > SELECT userID,MAX(score) max_score FROM t1 WHERE userID <2 || userID > 3 GROUP BY userID ORDER BY max_score;","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/","text":"SHOW DATABASES Description Shows the list of databases that exist on the instance. Syntax > SHOW DATABASES [LIKE expr | WHERE expr] Examples > SHOW DATABASES; +----------+ | Database | +----------+ | default | | for_test | | local | | ss | | ss1 | | ss2 | | ss3 | | system | | test | +----------+ 9 rows in set (0.00 sec)","title":"SHOW DATABASES"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/#show-databases","text":"","title":"SHOW DATABASES"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/#description","text":"Shows the list of databases that exist on the instance.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/#syntax","text":"> SHOW DATABASES [LIKE expr | WHERE expr]","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-databases/#examples","text":"> SHOW DATABASES; +----------+ | Database | +----------+ | default | | for_test | | local | | ss | | ss1 | | ss2 | | ss3 | | system | | test | +----------+ 9 rows in set (0.00 sec)","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/","text":"SHOW TABLES Description Shows the list of tables in the currently selected database. Syntax > SHOW TABLES [LIKE 'pattern' | WHERE expr | FROM 'pattern' | IN 'pattern'] Examples > SHOW TABLES; +---------------+ | name | +---------------+ | clusters | | contributors | | databases | | functions | | numbers | | numbers_local | | numbers_mt | | one | | processes | | settings | | tables | | tracing | +---------------+","title":"SHOW TABLES"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/#show-tables","text":"","title":"SHOW TABLES"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/#description","text":"Shows the list of tables in the currently selected database.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/#syntax","text":"> SHOW TABLES [LIKE 'pattern' | WHERE expr | FROM 'pattern' | IN 'pattern']","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/show-tables/#examples","text":"> SHOW TABLES; +---------------+ | name | +---------------+ | clusters | | contributors | | databases | | functions | | numbers | | numbers_local | | numbers_mt | | one | | processes | | settings | | tables | | tracing | +---------------+","title":"Examples"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/","text":"USE Description The USE statement tells MatrixOne to use the named database as the default (current) database for subsequent statements. Syntax > USE db_name Examples > USE db1; > SELECT COUNT(*) FROM mytable;","title":"USE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/#use","text":"","title":"USE"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/#description","text":"The USE statement tells MatrixOne to use the named database as the default (current) database for subsequent statements.","title":"Description"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/#syntax","text":"> USE db_name","title":"Syntax"},{"location":"MatrixOne/Reference/SQL-Reference/Data-Manipulation-Statements/use/#examples","text":"> USE db1; > SELECT COUNT(*) FROM mytable;","title":"Examples"},{"location":"MatrixOne/Release-Notes/v0.1.0/","text":"MatrixOne v0.1.0 Release Notes We are excited to announce the first release of MatrixOne 0.1.0 on 2021/10/24. Cheers! Docker docker pull matrixorigin/matrixone:0.1.0 Features SQL Following SQL statements are supported in this release. DDL CREATE / DROP DATABASE CREATE / DROP TABLE DML INSERT LOAD DATA SELECT WHERE GROUP BY ORDER BY LIMIT, OFFSET SHOW DATABASES TABLES USE Data Types TINYINT / SMALLINT / INT / BIGINT, SIGNED / UNSIGNED FLOAT / DOUBLE CHAR / VARCHAR Operators <, >=, <, <=, <>, !=, = BETWEEN \u2026 AND \u2026, NOT BETWEEN \u2026 AND \u2026 AND, &&, OR, || +, -, *, /, %, MOD, DIV, NEG CAST Aggregation Functions COUNT SUM AVG MAX MIN Database Engine MySQL dialect is supported. Build-in Append only columnar engine(AOE) has been supported as the first fusion database engine. Real-time analytical queries are supported. Vectorized query execution engine, based on MPP solution, is introduced. Part of the expression execution has been vectorized through SIMD instructions. Distributed AOE with strong consistency guaranteed by RAFT has been supported. The performance of replicated state machine has been greatly improved through the unique design of reusing RAFT log as well as Write-Ahead log without any redundancy. Contributors This release includes 453 commits by 16 authors. Special thanks to the first author: Yan Wenze (@nnsgmsone) Chen Mingsong\uff08@m-schen\uff09 Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Li Yang (@lignay) Lin Junhong (@iamlinjunhong) lni (@lni) Long Ran (@aunjgr) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Shen JiangWei(@LeftHandCold) Wei Ziran (@w-zr) Xiong Jingjuan (@anitajjx) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"v0.1.0"},{"location":"MatrixOne/Release-Notes/v0.1.0/#matrixone-v010-release-notes","text":"We are excited to announce the first release of MatrixOne 0.1.0 on 2021/10/24. Cheers!","title":"MatrixOne v0.1.0 Release Notes"},{"location":"MatrixOne/Release-Notes/v0.1.0/#docker","text":"docker pull matrixorigin/matrixone:0.1.0","title":"Docker"},{"location":"MatrixOne/Release-Notes/v0.1.0/#features","text":"","title":"Features"},{"location":"MatrixOne/Release-Notes/v0.1.0/#sql","text":"Following SQL statements are supported in this release.","title":"SQL"},{"location":"MatrixOne/Release-Notes/v0.1.0/#ddl","text":"CREATE / DROP DATABASE CREATE / DROP TABLE","title":"DDL"},{"location":"MatrixOne/Release-Notes/v0.1.0/#dml","text":"INSERT LOAD DATA SELECT WHERE GROUP BY ORDER BY LIMIT, OFFSET SHOW DATABASES TABLES USE","title":"DML"},{"location":"MatrixOne/Release-Notes/v0.1.0/#data-types","text":"TINYINT / SMALLINT / INT / BIGINT, SIGNED / UNSIGNED FLOAT / DOUBLE CHAR / VARCHAR","title":"Data Types"},{"location":"MatrixOne/Release-Notes/v0.1.0/#operators","text":"<, >=, <, <=, <>, !=, = BETWEEN \u2026 AND \u2026, NOT BETWEEN \u2026 AND \u2026 AND, &&, OR, || +, -, *, /, %, MOD, DIV, NEG CAST","title":"Operators"},{"location":"MatrixOne/Release-Notes/v0.1.0/#aggregation-functions","text":"COUNT SUM AVG MAX MIN","title":"Aggregation Functions"},{"location":"MatrixOne/Release-Notes/v0.1.0/#database-engine","text":"MySQL dialect is supported. Build-in Append only columnar engine(AOE) has been supported as the first fusion database engine. Real-time analytical queries are supported. Vectorized query execution engine, based on MPP solution, is introduced. Part of the expression execution has been vectorized through SIMD instructions. Distributed AOE with strong consistency guaranteed by RAFT has been supported. The performance of replicated state machine has been greatly improved through the unique design of reusing RAFT log as well as Write-Ahead log without any redundancy.","title":"Database Engine"},{"location":"MatrixOne/Release-Notes/v0.1.0/#contributors","text":"This release includes 453 commits by 16 authors. Special thanks to the first author: Yan Wenze (@nnsgmsone) Chen Mingsong\uff08@m-schen\uff09 Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Li Yang (@lignay) Lin Junhong (@iamlinjunhong) lni (@lni) Long Ran (@aunjgr) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Shen JiangWei(@LeftHandCold) Wei Ziran (@w-zr) Xiong Jingjuan (@anitajjx) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"Contributors"},{"location":"MatrixOne/Release-Notes/v0.2.0/","text":"MatrixOne v0.2.0 Release Notes We are excited to announce MatrixOne 0.2.0 release. Cheers! Docker docker pull matrixorigin/matrixone:0.2.0 Features Support automatic rebalancing for the built-in AOE columnar storage engine. Introduce new SQL parser. Introduce factorized SQL execution engine which is the fastest MPP in Golang. Support CREATE / DROP INDEX. Support PRIMARY KEY in CREATE TABLE. Support more data types for SQL binary operators. Support equi join with group by or aggregation statements. Support new types of DATE and DATETIME. Database Engine For continuous table creation actions in a script, the parameter of pre-allocated-group-num should be set to a bigger value such in cluster scenarios. Otherwise, \"no available raft group\" may be notified during tables creation sequence. Contributors This release includes 243 commits by 21 authors. BingLin Chang (@decster) Chen Mingsong\uff08@m-schen\uff09 Nan Deng (@dengn) Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Li Yang (@lignay) Lin Junhong (@iamlinjunhong) lni (@lni) Long Ran (@aunjgr) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Shen JiangWei(@LeftHandCold) Jian Wang(@jianwan0214) broccoliSpicy(@broccoliSpicy) Ryan Wang(@wanglei4687) Xiong Jingjuan (@anitajjx) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Yuesheng Li(@reusee) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"v0.2.0"},{"location":"MatrixOne/Release-Notes/v0.2.0/#matrixone-v020-release-notes","text":"We are excited to announce MatrixOne 0.2.0 release. Cheers!","title":"MatrixOne v0.2.0 Release Notes"},{"location":"MatrixOne/Release-Notes/v0.2.0/#docker","text":"docker pull matrixorigin/matrixone:0.2.0","title":"Docker"},{"location":"MatrixOne/Release-Notes/v0.2.0/#features","text":"Support automatic rebalancing for the built-in AOE columnar storage engine. Introduce new SQL parser. Introduce factorized SQL execution engine which is the fastest MPP in Golang. Support CREATE / DROP INDEX. Support PRIMARY KEY in CREATE TABLE. Support more data types for SQL binary operators. Support equi join with group by or aggregation statements. Support new types of DATE and DATETIME.","title":"Features"},{"location":"MatrixOne/Release-Notes/v0.2.0/#database-engine","text":"For continuous table creation actions in a script, the parameter of pre-allocated-group-num should be set to a bigger value such in cluster scenarios. Otherwise, \"no available raft group\" may be notified during tables creation sequence.","title":"Database Engine"},{"location":"MatrixOne/Release-Notes/v0.2.0/#contributors","text":"This release includes 243 commits by 21 authors. BingLin Chang (@decster) Chen Mingsong\uff08@m-schen\uff09 Nan Deng (@dengn) Jin Hai (@JinHai-CN) Jiang xinmeng (@jiangxinmeng1) Li Yang (@lignay) Lin Junhong (@iamlinjunhong) lni (@lni) Long Ran (@aunjgr) Peng Zhen (@daviszhen) Qin Shuqi (@sukki37) Shen JiangWei(@LeftHandCold) Jian Wang(@jianwan0214) broccoliSpicy(@broccoliSpicy) Ryan Wang(@wanglei4687) Xiong Jingjuan (@anitajjx) Xu Peng (@XuPeng-SH) Yan Wenze(@nnsgmsone) Yuesheng Li(@reusee) Zilong Zhou (@zzl200012) Zhang Yingfeng (@yingfeng)","title":"Contributors"}]}